/*
 * search.c
 *
 *  Created on: 2017年8月22日
 *      Author: hmj110131
 */
#include <stdio.h>
#include <stdlib.h>
#include <table.h>
#include "math.h"
#include "typedef.h"
#include "ciphers.h"
#include "search.h"
#include "globalvar.h"
#include "printinfo.h"
#include <time.h>
#include <nmmintrin.h>

#if 1
#include "speck.h"
#endif

#if 1
#include "gimli.h"
#endif

#if 1
#include "hight.h"
#endif

#if 1
#include "sparx.h"
#endif

#if 1
#include "chaskey.h"
#endif

#if 1
#include "CHAM.h"
#endif

#if 1
#include "Alzette.h"
#endif



#if (USEMPI==1)
#include <mpich/mpi.h>
#endif

#if (USEOPENMP==1)
#include <omp.h>
#endif

//#include <omp.h>
/**
 * @deal with the preparatory information!
 * @param[in]
 * @param[out]  #ciper #mode
 *
 *搜索参数设置：
 *
 *
 *
 *
 */
int pre_processing_info(void)
{
	printf("|************************************************************************|\n");
	printf("Auto-search Begin... \n");
	printf( "Enter the parameters : #ciper #blocksize #rounds  #mode \n");
//	printf( "Description:   \n");

////////用nohup后台执行时，需要先写死参数，编译后直接执行/////////
	strcpy(str_cipher, "alzette");    //设定待搜索的密码算法
	strcpy(str_blocksize, "64");   //设定分组长度  //注意需要到对应.h文件中改宏定义的分组长度选择编译相应代码
	sc_rounds = 8;   //设定要搜索的轮数

	//str_mode = 0 默认差分路径:
			//****包括对SIMON、SIMECK、SPECK、SPARX64/128、CHAM64/128、Alzette的最优差分路径搜索
	//1 为对SIMON、SIMECK、SPECK的差分聚合differential effect概率的搜索
	//5 SPARX64/128的差分聚合differential effect概率的搜索搜索
	//2 为对speck、SPARX64、SPARX128、Chaskey128、CHAM、Alzette最优线性路 Linear Trail径搜索
	//3 为对SIMON、SIMECK的LinearHull的搜索
	//30 为对speck的Linear Hull的搜索
	//31 为对SPARX64、SPARX128的Linear Hull的搜索
	//32 为对CHAM64、CHAM128的Linear Hull的搜索
	str_mode = 2;

	//对于CHAM，需要分别搜索奇数和偶数轮开始的截断路径 //在CHAM.h文件中设置
	//CHAM_even_round = 0;  //0 为奇数轮开始的(参数1,8），1为偶数轮开始的（参数8,1）



////////////////////////////////////

///////需要在下面代码中开启scanf函数，从终端获取输入参数//////////
	/* Get the input ciper name.*/
	printf("ciper:");
//	scanf("%s",str_cipher); //从终端输入
	printf("%s \n",str_cipher); ///在程序里面写死

	if( strcmp(str_cipher,"simon") == 0)
	{
		cipher_name = simon;

		/*the Rotation parameter of simon-LIKE cipher, abc */
		rol_a = 8;	/* a */
		rol_b = 1;   /* b */
		rol_c = 2;	/* c */
		rol_delt = 7;   /* a-b */
	}
	else
	if( strcmp(str_cipher,"simeck") == 0)
	{
		cipher_name = simeck;
		/*the Rotation parameter of simon-LIKE cipher, abc */
		rol_a = 5;	/* a */
		rol_b = 0;   /* b */
		rol_c = 1;	/* c */
		rol_delt = 5;   /* a-b */
	}
	else
	if( strcmp(str_cipher,"speck") == 0)
	{
		cipher_name = speck;
		/*the Rotation parameter of simon-LIKE cipher, abc */
		rol_a = 8;	/* a */
		rol_b = 3;   /* b */
		rol_delt = 5;   /* a-b */
	}
	else
	if( strcmp(str_cipher,"gimli") == 0)
	{
		cipher_name = gimli;
	}
	else
	if( strcmp(str_cipher,"hight") == 0)
	{
		cipher_name = hight;
	}
	else
	if( strcmp(str_cipher,"sparx") == 0)
	{
		cipher_name = sparx;
		rol_a = 7;	/* a */
		rol_b = 2;   /* b */
		printf("Note: blocksize Now only fixed for 64 or 128 bits.  \n");
	}
	else
	if( strcmp(str_cipher,"chaskey") == 0)
	{
		cipher_name = chaskey;
		printf("Note: blocksize Now only fixed for 128 bits.  \n");
	}
	else
	if( strcmp(str_cipher,"cham") == 0)
	{
		cipher_name = cham;
		rol_a = 8;	/* a */
		rol_b = 1;   /* b */
		printf("Note: blocksize Now only fixed for 64 or 128 bits.  \n");
	}
	else
	if( strcmp(str_cipher,"alzette") == 0)
	{
		cipher_name = alzette;
		rol_a = 31;	/* a */ //first round rol_constants
		rol_b = 24;   /* b */
		printf("Note: blocksize Now only fixed for bits for Alzette.  \n");
	}
	else
	{
		printf("Error input with cipher name! \n");
		return 0;
	}



	/* Get the input ciper variant with corresponding blocksize.*/
	printf("blocksize: ");
//	scanf("%s",str_blocksize); //从终端输入
	printf("%s \n",str_blocksize); ///在程序里面写死

	if( strcmp(str_blocksize,"32") == 0)
	{
		sc_blocksize = 32;
		blocksize_len = 16;
		nBytes = 2;

		if( strcmp(str_cipher,"speck") == 0)
		{
			rol_a = 7;	/* a */
			rol_b = 2;   /* b */
			rol_delt = 5;   /* a-b */
		}
	}
	else
	if( strcmp(str_blocksize,"48") == 0)
	{
		sc_blocksize = 48;
		blocksize_len = 24;
		nBytes = 3;
		if( strcmp(str_cipher,"speck") == 0)
		{
			rol_a = 8;	/* a */
			rol_b = 3;   /* b */
		}
	}
	else
	if( strcmp(str_blocksize,"64") == 0)
	{
		sc_blocksize = 64;
		blocksize_len = 32;
		nBytes = 4;
		if( strcmp(str_cipher,"speck") == 0)
		{
			rol_a = 8;	/* a */
			rol_b = 3;   /* b */
		}
	}
	else
	if( strcmp(str_blocksize,"96") == 0)
	{
		if( strcmp(str_cipher,"simeck") == 0)
		{
			printf("Input error.Simeck does not have this blocksize!  \n");
			return 0;
		}

		sc_blocksize = 96;
		blocksize_len = 48;
		nBytes = 6;
		if( strcmp(str_cipher,"speck") == 0)
		{
			rol_a = 8;	/* a */
			rol_b = 3;   /* b */
		}
	}
	else
	if( strcmp(str_blocksize,"128") == 0)
	{
		if( strcmp(str_cipher,"simeck") == 0)
		{
			printf("Input error.Simeck does not have this blocksize!  \n");
			return 0;
		}

		sc_blocksize = 128;
		blocksize_len = 64;
		nBytes = 8;
		if( strcmp(str_cipher,"speck") == 0)
		{
			rol_a = 8;	/* a */
			rol_b = 3;   /* b */
		}
	}
	else
	if(strcmp(str_blocksize,"384") == 0)
	{
		if( strcmp(str_cipher,"gimli") == 0)
		{
			sc_blocksize = 384;
		}
		else
		{
			printf("Error input with blocksize of the cipher! \n");
			return 0;
		}
	}
	else
	{
		printf("Error input with blocksize of the cipher! \n");
		return 0;
	}

	if( strcmp(str_cipher,"hight") == 0)
	{
		sc_blocksize = 64;
		blocksize_len = 8;
		//printf(" 64 \n");
	}


	/* Get the input expected r round max weight of DP.*/
	printf("rounds:");
//	scanf("%d",&sc_rounds); //从终端输入
	printf("%d \n",sc_rounds); ///在程序里面写死了

	if((sc_rounds < 1) || (sc_rounds > 100))
	{
		printf("Error input search Rounds! \n");
		return 0;
	}

	/* Get the input search mode.*/
	printf("mode: %d \n", str_mode); //在程序里面写死  //0, //5 for SPARX64-diff ....
//	scanf("%d",&str_mode); //从终端输入

	switch(str_mode)
	{
	case 0: // Optimal diff trail.
		findMinDPWeightDifferentialTrail((u16)sc_rounds);
		break;
	case 1: // differentials.
		/* Get the input difference of r rounds.*/
		printf("input_diff_Left:  0x");
		scanf("%x",&input_diff_L);
		printf("input_diff_Right: 0x");
		scanf("%x",&input_diff_R);
		printf("output_diff_Left: 0x");
		scanf("%x",&output_diff_L);
		printf("output_diff_Right:0x");
		scanf("%x",&output_diff_R);

//		printf("trail number(0:Exhaustive):");
//		scanf("%d",&trail_nmu);

		//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
		printf("wt_min(:*)--->wt_max:");
		scanf("%d",&wt_max);

		find_Differntial_characteristic((u16)sc_rounds);

		break;
	case 2: //Optiamla linear trail.最优线性路径
		findMinDPWeightLinearTrail((u16)sc_rounds);
		break;
	case 3: // linear Hulls. 搜索SIMON和SIMECK的linear HULL.
		/* Get the input mask of r rounds.*/
		printf("input_mask_Left:  0x");
		scanf("%x",&input_mask_L);
		printf("input_mask_Right: 0x");
		scanf("%x",&input_mask_R);
		printf("output_mask_Left: 0x");
		scanf("%x",&output_mask_L);
		printf("output_mask_Right:0x");
		scanf("%x",&output_mask_R);

		//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
		printf("wt_min(:*)--->wt_max:");
		scanf("%d",&wt_max);

		find_linearHull_characteristic((u16)sc_rounds);
		break;

	case 30:    //搜索 speck 的Linear Hull

		sepck_linear_Hull_search_entry((u16)sc_rounds);

		break;
	case 31:    //搜索SPARX的Linear Hull

		if( strcmp(str_blocksize,"64") == 0)
		{
			SPARX64_linear_Hull_search_entry((u16)sc_rounds);
		}
		else
		{
			if( strcmp(str_blocksize,"128") == 0)
			{
				SPARX128_linear_Hull_search_entry((u16)sc_rounds);;
			}
			else
			{
				printf("Error! . \n" );
			}
		}
		break;
	case 32:    //搜索 CHAM 的Linear Hull

		sepck_linear_Hull_search_entry((u16)sc_rounds);




		break;
	case 4: //trail-core extension for speck96 and speck128.
		//原始的Trail-Core extension for speck96/128 of 9 round or more.
		/*
		if(sc_rounds < 9)
		{
			printf("Error! The extended rounds should >= 1 rounds. search round >= 9. \n" );
			return 0;
		}
		*/
		//Trail Core扩展方法搜索SPEC96/128的大于8/9轮的差分路径
		bit_align_fun();
		speck_trailCore_Extendsion(sc_rounds);  //

/*
		//新的trail-core extension for speck96 and speck128.
		//只为大于8轮的speck96、128
		if(sc_blocksize <= 64)
		{
			printf("The block size of this mode=7 for speck96/128 MUST be 96/128 bits...... \n");
			return 0;
		}
		speck_TC_extend_entry((u16)sc_rounds);
*/

		break;

	case 5: //Optimal differential trails of SPARX64.
		if(sc_blocksize == 64)
		{
			SPARX64_diff_search_entry((u16)sc_rounds);
		}
		else
			if(sc_blocksize == 128 )
			{
				SPARX_128_diff_search_entry((u16)sc_rounds);
			}
			else
			{
				printf("The block size of SPARX should be 64 or 128 bits. \n");
				return 0;
			}

		//SPARX64_round_1_diff((u16)sc_rounds);
		break;

	case 6: //Optimal differential trails of HIGHT-64,
		if(sc_blocksize != 64)
		{
			printf("The block size of HIGHT MUST be 64 bits...... \n");
			return 0;
		}
		HIGHT_diff_search_entry((u16)sc_rounds);
		break;


	case 7: //trail-core extension for speck96 and speck128.

		if(sc_blocksize <= 64)
		{
			printf("The block size of this mode=7 for speck96/128 MUST be 96/128 bits...... \n");
			return 0;
		}
		speck_TC_extend_entry((u16)sc_rounds);
		break;

	default:
		printf("Error search mode,does not have this search mode! \n");
		break;
	}

	/*
		// Get the input expected r round max weight of DP.//
		printf("max Bnw:");
		scanf("%d",&sc_maxBnw);
		if((sc_maxBnw < 1) || (sc_maxBnw > 100))
		{
			printf("Expected Bnw is not property,too high or too below of the reality! \n");
			return 0;
		}
	*/

	printf("---------------------------------\n");
	return 1;
}
/**
 * @def The varibits
 *
 */
u64 varibits(u64 input)
{
	u64 tmp = 0;

	//tmp = ROTATE_LEFT(input,rol_a,blocksize_len) | ROTATE_LEFT(input,rol_b,blocksize_len);
	tmp = ROTATE_LEFT(input,rol_a,blocksize_len) | ROTATE_LEFT(input,rol_b,blocksize_len);

	switch(sc_blocksize)  //make the rotation value in unsigned 64 bits.
	{
	case 32:
		tmp &= 0xFFFF;
		break;
	case 48:
		tmp &=  0x00FFFFFF;
		break;
	case 64:
		tmp &=  0xFFFFFFFF;
		break;
	case 96:
		tmp &=  0xFFFFFFFFFFFF;
		break;
	case 128://128
		tmp &=  0xFFFFFFFFFFFFFFFF;
		break;
	default:
		break;
	}
    return tmp;
}
/**
 * @def The doublebits
 *
 */
u64 doublebits(u64 input)
{
	u64 tmp = 0;

	tmp = ROTATE_LEFT(input,rol_b,blocksize_len)
			& (~ROTATE_LEFT(input,rol_a,blocksize_len))
			& ROTATE_LEFT(input,(2*rol_a - rol_b),blocksize_len);

	switch(sc_blocksize)
	{
	case 32:
		tmp &= 0xFFFF;
		break;
	case 48:
		tmp &=  0x00FFFFFF;
		break;
	case 64:
		tmp &=  0xFFFFFFFF;
		break;
	case 96:
		tmp &=  0xFFFFFFFFFFFF;
		break;
	case 128://128
		tmp &=  0xFFFFFFFFFFFFFFFF;
		break;
	default:
		break;
	}
    return tmp;
}
/**
 * @ Hamming weight compute.
 *
 */
u16 HM_weight(u64 input)
{
	u16 count = 0; /* haming weight. */
	//u64 tmp=0;
	//tmp = input;
/*
	while ( tmp != 0 )  //遍历
	{
		if((tmp & 0x01) == 1) //尾数按位与1
		{
			count +=1;
		}
		tmp >>= 1;   // 右移一位
	}
*/
	/*
	for(count=0;input;count++)
	{
		input &= (input -1);
	}
*/

	count = (u16)_mm_popcnt_u64(input); //faster than above.

return count;
}
/**
 * @ HW space with the hamming weight increase.
 * @
 */
void HW_space_construct(void)
{
	u64 i = 0;
	u64 numb = 0;
	u16 hweight = 0;
	u16 w=0;
	u64 ValueMax = 0;

	switch(sc_blocksize)
	{
	case 32:
		ValueMax = 0xFFFF;
		break;
	case 48:
		ValueMax = 0x00FFFFFF;
		break;
	case 64:
		ValueMax = 0xFFFFFFFF;
		break;
	case 96:
		ValueMax = 0xFFFFFFFFFFFF;
		break;
	default:  //128
		ValueMax = 0xFFFFFFFFFFFFFFFF;
		break;
	}

	while( hweight<= 5)   //16
	{
		numb = 0;
		i = 0;
		while(i<=ValueMax)
		{
			w = HM_weight(i);
			if(hweight == w)
			{
				HMspace[hweight][numb] = i;
				numb += 1;
			}
			i++;
		}
		HMspace_num[hweight] = numb;
		hweight++;
	}
}
/**
 * @def  SIMON Differential probability Hamming weight compute and valid check.
 *
 */
u16 SIMON_DP_weight_compute(u64 alpha)
{
	u16 wt = 0;

	switch(alpha)
	{
	case 0:
		wt = 0;
		break;
	case 0xFFFF:  //0xFFFFFF;0xFFFFFFF;...//
		wt = 15;
		break;
	default:
		//wt =  HM_weight(varibits(alpha) ^ doublebits(alpha));
		wt = (u16)_mm_popcnt_u64((int)(varibits(alpha) ^ doublebits(alpha))); //faster than above.
		break;
	}

/*
	if(hmw == 16)
	{
		wt= 15;
	}
	else
		if(HM_weight(alpha) == 0)
		{
			wt = 0;
		}
		else
		{
			wt =  HM_weight(varibits(alpha) ^ doublebits(alpha));
		}
*/
	return wt;
}

u16 SIMON_SCorr_weight_compute(u64 beta)
{
	u16 wt = 0;
	u64 tmp = beta ;
	u64 abits = beta;

	while(tmp != 0)
	{
		tmp = beta & (RIGHT_rotation_64(tmp,rol_delt,blocksize_len));
		abits = abits ^ tmp;
	}

	wt = 2* (u16)_mm_popcnt_u64(abits); //faster than above.

	return wt;
}

/**
 * @def  SIMON Differential probability Hamming weight valid check.
 *
 */
u16 SIMON_DP_weight_check(u64 alpha,u64 gama)
{
	u16 flag = 0;  //1 valid; 0 invalid.

	switch(alpha)
	{
	case 0:
		flag = 1;
		break;
	case 0xFFFF:  //0xFFFFFF;0xFFFFFFF;...//
		if((HM_weight(gama))%2 == 0)
		{
			flag = 1;
		}
		break;
	default:
		//if(((gama & (~varibits(alpha))) == 0))
		{
			if(((gama ^ ROTATE_LEFT(gama,rol_delt,blocksize_len)) & doublebits(alpha)) == 0)
				{
					flag = 1;
				}
		}
		break;
	}

	/*
	if(HM_weight(alpha) == 16)
	{
		if((HM_weight(gama))%2 == 0)
			flag = 1;
	}
	else
	{
		if(((gama & (~varibits(alpha))) == 0))
		{
			if(((gama ^ ROTATE_LEFT(gama,rol_delt,16)) & doublebits(alpha)) == 0)
				{
					flag = 1;
				}
		}
	}


	*/
	return flag;
}
u16 SIMON_SCorr_weight_check(u64 beta,u64 *U_base) //,u64 *U_base_num)
{

	//u64 U_base_cnt;
	//U_base_cnt = U_base_num;

	u16 wt = 0;
	u64 tmp = beta ;
	u64 abits = beta;

	u64 u = 0;
	u64 v = 0;
	u64 w = 0;
	u64 r = 0;

	u64 i = 0;
	u64 x[65]={0};
	//u64 y[65] = {0};


	while(tmp != 0)
	{
		tmp = beta & (RIGHT_rotation_64(tmp,rol_delt,blocksize_len));  //>>>d
		abits = abits ^ tmp;
	}

	u = RIGHT_rotation_64(abits,2*rol_delt,blocksize_len);  //>>>2d
	v = RIGHT_rotation_64(beta,rol_delt,blocksize_len);  //>>>d
	w = u & v;
	r = abits ^ (RIGHT_rotation_64(abits,rol_delt,blocksize_len));

	for( i = 0; i < blocksize_len; i++)
	{
		x[i] = r & (1<<i);
		*U_base++ = x[i] ^(w & (1 << ((i-2*rol_delt)%blocksize_len))); // non zero vector in U_base construct the bases of Ubeta.//

//		y[i]
/*
		if(U_base[i] != 0)
		{
			U_alpha_base[U_base_cnt] = U_base[i] ;
			U_base_cnt +=1;
		}
*/
	}

	//U_base = y;
	//U_base_num = &U_base_cnt;

	wt = 2*(u16)_mm_popcnt_u64(abits); //faster than above.

	return wt;
}
/**
 * @ Max probability of the corresponding input difference.
 * @ From Liuzhengbing's paper Theory 3.
 */
u16 Pmax_compute(u16 input_alpha_hw)
{
	u16 wPmax = 0xFFFF;

	switch(input_alpha_hw)
	{
	case 0:
		wPmax = 0;
		break;
	case 1:
		wPmax = 2;
		break;
	case 2:
		wPmax = 3;
		break;
	case 3:
		wPmax = 4;
		break;
	case 4:
		wPmax = 5;
		break;
	case 5:
		wPmax = 6;
		break;
	case 6:
		wPmax = 7;
		break;
	case 7:
		wPmax = 8;
		break;

	case 16:  //N
		wPmax = 15;
		break;

	default:
		wPmax = input_alpha_hw;// n/2 < wt(a)
		break;
	}

/*
	u16 alpha_w = 0;

	alpha_w =  input_alpha_hw;    //HM_weight(input_alpha);

	if(alpha_w == 0)
	{
		wPmax = 0;
	}

	if(1 <= alpha_w)
	{
		if (alpha_w < 8)
		{
			wPmax = alpha_w + 1;
		}
		else
			if(alpha_w < 16)
			{
				wPmax = alpha_w;
			}
			else
			{
				if(alpha_w == 16)
				{
					wPmax = 15;
				}
				else
					wPmax = 0xFFFF;
			}
	}
*/
	return wPmax;
}

u16 sCorrelation_max_compute(u16 input_beta_hw)
{
	u16 cwmax = 0;

	cwmax = input_beta_hw;  //(u16)_mm_popcnt_u64(input_beta); //faster than above.

	if(input_beta_hw != blocksize_len )
	{
		if((input_beta_hw % 2) ==0)
		{
			return cwmax;
		}
		else
		{
			return cwmax+1;
		}
	}
	else
	{
		cwmax = blocksize_len - 2;
	}

return cwmax;
}


/**
 * @ Construct the DDTA of simon to find the property gama.
 * @
 */
void DDTA_construct(void)
{
	u64 XA,YB;  //Sa, Sb
	u64 num = 0;
	u64 OUT_AB;
	u64 tmp = 0;

	for(XA=0;XA<=0xFF;XA++)   //8bit DDTA
	{
		for(YB=0;YB<=0xFF;YB++)
		{
			num = 0;
			tmp = XA;
			tmp = ((tmp << 8) | YB);
			for(OUT_AB=0;OUT_AB<=0xFF;OUT_AB++)
			{
				if(HM_weight((~XA) & (~YB) & OUT_AB)  == 0)
				{
					DDTAB_8bit[tmp][num] = OUT_AB;
					num += 1;
				}
			}
			DDTAB_8bit[tmp][256] = num;
		}
	}

/*
	//4 bit DDTA table
	u16 XA,YB;  //Sa, Sb
	u16 num = 0;
	u16 OUT_AB;
	u16 tmp = 0;

	for(XA=0;XA<=0xF;XA++)   //4bit DDTA
		for(YB=0;YB<=0xF;YB++)
		{
			num = 0;
			tmp = ((XA << 4) | YB);
			for(OUT_AB=0;OUT_AB<=0xF;OUT_AB++)
			{
				if(HM_weight((~XA) & (~YB) & OUT_AB)  == 0)
				{
					DDTAB[tmp][num] = OUT_AB;
					printf( "DDTAB[%d][%d]= %d;  \n", tmp,num,DDTAB[tmp][num] );
					num += 1;
				}
			}
			DDTAB[tmp][255] = num;
			printf( "DDTAB[%d][255]=%d;  \n",tmp, DDTAB[tmp][255] );
		}
*/

//8bit DDTA table
	/*
	u16 XA,YB;  //Sa, Sb
	u16 num = 0;
	u16 OUT_AB;
	u32 tmp = 0;
	FILE* ddta8bit;
	ddta8bit = fopen ("../printf/DDTA_8bit.txt", "w+"); //"a+"); //
	fprintf(ddta8bit, "#include \"search.h\" \n");
	fprintf(ddta8bit, "#include \"table.h\" \n");
	fprintf(ddta8bit, "void DDTAB_8bit_init(void) \n");
	fprintf(ddta8bit, "{ \n");

	for(XA=0;XA<=0xFF;XA++)   //4bit DDTA
	{
		for(YB=0;YB<=0xFF;YB++)
		{
			num = 0;
			tmp = XA;
			tmp = ((tmp << 8) | YB);
			for(OUT_AB=0;OUT_AB<=0xFF;OUT_AB++)
			{
				if(HM_weight((~XA) & (~YB) & OUT_AB)  == 0)
				{
					DDTAB_8bit[tmp][num] = OUT_AB;
					printf( "DDTAB[%d][%d]= %d;  \n", tmp,num,OUT_AB);  //DDTAB_8bit[tmp][num] );
					fprintf(ddta8bit,"DDTAB_8bit[%d][%d]= %d;  \n",tmp,num,OUT_AB); // write.
					num += 1;
				}
			}
			DDTAB_8bit[tmp][256] = num;
			printf( "DDTAB[%d][256]=%d;  \n",tmp, DDTAB_8bit[tmp][256] );
			fprintf(ddta8bit,"DDTAB_8bit[%d][256]= %d;  \n",tmp,DDTAB_8bit[tmp][256]); // write.
		}
	}

	fprintf(ddta8bit, "} \n");
	fclose(ddta8bit);

*/
}

void ARX_carry_DDTm_construct(void)
{
	u16 A,B,C;  //ALPHA,BETA
	u16 AB = 0;
	u16 carrybits = 0;
	u16 alpha_inv = 0;
	u16 beta_inv = 0;
	u16 gamma_inv = 0;
	u16 alpha_tmp = 0;
	u16 beta_tmp = 0;
	u16 gamma_tmp= 0;
	u16 eq = 0xFFFF;
	//u64 num = 0;
	u16 wt = 0;
	u16 wt_cnt[9] = {0};
	u16 i = 0;
	u16 WT = 0;
	u16 WT_cnt[9] = {0};
	u8 flag1 = 0,flag2 = 0;


	memset(cDDT_v,0,sizeof(MSB_cDDT_v)); //内存清零函数
	memset(cDDT_n,0,sizeof(MSB_cDDT_n)); //内存清零函数
	memset(MSB_cDDT_v,0,sizeof(MSB_cDDT_v)); //内存清零函数
	memset(MSB_cDDT_n,0,sizeof(MSB_cDDT_n)); //内存清零函数

	memset(cDDT_wt_min,0xFF,sizeof(cDDT_wt_min)); //初始化cDDT_wt_min为全F。
	memset(cDDT_wt_max,0,sizeof(cDDT_wt_max)); //初始化MSB_cDDT_wt_min为全F。
	memset(MSB_cDDT_wt_min,0xFF,sizeof(MSB_cDDT_wt_min)); //初始化MSB_cDDT_wt_min为全F。
	memset(MSB_cDDT_wt_max,0,sizeof(MSB_cDDT_wt_max)); //内存清零函数

	for(A=0;A<=0xFF;A++)   //8bit DDTA
	{
		alpha_tmp = A<<1;
		for(B=0;B<=0xFF;B++)
		{
			AB = ((A << 8) | B);
			beta_tmp = B<<1;
			for(carrybits=0; carrybits<8; carrybits++)
			{
				for(i=0; i<9;i++ )
				{
					wt_cnt[i] = 0;
					WT_cnt[i] = 0;
				}
			for(C=0; C<=0xFF;C++ )
			{
				gamma_tmp = C << 1;

				if((carrybits & 0x4) != 0) // alpha  LSB bit.
				{
					alpha_inv = ~(alpha_tmp | 1) ; // & 0xFFFF;
				}
				else
				{
					alpha_inv = ~alpha_tmp ; // & 0xFFFF;
				}

				if((carrybits & 0x2) != 0) // beta LSB bit.
				{
					beta_inv = (beta_tmp | 1) ; // & 0xFFFF;
				}
				else
				{
					beta_inv = beta_tmp; // & 0xFFFF;
				}

				if((carrybits & 0x1) != 0) // gamma LSB bit.
				{
					gamma_inv = (gamma_tmp | 1);
				}
				else
				{
					gamma_inv = gamma_tmp;
				}

				eq = (alpha_inv ^ beta_inv) & (alpha_inv ^ gamma_inv);
				eq = eq & (A ^ B ^ C ^ beta_inv);

				if( (eq & 0xFF) == 0) //
				{
					//compute wt= Speck_block_wt_compute(A,B,C)
					wt = Speck_block_wt_compute(A,B,C,0xFF);
					cDDT_v[carrybits][AB][wt][wt_cnt[wt]] = (u16)C;  //for gamma numb.
					wt_cnt[wt]++ ;

					WT = Speck_block_wt_compute(A,B,C,0x7F); //HM_weight((~((~A ^ B) & (~A ^ C))) & 0x7F);
					MSB_cDDT_v[carrybits][AB][WT][WT_cnt[WT]] = (u16)C;  //for gamma numb.
					WT_cnt[WT]++;
				}
			}

			flag1 = 0;
			flag2 = 0;
			for(i=0; i<9;i++ )
			{
				cDDT_n[carrybits][AB][i] = wt_cnt[i];
				MSB_cDDT_n[carrybits][AB][i] = WT_cnt[i];

				if(wt_cnt[i] != 0)
				{
					if(flag1 ==0)
					{
						cDDT_wt_min[carrybits][AB] = i;
						flag1 = 1;
					}
					cDDT_wt_max[carrybits][AB] = i;
				}

				if(WT_cnt[i] != 0)
				{
					if(flag2 ==0)
					{
						MSB_cDDT_wt_min[carrybits][AB] = i;
						flag2 = 1;
					}
					MSB_cDDT_wt_max[carrybits][AB] = i;
				}

			}

			if(cDDT_AB_wt_min[AB] > cDDT_wt_min[carrybits][AB])
			{
				cDDT_AB_wt_min[AB] = cDDT_wt_min[carrybits][AB];
			}

			//printf("cDDT[carrybits][AB][256]: %d \n",cDDT[carrybits][AB][256]);
			}
		}
	}
}


void ARX_borrow_DDTm_construct(void)
{
	u64 A,B,C;  //ALPHA,BETA
	u64 CB = 0;
	u64 carrybits = 0;
	u64 alpha_inv = 0;
	u64 beta_inv = 0;
	u64 gamma_inv = 0;
	u64 alpha_tmp = 0;
	u64 beta_tmp = 0;
	u64 gamma_tmp= 0;
	u64 eq = 0xFFFF;
	u16 wt = 0;
	u64 wt_cnt[9] = {0};
	u64 i = 0;
	u16 WT = 0;
	u64 WT_cnt[9] = {0};
	u8 flag1 = 0,flag2 = 0;


	for(B=0;B<=0xFF;B++)
	{
		beta_tmp = B<<1;
		for(C=0; C<=0xFF;C++ )
		{
			gamma_tmp = C << 1;
			CB = ((C << 8) | B);
			for(carrybits=0; carrybits<8; carrybits++)
			{
				for(i=0; i<9;i++ )
				{
					wt_cnt[i] = 0;
					WT_cnt[i] = 0;
				}

			for(A=0;A<=0xFF;A++)   //8bit DDTA
			{
				alpha_tmp = A<<1;

				if((carrybits & 0x4) != 0) // alpha  LSB bit.
				{
					alpha_inv = ~(alpha_tmp | 1) ; // & 0xFFFF;
				}
				else
				{
					alpha_inv = ~alpha_tmp ; // & 0xFFFF;
				}

				if((carrybits & 0x2) != 0) // beta LSB bit.
				{
					beta_inv = (beta_tmp | 1) ; // & 0xFFFF;
				}
				else
				{
					beta_inv = beta_tmp; // & 0xFFFF;
				}

				if((carrybits & 0x1) != 0) // gamma LSB bit.
				{
					gamma_inv = (gamma_tmp | 1);
				}
				else
				{
					gamma_inv = gamma_tmp;
				}

				eq = (alpha_inv ^ beta_inv) & (alpha_inv ^ gamma_inv);
				eq = eq & (A ^ B ^ C ^ beta_inv);

				if( (eq & 0xFF) == 0) //
				{
					//compute wt= Speck_block_wt_compute(A,B,C)
					wt = Speck_block_wt_compute(A,B,C,0xFF);
					bDDT_v[carrybits][CB][wt][wt_cnt[wt]] = A;
					wt_cnt[wt]++ ;

					WT = Speck_block_wt_compute(A,B,C,0x7F); //HM_weight((~((~A ^ B) & (~A ^ C))) & 0x7F);
					MSB_bDDT_v[carrybits][CB][WT][WT_cnt[WT]] = C;  //for gamma numb.
					WT_cnt[WT]++;

				}
			}

			flag1 = 0;
			flag2 = 0;
			for(i=0; i<9;i++ )
			{
				bDDT_n[carrybits][CB][i] = wt_cnt[i];
				MSB_bDDT_n[carrybits][CB][i] = WT_cnt[i];

				if(wt_cnt[i] != 0)
				{
					if(flag1==0)
					{
						bDDT_wt_min[carrybits][CB] = i;
						flag1 = 1;
					}
					bDDT_wt_max[carrybits][CB] = i;
				}

				if(WT_cnt[i] != 0)
				{
					if(flag2==0)
					{
						MSB_bDDT_wt_min[carrybits][CB] = i;
						flag2 = 1;
					}
					MSB_bDDT_wt_max[carrybits][CB] = i;
				}
			}
			//printf("cDDT[carrybits][AB][256]: %d \n",cDDT[carrybits][AB][256]);
			}
		}
	}
}



/////
u64 Speck_XDP_validcheck(u64 alpha, u64 beta, u64 gamma)
{
	u64 eq = 0xFFFF;
	u64 alpha_inv = 0;
	u64 beta_inv = 0;

	alpha_inv = ~(alpha << 1);
	beta_inv = beta << 1;

	eq = (alpha_inv ^ beta_inv) & (alpha_inv ^ (gamma <<1));
	eq = eq & (alpha ^ beta ^ gamma ^ beta_inv);
	eq = eq & Bit_Align; // 因为左移位会导致超过分组长度,当分组小于64
/*
	if(eq != 0)   // probability equals to 0.
	{
		return 0;
	}
	else
	{
		return 1;
	}
*/
	return eq;
}

u16 Speck_XDP_compute(u64 alpha, u64 beta, u64 gamma)
{
	u64 alpha_inv = 0;
	u64 eq = 0xFFFF;

	alpha_inv = ~alpha;
	eq = (alpha_inv ^ beta)	& (alpha_inv ^ gamma );
	eq = (~eq) & ValueMax_Align;

	return HM_weight(eq);
}

// 只返回最大概率重量,该gamma对应的差分概率为最大值
u16 Speck_XDP_Max(u64 alpha, u64 beta, u64 *gamma_tmp)
{
	u16 xdp_max_wt = 0;
	u64 GAMMA = 0;
	u64 GAMMA_i = 0;
	u64 and_ab = 0;
	u64 and_ab_i = 0;
	u64 i = 0;
	u64 alpha_i = 0;
	u64 beta_i = 0;
	u64 gamma_i = 0;
	u64 *p;
	p = gamma_tmp;

	GAMMA = (alpha ^ beta) & 0x01;
	and_ab = alpha & beta & Bit_Align;

	for(i=1;i< blocksize_len;i++)
	{
		if(i == blocksize_len -1)
		{
			//gamma-i = 0/1
			GAMMA_i = 0;
		}
		else
		{
			alpha_i = (1 << (i-1)) & alpha;
			beta_i  = (1 << (i-1)) & beta;
			gamma_i = (1 << (i-1)) & GAMMA;

			if(alpha_i == beta_i)  //alpha-i-1 == beta-i-1
			{
				if(alpha_i == gamma_i) ////alpha-i-1 == beta-i-1 == gamma-i-1
				{
					GAMMA_i = ((1 << i) & (alpha ^ beta)) ^ ((1 << (i-1)) & alpha);
				}
			}
			else//alpha-i-1 != beta-i-1
			{
				//gamma-i = 0/1
				GAMMA_i = 0;
			}

		}

		and_ab_i = (1 << i) & and_ab;
		if(and_ab_i != 0)
		{
			//gamma-i = 0/1
			GAMMA_i = 0;
		}

		GAMMA |= GAMMA_i;
	}
	*p = GAMMA;
	xdp_max_wt = Speck_XDP_compute(alpha,beta,GAMMA);

	return xdp_max_wt;
}

// 只返回一个gamma,该gamma对应的差分概率为最大值
u64 Speck_XDP_Max_Gamma(u64 alpha, u64 beta)
{
	//u16 xdp_max_wt = 0;
	u64 GAMMA = 0;
	u64 GAMMA_i = 0;
	u64 and_ab = 0;
	u64 and_ab_i = 0;
	u64 i = 0;
	u64 alpha_i = 0;
	u64 beta_i = 0;
	u64 gamma_i = 0;


	GAMMA = (alpha ^ beta) & 0x01;
	and_ab = alpha & beta & Bit_Align;

	for(i=1;i< blocksize_len;i++)
	{
		if(i == blocksize_len -1)
		{
			//gamma-i = 0/1
			GAMMA_i = 0;
		}
		else
		{
			alpha_i = (1 << (i-1)) & alpha;
			beta_i  = (1 << (i-1)) & beta;
			gamma_i = (1 << (i-1)) & GAMMA;

			if(alpha_i == beta_i)  //alpha-i-1 == beta-i-1
			{
				if(alpha_i == gamma_i) ////alpha-i-1 == beta-i-1 == gamma-i-1
				{
					GAMMA_i = ((1 << i) & (alpha ^ beta)) ^ ((1 << (i-1)) & alpha);
				}
			}
			else//alpha-i-1 != beta-i-1
			{
				//gamma-i = 0/1
				GAMMA_i = 0;
			}

		}

		and_ab_i = (1 << i) & and_ab;
		if(and_ab_i != 0)
		{
			//gamma-i = 0/1
			GAMMA_i = 0;
		}

		GAMMA |= GAMMA_i;
	}

	//xdp_max_wt = Speck_XDP_compute(alpha,beta,GAMMA);

	return GAMMA;
}

u16 Speck_block_wt_compute(u64 alpha, u64 beta, u64 gamma,u64 asign_bits)
{
	u64 alpha_inv = 0;
	u64 eq = 0xFF;//8bit

	alpha_inv = ~alpha;
	eq = (alpha_inv ^ beta)	& (alpha_inv ^ gamma );
	eq = (~eq) & asign_bits;

	return _mm_popcnt_u64(eq);
}


u64 Combination_cal(u64 M0, u64 N0, char *T )
{
	char A0[65], T0[65], F0[65], H0[65],  C0[65], X0, Y0, I0, L0, Z0;
	int i=0;
	u64 cnt = 0;


	for ( i=0; i<=(N0-M0); i++) A0[i] = 0;
	for ( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
	for ( i = 1; i<=M0; i++) { C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
	T0[N0-M0] = -1;
	T0[1] = 0;
	F0[N0] = N0 - M0 + 1;
	I0 = N0 - M0; L0 = N0;

	/*
	//第一种模式输出
	for( i=1; i<=M0; i++)
	{
		printf("pppp:%d \t",C0[i]);
	}
	printf("\n");
*/
	for( i=1; i<=M0; i++)
	{
		T[i] = C0[i];
	}
	cnt = 1;

	do{
		if (I0 == 0)
		{
			break;
		}
		else
		{
			if (T0[I0] < 0)
			{
				if ((-T0[I0]) != (I0-1))
				{
					T0[I0-1] = T0[I0];
				}
				T0[I0] = I0-1;
			}

			if ( A0[I0]==0 )
			{
				X0 = I0;
				Y0 = F0[L0];

				if (A0[I0-1] == 1)
				{
					F0[I0] = F0[I0 - 1];
				}
				else
				{
					F0[I0] = I0;
				}

				if (F0[L0] == L0)
				{
					L0 = I0; I0 = T0[I0]; goto CHANGE0;
				}

				if (L0 == N0)
				{
					T0[F0[N0]] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = F0[N0];
					F0[N0] = F0[N0] + 1;
					goto CHANGE0;
				}

				T0[L0] = -I0-1;
				T0[I0+1] = T0[I0];
				F0[L0] = F0[L0] + 1;
				I0 = L0;
				goto CHANGE0;
			}

			Y0 = I0;

			if (I0 != L0)
			{
				F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
				if (L0 == N0)
				{
					if (I0 == (F0[N0] - 1))
					{
						I0 = T0[I0];
						goto CHANGE0;
					}
					T0[F0[N0]-1] = -I0-1;
					T0[I0+1] = T0[I0];
					I0 = F0[N0] - 1;
					goto CHANGE0;
				}
				T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0; goto CHANGE0;
			}

			X0 = N0;
			F0[L0 - 1] = F0[L0];
			F0[N0] = N0;
			L0 = N0;
			if (I0 == N0 - 1)
			{
				I0 = T0[N0 - 1];
				goto CHANGE0;
			}
			T0[N0 - 1] = -I0 - 1;
			T0[I0 + 1] = T0[I0];
			I0 = N0 - 1;


CHANGE0:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
			}

///////////
/*
			for(i=1; i<=M0; i++)
			{
				printf("%d\t",C0[i]);
			}
			printf("\n");
*/

		for( i=1; i<=M0; i++)
		{
			T[M0*cnt + i] = C0[i];
		}
		cnt ++;

/////////////
		} while (1);

	//printf("cnt: %d \n",cnt);

	//if( N0 == 0)
		//cnt =0;

	return cnt;
}


u16 Cal_nonezero_subscript(u64 input, u16 *sub )
{
	u16 index_i;
	u16 ctr = 0;
	u64 tmp = 0;

	tmp = input;
	for(index_i=0; index_i< blocksize_len-1; index_i++)
	{
		if((tmp & 0x1) == 1)  // MSB--->LSB
		{
			sub[ctr] = index_i ;  //These bits position are SET.
			ctr++;
		}

		tmp >>= 1;
	}

	return ctr;
}

u64 search_entry(u16 search_round)
{
	u16 i = 0;

	memset(DDTAB_8bit,0,sizeof(DDTAB_8bit)); //内存清零函数
	DDTA_construct();

	memset(HMspace,0,sizeof(HMspace)); //内存清零函数
	memset(HMspace_num,0,sizeof(HMspace_num)); //内存清零函数
	HW_space_construct();


	/* Variables define. */
	time_start = clock();
	simon_diff_trail = fopen ("../tmp/simon_diff_trail.xlsx", "w+"); //"a+"); //
	fprintf(simon_diff_trail,"Rounds  \t x \t y \t P_w \t n_P_bestofR_w\n"); // write.
	best_Bn = fopen ("../tmp/best_Bn_w.xlsx", "a+"); //  "w+"); //



	if(search_round > 2)
	for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
	{
		fscanf(best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
		//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
	}
	Bn_w = n_P_bestofR_w[search_round-1] - 1;

#if 1  //round 2 search from Bn_w >= 2.
	if(search_round == 2)
		Bn_w = 1;
#endif

	do
	{
		Bn_w = Bn_w + 1;
		printf("Searching Bn_w: %d \n", Bn_w);

		round_1(search_round);  // Search Entry.

		time_Round = clock();
		run_time =  (time_Round - time_start) / CLOCKS_PER_SEC;
		printf("Time: %.2f seconds.  \n", run_time);
	}while(Bn_w !=  n_P_bestofR_w[search_round]);   //end conditions.
	fprintf(best_Bn,"%d \n",n_P_bestofR_w[search_round]);  // write.

	fclose(simon_diff_trail); // close the files in tmp.
	fclose(best_Bn);

	return 1;
}

/**
 * @Search for the min weight of DP of the FIRST Round of SIMON completely.
 * @
 */
u16 round_1(u16 search_round)
{
	u16 HM_w;
	u64 alpha = 0;  //x
	u64 beta = 0;  //beta.
	u64 gama = 0;  //gama.andout.
	u16 p_alpha = 0; // p with the input alpha.
	u64 Sa,Sb;
	u64 Sa_LSB8,Sb_LSB8;
	u16 best = 0;
	u64 HW_space_num = 0;
	u64 AB_indx[16] = {0};  // Sa and Sb
	u16 gama_num[]={0};
	u64 gama_0 = 0,gama_1 = 0,gama_2 = 0,gama_3 = 0,gama_4 = 0,gama_5 = 0,gama_6 = 0,gama_7 = 0;
	u16 i=0,i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0,j=0,k=0;

	if( search_round == 1)
	{
		best = round_1_j(1);
		return best;
	}
	else
	{
	// 汉明重量逐渐增加
	for(HM_w=0;HM_w <= blocksize_len;HM_w++)  // alpha hamming weight 0-n wordsize. pow(2,n).
	{
		if ( (Pmax_compute(HM_w) + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //alpha hamming weight increased,the Pmax will be decreased,and Pmax weight be increase.
		}

		HW_space_num = HMspace_num[HM_w];  // The number of value of the corresponding HMW.
		for (k=0;k < HW_space_num;k++)
		{
			alpha = HMspace[HM_w][k];

			p_alpha = SIMON_DP_weight_compute(alpha);
			if ((p_alpha + n_P_bestofR_w[search_round - 1]) <= Bn_w)
				{
					//////look up the DDTAB table to find the gama.//////
					Sa = ROTATE_LEFT(alpha,rol_a,blocksize_len);
					Sb = ROTATE_LEFT(alpha,rol_b,blocksize_len);

					switch(sc_blocksize)
					{
					case 32:
						//x0
						Sa_LSB8 = (Sa) & 0xFF; //8 bit
						Sb_LSB8 = (Sb) & 0xFF; //8 bit
						AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
						gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
						//x1
						Sa_LSB8 = Sa & 0xFF00; //8 bit
						Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
						AB_indx[1] = Sa_LSB8  | Sb_LSB8;
						gama_num[1] = DDTAB_8bit[AB_indx[1]][256];

						//gama_cnt[1] = gama_num[0] * gama_num[1];

						for(i1=0;i1<gama_num[1];i1++)
						{
							gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
							for(i0=0;i0 < gama_num[0];i0++)
							{
								gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
								gama = (gama_1 <<8) | gama_0;


								if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
								{
									beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
									P_w[1] = p_alpha;  // p1alpha
									x_in[1] = alpha;  //x1
									y_in[1] = 0x0000; //beta;  // y_in[1] = x_in[2] ^ beta1;
									beta_in[1] = beta; //so,use beta_in[1] to store beta1.

									best = round_2(search_round);// Call the next round.
#if 1   //是否找到第一条最优路径就返回？
									if(best==1)
										return 1;
#endif
								}
							}
						}
						break;
					case 48:
						//x0
						Sa_LSB8 = (Sa) & 0xFF; //8 bit
						Sb_LSB8 = (Sb) & 0xFF; //8 bit
						AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
						gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
						//x1
						Sa_LSB8 = Sa & 0x00FF00 ; //8 bit
						Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
						AB_indx[1] = Sa_LSB8  | Sb_LSB8;
						gama_num[1] = DDTAB_8bit[AB_indx[1]][256];
						//x2
						Sa_LSB8 = (Sa>>16) & 0x00FF; //8 bit
						Sb_LSB8 = (Sb>>16) & 0x00FF; //8 bit
						AB_indx[2] = ((Sa_LSB8 << 8) | Sb_LSB8);
						gama_num[2] = DDTAB_8bit[AB_indx[2]][256];

						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama = (gama_2 << 16) | (gama_1 <<8) | gama_0;

									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[1] = p_alpha;  // p1alpha
										x_in[1] = alpha;  //x1
										y_in[1] = 0x01; //beta;  // y_in[1] = x_in[2] ^ beta1;
										beta_in[1] = beta; //so,use beta_in[1] to store beta1.

										best = round_2(search_round);// Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best==1)
											return 1;
#endif
									}
								}
							}
						}
						break;
					case 64:
						for(j=0;j<nBytes;j++)  //nBytes
						{
							Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
							Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
							AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
							gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
						}

						for(i3=0;i3<gama_num[3];i3++)
						{
						gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama = (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[1] = p_alpha;  // p1alpha
										x_in[1] = alpha;  //x1
										y_in[1] = 0x01; //beta;  // y_in[1] = x_in[2] ^ beta1;
										beta_in[1] = beta; //so,use beta_in[1] to store beta1.

										best = round_2(search_round);// Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best==1)
											return 1;
#endif
									}
								}
							}
						}
					}
						break;
					case 96:
						for(j=0;j<nBytes;j++)  //nBytes
						{
							Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
							Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
							AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
							gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
						}

						for(i5=0;i5<gama_num[5];i5++)
						{
						gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
						for(i4=0;i4<gama_num[4];i4++)
						{
						gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
						for(i3=0;i3<gama_num[3];i3++)
						{
						gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama = (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[1] = p_alpha;  // p1alpha
										x_in[1] = alpha;  //x1
										y_in[1] = 0x01; //beta;  // y_in[1] = x_in[2] ^ beta1;
										beta_in[1] = beta; //so,use beta_in[1] to store beta1.

										best = round_2(search_round);// Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best==1)
											return 1;
#endif
									}
								}
							}
						}
						}
						}
						}
						break;
					case 128:
						for(j=0;j<nBytes;j++)  //nBytes
						{
							Sa_LSB8 = (Sa>>(8*j)) & 0xFF; //8 bit
							Sb_LSB8 = (Sb>>(8*j)) & 0xFF; //8 bit
							AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
							gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
						}


						for(i7=0;i7<gama_num[7];i7++)
						{
						gama_7 = DDTAB_8bit[AB_indx[7]][i7];  //gama_num 4-7 bits
						for(i6=0;i6<gama_num[6];i6++)
						{
						gama_6 = DDTAB_8bit[AB_indx[6]][i6];  //gam2a_num 4-7 bits
						for(i5=0;i5<gama_num[5];i5++)
						{
						gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
						for(i4=0;i4<gama_num[4];i4++)
						{
						gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
						for(i3=0;i3<gama_num[3];i3++)
						{
						gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama =(gama_7 << 56) | (gama_6 << 48) | (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

//gama =  (DDTAB_8bit[AB_indx[7]][i7] << 56) | (DDTAB_8bit[AB_indx[6]][i6] << 48) | \
//		(DDTAB_8bit[AB_indx[5]][i5] << 40) | (DDTAB_8bit[AB_indx[4]][i4] << 32) | \
//		(DDTAB_8bit[AB_indx[3]][i3] << 24) | (DDTAB_8bit[AB_indx[2]][					if(beta == 0)i2] << 16) | \
//		(DDTAB_8bit[AB_indx[1]][i1] <<8) | DDTAB_8bit[AB_indx[0]][i0];


									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[1] = p_alpha;  // p1alpha
										x_in[1] = alpha;  //x1
										y_in[1] = 0x01; //beta;  // y_in[1] = x_in[2] ^ beta1;
										beta_in[1] = beta; //so,use beta_in[1] to store beta1.

										best = round_2(search_round);// Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best==1)
											return 1;
#endif
									}
								}
							}
						}
						}
						}
						}
						}
						}
						break;
					default:
						printf("Auto-search Error with blocksize! \n");
						break;
					}
				}
			}
		}
	}
	return best;
}
/**
 * @Search for the Differential of SIMON.
 * @Round 1.
 */
u16 round_1_diff(u16 search_round)
{
	u16 HM_w;
	u64 alpha = 0;  //x
	u64 beta = 0;  //beta.
	u64 gama = 0;  //gama.andout.
	u16 p_alpha = 0; // p with the input alpha.
	u64 Sa,Sb;
	u64 Sa_LSB8,Sb_LSB8;
	u16 best = 0;
	u16 HW_space_num = 0;
	u64 AB_indx[16] = {0};  // Sa and Sb
	u16 gama_num[]={0};
	u64 gama_0 = 0,gama_1 = 0,gama_2 = 0,gama_3 = 0,gama_4 = 0,gama_5 = 0,gama_6 = 0,gama_7 = 0;
	u16 i=0,i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0,j=0,k=0;


	if( search_round == 1)
	{
		return 1;
	}
	else
	{
		alpha = input_diff_L;  // simon_32 input: 0x0000 0001, output:0x0400 0100
		p_alpha = SIMON_DP_weight_compute(alpha);
//			if ((p_alpha + n_P_bestofR_w[search_round - 1]) <= Bn_w)
				{
					//////look up the DDTAB table to find the gama.//////
					Sa = ROTATE_LEFT(alpha,rol_a,blocksize_len);
					Sb = ROTATE_LEFT(alpha,rol_b,blocksize_len);

					switch(sc_blocksize)
					{
					case 32:
						//x0
						Sa_LSB8 = (Sa) & 0xFF; //8 bit
						Sb_LSB8 = (Sb) & 0xFF; //8 bit
						AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
						gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
						//x1
						Sa_LSB8 = Sa & 0xFF00; //8 bit
						Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
						AB_indx[1] = Sa_LSB8  | Sb_LSB8;
						gama_num[1] = DDTAB_8bit[AB_indx[1]][256];

						for(i1=0;i1<gama_num[1];i1++)
						{
							gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
							for(i0=0;i0 < gama_num[0];i0++)
							{
								gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
								gama = (gama_1 <<8) | gama_0;

								if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
								{
									beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
									P_w[1] = p_alpha;  // p1alpha
									x_in[1] = alpha;  //x1
									y_in[1] = input_diff_R; //beta;  // y_in[1] = x_in[2] ^ beta1;
									beta_in[1] = beta; //so,use beta_in[1] to store beta1.

									best = round_2_diff(search_round);// Call the next round.
#if 1   //是否找到第一条最优路径就返回？
									if(best==1)
										return 1;
#endif
								}
							}
						}
						break;
					case 48:
						//x0
						Sa_LSB8 = (Sa) & 0xFF; //8 bit
						Sb_LSB8 = (Sb) & 0xFF; //8 bit
						AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
						gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
						//x1
						Sa_LSB8 = Sa & 0x00FF00 ; //8 bit
						Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
						AB_indx[1] = Sa_LSB8  | Sb_LSB8;
						gama_num[1] = DDTAB_8bit[AB_indx[1]][256];
						//x2
						Sa_LSB8 = (Sa>>16) & 0x00FF; //8 bit
						Sb_LSB8 = (Sb>>16) & 0x00FF; //8 bit
						AB_indx[2] = ((Sa_LSB8 << 8) | Sb_LSB8);
						gama_num[2] = DDTAB_8bit[AB_indx[2]][256];

						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama = (gama_2 << 16) | (gama_1 <<8) | gama_0;

									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[1] = p_alpha;  // p1alpha
										x_in[1] = alpha;  //x1
										y_in[1] = input_diff_R; //beta;  // y_in[1] = x_in[2] ^ beta1;
										beta_in[1] = beta; //so,use beta_in[1] to store beta1.

										best = round_2_diff(search_round);// Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best==1)
											return 1;
#endif
									}
								}
							}
						}
						break;
					case 64:
						for(j=0;j<nBytes;j++)  //nBytes
						{
							Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
							Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
							AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
							gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
						}

						for(i3=0;i3<gama_num[3];i3++)
						{
						gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama = (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[1] = p_alpha;  // p1alpha
										x_in[1] = alpha;  //x1
										y_in[1] = input_diff_R; //beta;  // y_in[1] = x_in[2] ^ beta1;
										beta_in[1] = beta; //so,use beta_in[1] to store beta1.

										best = round_2_diff(search_round);// Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best==1)
											return 1;
#endif
									}
								}
							}
						}
					}
						break;
					case 96:
						for(j=0;j<nBytes;j++)  //nBytes
						{
							Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
							Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
							AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
							gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
						}

						for(i5=0;i5<gama_num[5];i5++)
						{
						gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
						for(i4=0;i4<gama_num[4];i4++)
						{
						gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
						for(i3=0;i3<gama_num[3];i3++)
						{
						gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama = (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[1] = p_alpha;  // p1alpha
										x_in[1] = alpha;  //x1
										y_in[1] = input_diff_R; //beta;  // y_in[1] = x_in[2] ^ beta1;
										beta_in[1] = beta; //so,use beta_in[1] to store beta1.

										best = round_2_diff(search_round);// Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best==1)
											return 1;
#endif
									}
								}
							}
						}
						}
						}
						}
						break;
					case 128:
						for(j=0;j<nBytes;j++)  //nBytes
						{
							Sa_LSB8 = (Sa>>(8*j)) & 0xFF; //8 bit
							Sb_LSB8 = (Sb>>(8*j)) & 0xFF; //8 bit
							AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
							gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
						}


						for(i7=0;i7<gama_num[7];i7++)
						{
						gama_7 = DDTAB_8bit[AB_indx[7]][i7];  //gama_num 4-7 bits
						for(i6=0;i6<gama_num[6];i6++)
						{
						gama_6 = DDTAB_8bit[AB_indx[6]][i6];  //gam2a_num 4-7 bits
						for(i5=0;i5<gama_num[5];i5++)
						{
						gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
						for(i4=0;i4<gama_num[4];i4++)
						{
						gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
						for(i3=0;i3<gama_num[3];i3++)
						{
						gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama =(gama_7 << 56) | (gama_6 << 48) | (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

//gama =  (DDTAB_8bit[AB_indx[7]][i7] << 56) | (DDTAB_8bit[AB_indx[6]][i6] << 48) | \
		(DDTAB_8bit[AB_indx[5]][i5] << 40) | (DDTAB_8bit[AB_indx[4]][i4] << 32) | \
		(DDTAB_8bit[AB_indx[3]][i3] << 24) | (DDTAB_8bit[AB_indx[2]][i2] << 16) | \
		(DDTAB_8bit[AB_indx[1]][i1] <<8) | DDTAB_8bit[AB_indx[0]][i0];

									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[1] = p_alpha;  // p1alpha
										x_in[1] = alpha;  //x1
										y_in[1] = input_diff_R; //beta;  // y_in[1] = x_in[2] ^ beta1;
										beta_in[1] = beta; //so,use beta_in[1] to store beta1.

										best = round_2_diff(search_round);// Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best==1)
											return 1;
#endif
									}
								}
							}
						}
						}
						}
						}
						}
						}
						break;
					default:
						printf("Auto-search Error with blocksize! \n");
						break;
					}
				}
			}
	return best;
}
/**
 * @Search for the FIRST Round of SIMON completely.
 * @
 */
u16 round_1_j(u16 search_round)
{
	/// the best of the r round input and ouput and probability.
	n_P_w[1] = 0;  // p1alpha
	n_P_bestofR_w[1] = n_P_w[1];
	n_x_in[1] = 0;  //x1
	n_y_in[1] = 0x01; //beta;  // y_in[1] = x_in[2] ^ beta1;
	n_beta_in[1] = 0; //so,use beta_in[1] to store beta1.
	n_x_in[2] = n_y_in[1];
	n_y_in[2] = n_x_in[1];  // y_in[1] = x_in[2] ^ beta1;

	return 1;
}

/**
 * @Search for the min weight of LT of the FIRST Round of SIMON completely.
 * @
 */
u16 round_1_Lineartrail(u16 search_round)
{
	u16 best = 0;
	u16 HM_w = 0,hw=0;
	u16 HW_space_num = 0;
	u64 beta = 0;  //beta.
	u16 P_beta = 0; // p with the output beat.
	u16 i=0,j=0,k=0,t=0;
	u64 U_base_tmp[65] = {0}; //u64 *U_base_tmp;  //
	u64 U_alpha_base[65] = {0};
	u16 alpha_nmu=0;
	u64 U_alpha_tmp=0;


	if( search_round == 1)
	{
		best = round_1_j(1);
		return best;
	}
	else
	{
		// 汉明重量逐渐增加
		for(HM_w=0;HM_w <= blocksize_len;HM_w++)  // alpha hamming weight 0-n wordsize. pow(2,n).
		{
			if ( (sCorrelation_max_compute(HM_w) + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
			{
				return 0;  // hamming weight increased,the corr max will be decreased,and Pmax weight be increase.
			}
			else
			{
				HW_space_num = HMspace_num[HM_w];  // The number of value of the corresponding HMW.
				for (hw=0;hw < HW_space_num;hw++)
				{
					beta = HMspace[HM_w][hw];
					P_beta = SIMON_SCorr_weight_check(beta, U_base_tmp);//,&U_base_num);
					//if((beta == 0x0080) && ( Bn_w == 34 ))
					//	printf("test-I1:: beta: %x  P_beta: %d \n",beta,P_beta);  // test.
					if ((P_beta + n_P_bestofR_w[search_round - 1]) <= Bn_w)
					{
						P_w[1] = P_beta;  // p1;
						x_in[1] = beta;

						j=0;
						for(i=0;i<blocksize_len;i++)
						{
							if(U_base_tmp[i] != 0)
							{
								U_alpha_base[j] = U_base_tmp[i];
								//printf("test-I2:: U_base_tmp: %x \n", U_base_tmp[j]);
								j=j+1;
							}
						}
						alpha_nmu = pow(2,j);
						//printf("test-I3:: alpha_nmu: %d \n", alpha_nmu );
						for(k=0; k<alpha_nmu;k++)
						{
							U_alpha_tmp = 0;
							for(t=0;t<j;t++)
							{
								if( (k & (1<<t)) != 0 )
								{
									U_alpha_tmp ^= U_alpha_base[t];
								}
							}

							//printf("test-I4:: beta: %x  P_beta: %d  U_alpha_tmp: %x \n",beta,P_beta,U_alpha_tmp);  // test.
							beta_in[1] = (RIGHT_rotation_64(U_alpha_tmp,rol_b,blocksize_len))
									^ (RIGHT_rotation_64(beta,rol_c,blocksize_len));

							x_in[0] = U_alpha_tmp; // X0
							//y_in[1] = U_base[i]; //beta;  // y_in[1] = x_in[2] ^ beta1;
							//printf("test-I5:: beta_in[1]: %x \n",beta_in[1]);

							best = round_2_Lineartrail(search_round);// Call the next round.
#if 1   //是否找到第一条最优路径就返回？
							if(best==1)
								return 1;
#endif
						}
					}
				}
			}
		}
	}
	return best;
}

u16 round_1_LinearHull(u16 search_round)
{
	u16 best = 0;
	u16 HM_w = 0,hw=0;
	u16 HW_space_num = 0;
	u64 beta = 0;  //beta.
	u16 P_beta = 0; // p with the output beat.
	u16 i=0,j=0,k=0,t=0;
	u64 U_base_tmp[65] = {0}; //u64 *U_base_tmp;  //
	u64 U_alpha_base[65] = {0};
	u16 alpha_nmu=0;
	u64 U_alpha_tmp=0;


	if( search_round == 1)
	{
		return 1;
	}
	else
	{
		beta = input_mask_R;
		P_beta = SIMON_SCorr_weight_check(beta, U_base_tmp);//,&U_base_num);

		if ((P_beta + n_P_bestofR_w[search_round - 1]) <= wt_max)  //Bn_w)
		{
			P_w[1] = P_beta;  // p1;
			x_in[1] = beta;

			j=0;
			for(i=0;i<blocksize_len;i++)
			{
				if(U_base_tmp[i] != 0)
				{
					U_alpha_base[j] = U_base_tmp[i];
					j=j+1;
				}
			}
			alpha_nmu = pow(2,j);
			for(k=0; k<alpha_nmu;k++)
			{
				U_alpha_tmp = 0;
				for(t=0;t<j;t++)
				{
					if( (k & (1<<t)) != 0 )
					{
						U_alpha_tmp ^= U_alpha_base[t];
					}
				}

				beta_in[1] = (RIGHT_rotation_64(U_alpha_tmp,rol_b,blocksize_len))
						^ (RIGHT_rotation_64(beta,rol_c,blocksize_len));
				x_in[0] = input_mask_L; // X0

				best = round_2_LinearHull(search_round);// Call the next round.
#if 1   //是否找到第一条最优路径就返回？
				if(best==1)
					return 1;
#endif
			}
		}
	}
	return best;
}


/**
 * @Search for the min weight of DP of the 2 Round of SIMON completely.
 * @
 */
u16 round_2(u16 search_round)
{
	u16 HM_w = 0;
	u64 alpha = 0;  //x
	u64 beta = 0;  //beta.
	u64 gama = 0;  //gama.andout.
	u16 p_alpha = 0; // p with the input alpha.
	u64 Sa,Sb;
	u64 Sa_LSB8,Sb_LSB8;
	u16 best = 0;;
	u64 HW_space_num = 0;
	u64 AB_indx[16] = {0};  // Sa and Sb
	u16 gama_num[]={0};
	u64 gama_0 = 0,gama_1 = 0,gama_2 = 0,gama_3 = 0,gama_4 = 0,gama_5 = 0,gama_6 = 0,gama_7 = 0;
	u16 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0,j=0,k=0;

	if(search_round == 2)
	{
		best = round_2_j(2);
		return best;
	}
	else
	{
	// 汉明重量逐渐增加的alpha,而不是数值直接增加
	for(HM_w=0;HM_w <= blocksize_len;HM_w++) // alpha hamming weight 0-n wordsize. pow(2,n).
	{
		if ( P_w[1] + Pmax_compute(HM_w) + n_P_bestofR_w[search_round - 2] > Bn_w)  // Pmax_compute(xi) is the ri round min weight.
		{
			return 0; //alpha increased,the Pmax will be decrease,and Pmax weight be increase.
		}

		HW_space_num = HMspace_num[HM_w];  // The number of value of the corresponding HMW.
		for (k=0;k < HW_space_num;k++)
		{
			alpha = HMspace[HM_w][k];
			p_alpha = SIMON_DP_weight_compute(alpha);
			if ((P_w[1] + p_alpha + n_P_bestofR_w[search_round - 2]) <= Bn_w)//compute and check validity.
				{
					//////look up the DDTAB_4bit_init table to find the gama.//////
					Sa = ROTATE_LEFT(alpha,rol_a,blocksize_len);
					Sb = ROTATE_LEFT(alpha,rol_b,blocksize_len);

					switch(sc_blocksize)
					{
					case 32:
						//x0
						Sa_LSB8 = (Sa) & 0xFF; //8 bit
						Sb_LSB8 = (Sb) & 0xFF; //8 bit
						AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
						gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
						//x1
						Sa_LSB8 = Sa & (0xFF << 8); //8 bit
						Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
						AB_indx[1] = Sa_LSB8  | Sb_LSB8;
						gama_num[1] = DDTAB_8bit[AB_indx[1]][256];

						gama_cnt[2] = gama_num[0] * gama_num[1];

						for(i1=0;i1<gama_num[1];i1++)
						{
							gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
							for(i0=0;i0<gama_num[0];i0++)
							{
								gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bits
								gama = (gama_1 <<8) | gama_0;

								if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
								{
									beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len);
									P_w[2] = p_alpha;  // p1alpha
									x_in[2] = alpha;  //x2
									y_in[2] = x_in[1];  //y2
									beta_in[2] = beta; //so,use beta_in[i] to store betai.

									best = round_r(search_round,3); // Call the next round.
#if 1   //是否找到第一条最优路径就返回？
									if(best ==1)
										return 1;
#endif
								}
							}
						}
						break;
					case 48:
						//x0
						Sa_LSB8 = (Sa) & 0xFF; //8 bit
						Sb_LSB8 = (Sb) & 0xFF; //8 bit
						AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
						gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
						//x1
						Sa_LSB8 = Sa & 0x00FF00 ; //8 bit
						Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
						AB_indx[1] = Sa_LSB8  | Sb_LSB8;
						gama_num[1] = DDTAB_8bit[AB_indx[1]][256];
						//x2
						Sa_LSB8 = (Sa>>16) & 0x00FF; //8 bit
						Sb_LSB8 = (Sb>>16) & 0x00FF; //8 bit
						AB_indx[2] = ((Sa_LSB8 << 8) | Sb_LSB8);
						gama_num[2] = DDTAB_8bit[AB_indx[2]][256];

						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama = (gama_2 << 16) | (gama_1 <<8) | gama_0;

									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[2] = p_alpha;  // p1alpha
										x_in[2] = alpha;  //x2
										y_in[2] = x_in[1];  //y2
										beta_in[2] = beta; //so,use beta_in[i] to store betai.

										best = round_r(search_round,3); // Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best ==1)
											return 1;
#endif
									}
								}
							}
						}
						break;
					case 64:
						for(j=0;j<nBytes;j++)  //nBytes
						{
							Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
							Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
							AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
							gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
						}

						for(i3=0;i3<gama_num[3];i3++)
						{
						gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama = (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[2] = p_alpha;  // p1alpha
										x_in[2] = alpha;  //x2
										y_in[2] = x_in[1];  //y2
										beta_in[2] = beta; //so,use beta_in[i] to store betai.

										best = round_r(search_round,3); // Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best ==1)
											return 1;
#endif
									}
								}
							}
						}
					}
						break;
					case 96:
						for(j=0;j<nBytes;j++)  //nBytes
						{
							Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
							Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
							AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
							gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
						}

						for(i5=0;i5<gama_num[5];i5++)
						{
						gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
						for(i4=0;i4<gama_num[4];i4++)
						{
						gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
						for(i3=0;i3<gama_num[3];i3++)
						{
						gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama = (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[2] = p_alpha;  // p1alpha
										x_in[2] = alpha;  //x2
										y_in[2] = x_in[1];  //y2
										beta_in[2] = beta; //so,use beta_in[i] to store betai.

										best = round_r(search_round,3); // Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best ==1)
											return 1;
#endif
									}
								}
							}
						}
						}
						}
						}
					break;
					case 128:
//#pragma omp parallel for
						for(j=0;j<nBytes;j++)  //nBytes
						{
							Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
							Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
							AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
							gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
						}

						for(i7=0;i7<gama_num[7];i7++)
						{
						gama_7 = DDTAB_8bit[AB_indx[7]][i7];  //gama_num 4-7 bits
						for(i6=0;i6<gama_num[6];i6++)
						{
						gama_6 = DDTAB_8bit[AB_indx[6]][i6];  //gam2a_num 4-7 bits
						for(i5=0;i5<gama_num[5];i5++)
						{
						gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
						for(i4=0;i4<gama_num[4];i4++)
						{
						gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
						for(i3=0;i3<gama_num[3];i3++)
						{
						gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama =(gama_7 << 56) | (gama_6 << 48) | (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;


									//gama =  (DDTAB_8bit[AB_indx[7]][i7] << 56) | (DDTAB_8bit[AB_indx[6]][i6] << 48) | \
											(DDTAB_8bit[AB_indx[5]][i5] << 40) | (DDTAB_8bit[AB_indx[4]][i4] << 32) | \
											(DDTAB_8bit[AB_indx[3]][i3] << 24) | (DDTAB_8bit[AB_indx[2]][i2] << 16) | \
											(DDTAB_8bit[AB_indx[1]][i1] <<8) | DDTAB_8bit[AB_indx[0]][i0];


									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[2] = p_alpha;  // p1alpha
										x_in[2] = alpha;  //x2
										y_in[2] = x_in[1];  //y2
										beta_in[2] = beta; //so,use beta_in[i] to store betai.

										best = round_r(search_round,3); // Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best ==1)
											return 1;
#endif
									}
								}
							}
						}
						}
						}
						}
						}
						}
					break;
					default:
						break;
					}
			}
		}
	}
}
	return best;
}
/**
 * @Search for the min weight of DP of the 2 Round of SIMON completely.
 * @
 */
u16 round_2_diff(u16 search_round)
{
	u16 HM_w = 0;
	u64 alpha = 0;  //x
	u64 beta = 0;  //beta.
	u64 gama = 0;  //gama.andout.
	u16 p_alpha = 0; // p with the input alpha.
	u64 Sa,Sb;
	u64 Sa_LSB8,Sb_LSB8;
	u16 best = 0;;
	u16 HW_space_num = 0;
	u64 AB_indx[16] = {0};  // Sa and Sb
	u16 gama_num[]={0};
	u64 gama_0 = 0,gama_1 = 0,gama_2 = 0,gama_3 = 0,gama_4 = 0,gama_5 = 0,gama_6 = 0,gama_7 = 0;
	u16 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0,j=0,k=0;

	if(search_round == 2)
	{
		return 1;
	}
	else
	{
		alpha = input_diff_R ^ beta_in[1];
		p_alpha = SIMON_DP_weight_compute(alpha);
//			if ((P_w[1] + p_alpha + n_P_bestofR_w[search_round - 2]) <= Bn_w)//compute and check validity.
				{
					//////look up the DDTAB_4bit_init table to find the gama.//////
					Sa = ROTATE_LEFT(alpha,rol_a,blocksize_len);
					Sb = ROTATE_LEFT(alpha,rol_b,blocksize_len);

					switch(sc_blocksize)
					{
					case 32:
						//x0
						Sa_LSB8 = (Sa) & 0xFF; //8 bit
						Sb_LSB8 = (Sb) & 0xFF; //8 bit
						AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
						gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
						//x1
						Sa_LSB8 = Sa & (0xFF << 8); //8 bit
						Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
						AB_indx[1] = Sa_LSB8  | Sb_LSB8;
						gama_num[1] = DDTAB_8bit[AB_indx[1]][256];

						for(i1=0;i1<gama_num[1];i1++)
						{
							gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
							for(i0=0;i0<gama_num[0];i0++)   //printf("--------gama_num[0]: %d-----------\n",gama_num[0]);
							{
								gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bits
								gama = (gama_1 <<8) | gama_0;

								if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
								{
									beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
									P_w[2] = p_alpha;  // p1alpha
									x_in[2] = alpha;  //x2
									y_in[2] = x_in[1];  //y2
									beta_in[2] = beta; //so,use beta_in[i] to store betai.

									best = round_r_diff(search_round,3); // Call the next round.
#if 1   //是否找到第一条最优路径就返回？
									if(best ==1)
										return 1;
#endif
								}
							}
						}
						break;
					case 48:
						//x0
						Sa_LSB8 = (Sa) & 0xFF; //8 bit
						Sb_LSB8 = (Sb) & 0xFF; //8 bit
						AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
						gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
						//x1
						Sa_LSB8 = Sa & 0x00FF00 ; //8 bit
						Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
						AB_indx[1] = Sa_LSB8  | Sb_LSB8;
						gama_num[1] = DDTAB_8bit[AB_indx[1]][256];
						//x2
						Sa_LSB8 = (Sa>>16) & 0x00FF; //8 bit
						Sb_LSB8 = (Sb>>16) & 0x00FF; //8 bit
						AB_indx[2] = ((Sa_LSB8 << 8) | Sb_LSB8);
						gama_num[2] = DDTAB_8bit[AB_indx[2]][256];

						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama = (gama_2 << 16) | (gama_1 <<8) | gama_0;

									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[2] = p_alpha;  // p1alpha
										x_in[2] = alpha;  //x2
										y_in[2] = x_in[1];  //y2
										beta_in[2] = beta; //so,use beta_in[i] to store betai.

										best = round_r_diff(search_round,3); // Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best ==1)
											return 1;
#endif
									}
								}
							}
						}
						break;
					case 64:
						for(j=0;j<nBytes;j++)  //nBytes
						{
							Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
							Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
							AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
							gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
						}

						for(i3=0;i3<gama_num[3];i3++)
						{
						gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama = (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[2] = p_alpha;  // p1alpha
										x_in[2] = alpha;  //x2
										y_in[2] = x_in[1];  //y2
										beta_in[2] = beta; //so,use beta_in[i] to store betai.

										best = round_r_diff(search_round,3); // Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best ==1)
											return 1;
#endif
									}
								}
							}
						}
					}
						break;
					case 96:
						for(j=0;j<nBytes;j++)  //nBytes
						{
							Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
							Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
							AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
							gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
						}

						for(i5=0;i5<gama_num[5];i5++)
						{
						gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
						for(i4=0;i4<gama_num[4];i4++)
						{
						gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
						for(i3=0;i3<gama_num[3];i3++)
						{
						gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama = (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[2] = p_alpha;  // p1alpha
										x_in[2] = alpha;  //x2
										y_in[2] = x_in[1];  //y2
										beta_in[2] = beta; //so,use beta_in[i] to store betai.

										best = round_r_diff(search_round,3); // Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best ==1)
											return 1;
#endif
									}
								}
							}
						}
						}
						}
						}
					break;
					case 128:
//#pragma omp parallel for
						for(j=0;j<nBytes;j++)  //nBytes
						{
							Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
							Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
							AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
							gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
						}

						for(i7=0;i7<gama_num[7];i7++)
						{
						gama_7 = DDTAB_8bit[AB_indx[7]][i7];  //gama_num 4-7 bits
						for(i6=0;i6<gama_num[6];i6++)
						{
						gama_6 = DDTAB_8bit[AB_indx[6]][i6];  //gam2a_num 4-7 bits
						for(i5=0;i5<gama_num[5];i5++)
						{
						gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
						for(i4=0;i4<gama_num[4];i4++)
						{
						gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
						for(i3=0;i3<gama_num[3];i3++)
						{
						gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
						for(i2=0;i2<gama_num[2];i2++)
						{
							gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
							for(i1=0;i1<gama_num[1];i1++)
							{
								gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
								for(i0=0;i0 < gama_num[0];i0++)
								{
									gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
									gama =(gama_7 << 56) | (gama_6 << 48) | (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;
									//gama =  (DDTAB_8bit[AB_indx[7]][i7] << 56) | (DDTAB_8bit[AB_indx[6]][i6] << 48) | \
											(DDTAB_8bit[AB_indx[5]][i5] << 40) | (DDTAB_8bit[AB_indx[4]][i4] << 32) | \
											(DDTAB_8bit[AB_indx[3]][i3] << 24) | (DDTAB_8bit[AB_indx[2]][i2] << 16) | \
											(DDTAB_8bit[AB_indx[1]][i1] <<8) | DDTAB_8bit[AB_indx[0]][i0];

									if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
									{
										beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta1.Go to next round.
										P_w[2] = p_alpha;  // p1alpha
										x_in[2] = alpha;  //x2
										y_in[2] = x_in[1];  //y2
										beta_in[2] = beta; //so,use beta_in[i] to store betai.

										best = round_r_diff(search_round,3); // Call the next round.
#if 1   //是否找到第一条最优路径就返回？
										if(best ==1)
											return 1;
#endif
									}
								}
							}
						}
						}
						}
						}
						}
						}
					break;
					default:
						break;
					}
			}
		}
	return best;
}
/**
 * @Jump to 2rd Round of SIMON completely.
 * @
 */
u16 round_2_j(u16 search_round)
{
	u16 p_alpha=0;
	u16 P_beta=0;
	u64 U_base_tmp[65] = {0};
//	u64 U_base_num = 0;
//	u16 alpha_nmu=0;
//	u64 U_alpha_tmp=0;

	if(str_mode < 2)
	{
	p_alpha = SIMON_DP_weight_compute(0x0001);
	n_P_w[2] = p_alpha;  // p1alpha

	if(Bn_w ==  n_P_w[2] +  P_w[1])
	{
		n_P_bestofR_w[2] = n_P_w[2] +  P_w[1];
		n_x_in[1] = x_in[1];  //x1
		n_y_in[1] = 0x01 ^ beta_in[1];  //y1
		n_x_in[2] = 0x01;  //x2
		n_y_in[2] = x_in[1];  //y2
		n_x_in[3] = n_x_in[1] ^ ROTATE_LEFT(0x01,rol_c,blocksize_len);; //x3
		n_y_in[3] = n_x_in[2];  //y3
	}
	}
	else
	if(str_mode <4)
	{
		P_beta = SIMON_SCorr_weight_check(0x0001, U_base_tmp); //,&U_base_num);
		n_P_w[2] = P_beta;  // p1alpha

		if(Bn_w ==  n_P_w[2] +  P_w[1])
		{
			n_P_bestofR_w[2] = n_P_w[2];// +  P_w[1];
			n_x_in[1] = x_in[0];  //x1
			n_y_in[1] = x_in[1] ;  //0x01 ^ beta_in[1];  //y1

			n_x_in[2] = n_y_in[1];  //x2
			n_y_in[2] =  0x0001; //x_in[2];  //y2

			beta_in[1] = (ROTATE_RIGHT(U_base_tmp[0],rol_b,blocksize_len))
					^ (ROTATE_RIGHT(0x0001  ,rol_c,blocksize_len));

			n_x_in[3] = n_y_in[2]; //x3
			n_y_in[3] = n_x_in[2] ^ beta_in[1];  //y3
		}

	}

	return 1;
}

u16 round_2_Lineartrail(u16 search_round)
{
	u16 best = 0;
	u16 HM_w = 0,hw=0;
	u16 HW_space_num = 0;
	u64 beta = 0;  //beta.
	u16 P_beta = 0; // p with the output beat.
	u16 i=0,j=0,k=0,t=0;
	u64 U_base_tmp[65] = {0};
	//u64 *U_base_tmp;  //
	u64 U_alpha_base[65] = {0};
	u16 alpha_nmu=0;
	u64 U_alpha_tmp=0;


	if(search_round == 2)
	{
		best = round_2_j(2);
		return best;
	}
	else
	{
		// 汉明重量逐渐增加
		for(HM_w=0;HM_w <= blocksize_len;HM_w++)  // alpha hamming weight 0-n wordsize. pow(2,n).
		{
			if ((P_w[1] + sCorrelation_max_compute(HM_w) + n_P_bestofR_w[search_round - 2]) > Bn_w)
			{
				return 0;  // hamming weight increased,the corr max will be decreased,and Pmax weight be increase.
			}
			else
			{
				HW_space_num = HMspace_num[HM_w];  // The number of value of the corresponding HMW.
				for (hw=0;hw < HW_space_num;hw++)
				{
					beta = HMspace[HM_w][hw];
					P_beta = SIMON_SCorr_weight_check(beta, U_base_tmp); //,&U_base_num);
					//if((beta == 0x2200) && ( Bn_w == 34 ))
					//printf("test-II:: beta: %x  P_beta: %d \n",beta,P_beta);  // test.
					if ((P_w[1] + P_beta + n_P_bestofR_w[search_round - 2]) <= Bn_w)
					{
						P_w[2] = P_beta;  // p1;
						x_in[2] = beta;

						j=0;
						for(i=0;i<blocksize_len;i++)
						{
							if(U_base_tmp[i] != 0)
							{
								U_alpha_base[j] = U_base_tmp[i];
								//printf("test-II1:: U_base_tmp: %x \n", U_base[i]);
								j=j+1;
							}
						}
						alpha_nmu = pow(2,j) ;
						//printf("test-II2:: alpha_nmu: %d \n", alpha_nmu );
						for(k=0; k<alpha_nmu;k++)
						{
							U_alpha_tmp = 0;
							for(t=0;t<j;t++)
							{
								if( (k & (1<<t)) != 0 )
								{
									U_alpha_tmp ^= U_alpha_base[t];
								}
							}

						//printf("test-II3:: beta: %x  P_beta: %d  U_alpha_tmp: %x \n",beta,P_beta,U_alpha_tmp);  // test.
						beta_in[2] = (RIGHT_rotation_64(U_alpha_tmp,rol_b,blocksize_len))
									^ (RIGHT_rotation_64(beta,rol_c,blocksize_len));

						x_in[0] = x_in[2] ^ beta_in[1];  //alpha
						best = round_r_Lineartrail(search_round,3);// Call the next round.

#if 1   //是否找到第一条最优路径就返回？
						if(best==1)
							return 1;
#endif
						}
						}
					}
				}
			}
		}
	return best;
}

u16 round_2_LinearHull(u16 search_round)
{
	u16 best = 0;
	u16 HM_w = 0,hw=0;
	u16 HW_space_num = 0;
	u64 beta = 0;  //beta.
	u16 P_beta = 0; // p with the output beat.
	u16 i=0,j=0,k=0,t=0;
	u64 U_base_tmp[65] = {0};
	//u64 *U_base_tmp;  //
	u64 U_alpha_base[65] = {0};
	u16 alpha_nmu=0;
	u64 U_alpha_tmp=0;

	if(search_round == 2)
	{
		return 1;
	}
	else
	{
		beta = input_mask_L ^ beta_in[1];
		P_beta = SIMON_SCorr_weight_check(beta, U_base_tmp); //,&U_base_num);

		if ((P_w[1] + P_beta + n_P_bestofR_w[search_round - 2]) <= wt_max)  //Bn_w)
		{
			P_w[2] = P_beta;  // p1;
			x_in[2] = beta;

			j=0;
			for(i=0;i<blocksize_len;i++)
			{
				if(U_base_tmp[i] != 0)
				{
					U_alpha_base[j] = U_base_tmp[i];
					j=j+1;
				}
			}
			alpha_nmu = pow(2,j) ;
			for(k=0; k<alpha_nmu;k++)
			{
				U_alpha_tmp = 0;
				for(t=0;t<j;t++)
				{
					if( (k & (1<<t)) != 0 )
					{
						U_alpha_tmp ^= U_alpha_base[t];
					}
				}

			beta_in[2] = (RIGHT_rotation_64(U_alpha_tmp,rol_b,blocksize_len))
						^ (RIGHT_rotation_64(beta,rol_c,blocksize_len));

			best = round_r_LinearHull(search_round,3);// Call the next round.
#if 1   //是否找到第一条最优路径就返回？
			if(best==1)
				return 1;
#endif
			}
		}
	}
	return best;
}


/**
 * @Search for the min weight of DP of the r>2 Round of SIMON completely.
 * @
 */
u16 round_r(u16 search_round, u16 cur_round)
{
	u64 alpha = 0;  //x
	u64 beta = 0;  //beta.
	u64 gama = 0;  //gama.andout.
	u16 p_alpha = 0; // p with the input alpha.
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 Sa,Sb;
	u64 Sa_LSB8,Sb_LSB8;
	u16 best = 0;
	u64 AB_indx[16] = {0};  // Sa and Sb
	u16 gama_num[]={0};

	u64 gama_0 = 0,gama_1 = 0,gama_2 = 0,gama_3 = 0,gama_4 = 0,gama_5 = 0,gama_6 = 0,gama_7 = 0;
	u16 i=0,i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0,j=0;

	if(search_round == cur_round)
	{
		best = round_N(search_round);
		return best;
	}
	else
	{
		alpha = x_in[cur_round-2] ^ beta_in[cur_round-1]   ;  //x of r round.
		p_alpha = SIMON_DP_weight_compute(alpha);

		for(i=1;i<cur_round;i++)
		{
			p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
		}

	if ((p_sumof_r + p_alpha + n_P_bestofR_w[search_round - cur_round]) <= Bn_w)
	{
		//////look up the DDTAB_4bit_init table to find the gama.///////
		Sa = ROTATE_LEFT(alpha,rol_a,blocksize_len);
		Sb = ROTATE_LEFT(alpha,rol_b,blocksize_len);

		switch(sc_blocksize)
		{
		case 32:
			//x0
			Sa_LSB8 = (Sa) & 0xFF; //8 bit
			Sb_LSB8 = (Sb) & 0xFF; //8 bit
			AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
			gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
			//x1
			Sa_LSB8 = Sa & 0xFF00; //8 bit
			Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
			AB_indx[1] = Sa_LSB8  | Sb_LSB8;
			gama_num[1] = DDTAB_8bit[AB_indx[1]][256];

			gama_cnt[cur_round] = gama_num[0] * gama_num[1];

			for(i1=0;i1 < gama_num[1];i1++)
			{
				gama_1 = (u16)DDTAB_8bit[AB_indx[1]][i1];  //memcpy(&gama_1,&DDTAB_8bit[AB_indx[1]][i1],1)
				for(i0=0;i0 < gama_num[0];i0++)
				{
					gama_0 = (u16)DDTAB_8bit[AB_indx[0]][i0]; //memcpy(&gama_0,&DDTAB_8bit[AB_indx[0]][i0],1);
					gama = (gama_1 << 8) | gama_0;  //gama = gama_1 * 256 + gama_0;

					/////////////// search every gama. And Jump to next round//////////////////////////
					if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
					{
						beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta.
						P_w[cur_round] = p_alpha;  // p or r round.
						x_in[cur_round] = alpha;  //x of round.
						y_in[cur_round] = x_in[cur_round-1];  //y of round.
						beta_in[cur_round] = beta & 0xFFFF; //so,use beta_in[i] to store betai.

						best = round_r(search_round,cur_round+1);

#if 1   //是否找到第一条最优路径就返回？
						if(best == 1)
							return 1;
#endif
					}
				}
			}
			break;
		case 48:
			//x0
			Sa_LSB8 = (Sa) & 0xFF; //8 bit
			Sb_LSB8 = (Sb) & 0xFF; //8 bit
			AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
			gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
			//x1
			Sa_LSB8 = Sa & (0xFF << 8); //8 bit
			Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
			AB_indx[1] = Sa_LSB8  | Sb_LSB8;
			gama_num[1] = DDTAB_8bit[AB_indx[1]][256];
			//x2
			Sa_LSB8 = (Sa>>16) & 0x00FF; //8 bit
			Sb_LSB8 = (Sb>>16) & 0x00FF; //8 bit
			AB_indx[2] = ((Sa_LSB8 << 8) | Sb_LSB8);
			gama_num[2] = DDTAB_8bit[AB_indx[2]][256];

			for(i2=0;i2<gama_num[2];i2++)
			{
				gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
				for(i1=0;i1<gama_num[1];i1++)
				{
					gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
					for(i0=0;i0 < gama_num[0];i0++)
					{
						gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
						gama = (gama_2 << 16) | (gama_1 <<8) | gama_0;

						/////////////// search every gama. And Jump to next round//////////////////////////
						if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
						{
							beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta.
							P_w[cur_round] = p_alpha;  // p or r round.
							x_in[cur_round] = alpha;  //x of round.
							y_in[cur_round] = x_in[cur_round-1];  //y of round.
							beta_in[cur_round] = beta; //so,use beta_in[i] to store betai. // & 0xFFFFFF

							best = round_r(search_round,cur_round+1);

	#if 1   //是否找到第一条最优路径就返回？
							if(best == 1)
								return 1;
	#endif
						}
					}
				}
			}
			break;
		case 64:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
				Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
				AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
				gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
			}

			for(i3=0;i3<gama_num[3];i3++)
			{
			gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
			for(i2=0;i2<gama_num[2];i2++)
			{
				gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
				for(i1=0;i1<gama_num[1];i1++)
				{
					gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
					for(i0=0;i0 < gama_num[0];i0++)
					{
						gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
						gama = (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

						/////////////// search every gama. And Jump to next round//////////////////////////
						if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
						{
							beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta.
							P_w[cur_round] = p_alpha;  // p or r round.
							x_in[cur_round] = alpha;  //x of round.
							y_in[cur_round] = x_in[cur_round-1];  //y of round.
							beta_in[cur_round] = beta; //so,use beta_in[i] to store betai.

							best = round_r(search_round,cur_round+1);

#if 1   //是否找到第一条最优路径就返回？
							if(best == 1)
								return 1;
#endif
						}
					}
				}
			}
			}
			break;
		case 96:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
				Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
				AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
				gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
			}

			for(i5=0;i5<gama_num[5];i5++)
			{
			gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
			for(i4=0;i4<gama_num[4];i4++)
			{
			gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
			for(i3=0;i3<gama_num[3];i3++)
			{
			gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
			for(i2=0;i2<gama_num[2];i2++)
			{
				gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
				for(i1=0;i1<gama_num[1];i1++)
				{
					gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
					for(i0=0;i0 < gama_num[0];i0++)
					{
						gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
						gama = (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

						/////////////// search every gama. And Jump to next round//////////////////////////
						if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
						{
							beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta.
							P_w[cur_round] = p_alpha;  // p or r round.
							x_in[cur_round] = alpha;  //x of round.
							y_in[cur_round] = x_in[cur_round-1];  //y of round.
							beta_in[cur_round] = beta; //so,use beta_in[i] to store betai.

							best = round_r(search_round,cur_round+1);

#if 1   //是否找到第一条最优路径就返回？
							if(best == 1)
								return 1;
#endif
						}
					}
				}
			}
			}
			}
			}
			break;
		case 128:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
				Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
				AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
				gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
			}

			for(i7=0;i7<gama_num[7];i7++)
			{
			gama_7 = DDTAB_8bit[AB_indx[7]][i7];  //gama_num 4-7 bits
			for(i6=0;i6<gama_num[6];i6++)
			{
			gama_6 = DDTAB_8bit[AB_indx[6]][i6];  //gam2a_num 4-7 bits
			for(i5=0;i5<gama_num[5];i5++)
			{
			gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
			for(i4=0;i4<gama_num[4];i4++)
			{
			gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
			for(i3=0;i3<gama_num[3];i3++)
			{
			gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
			for(i2=0;i2<gama_num[2];i2++)
			{
				gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
				for(i1=0;i1<gama_num[1];i1++)
				{
					gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
					for(i0=0;i0 < gama_num[0];i0++)
					{
						gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
						gama =(gama_7 << 56) | (gama_6 << 48) | (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;


						//gama =  (DDTAB_8bit[AB_indx[7]][i7] << 56) | (DDTAB_8bit[AB_indx[6]][i6] << 48) | \
								(DDTAB_8bit[AB_indx[5]][i5] << 40) | (DDTAB_8bit[AB_indx[4]][i4] << 32) | \
								(DDTAB_8bit[AB_indx[3]][i3] << 24) | (DDTAB_8bit[AB_indx[2]][i2] << 16) | \
								(DDTAB_8bit[AB_indx[1]][i1] <<8) | DDTAB_8bit[AB_indx[0]][i0];
						/////////////// search every gama. And Jump to next round//////////////////////////
						if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
						{
							beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta.
							P_w[cur_round] = p_alpha;  // p or r round.
							x_in[cur_round] = alpha;  //x of round.
							y_in[cur_round] = x_in[cur_round-1];  //y of round.
							beta_in[cur_round] = beta; //so,use beta_in[i] to store betai.

							best = round_r(search_round,cur_round+1);

#if 1   //是否找到第一条最优路径就返回？
							if(best == 1)
								return 1;
#endif
						}
					}
				}
			}
			}
			}
			}
			}
			}
			break;
		default:
			break;
		}
		}
	}
	return best;
}
/**
 * @Search for the FIRST Round of SIMON completely.
 * @Round r.
 */
u16 round_r_diff(u16 search_round, u16 cur_round)
{
	u64 alpha = 0;  //x
	u64 beta = 0;  //beta.
	u64 gama = 0;  //gama.andout.
	u16 p_alpha = 0; // p with the input alpha.
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 Sa,Sb;
	u64 Sa_LSB8,Sb_LSB8;
	u16 best = 0;
	u64 AB_indx[16] = {0};  // Sa and Sb
	u16 gama_num[]={0};

	u64 gama_0 = 0,gama_1 = 0,gama_2 = 0,gama_3 = 0,gama_4 = 0,gama_5 = 0,gama_6 = 0,gama_7 = 0;
	u16 i=0,i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0,j=0;

	if(search_round == cur_round)
	{
		best = round_N_diff(search_round);
		return best;
	}
	else
	{
		alpha = x_in[cur_round-2] ^ beta_in[cur_round-1]   ;  //x of r round.
		p_alpha = SIMON_DP_weight_compute(alpha);

		for(i=1;i<cur_round;i++)
		{
			p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
		}

	if ((p_sumof_r + p_alpha + n_P_bestofR_w[search_round - cur_round]) <= wt_max)
//	if ((p_sumof_r + p_alpha + n_P_bestofR_w[search_round - cur_round]) <= Bn_w)
	{
		//////look up the DDTAB_4bit_init table to find the gama.///////
		Sa = ROTATE_LEFT(alpha,rol_a,blocksize_len);
		Sb = ROTATE_LEFT(alpha,rol_b,blocksize_len);

		switch(sc_blocksize)
		{
		case 32:
			//x0
			Sa_LSB8 = (Sa) & 0xFF; //8 bit
			Sb_LSB8 = (Sb) & 0xFF; //8 bit
			AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
			gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
			//x1
			Sa_LSB8 = Sa & 0xFF00; //8 bit
			Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
			AB_indx[1] = Sa_LSB8  | Sb_LSB8;
			gama_num[1] = DDTAB_8bit[AB_indx[1]][256];

			for(i1=0;i1 < gama_num[1];i1++)
			{
				gama_1 = (u16)DDTAB_8bit[AB_indx[1]][i1];  //memcpy(&gama_1,&DDTAB_8bit[AB_indx[1]][i1],1)
				for(i0=0;i0 < gama_num[0];i0++)
				{
					gama_0 = (u16)DDTAB_8bit[AB_indx[0]][i0]; //memcpy(&gama_0,&DDTAB_8bit[AB_indx[0]][i0],1);
					gama = (gama_1 << 8) | gama_0;  //gama = gama_1 * 256 + gama_0;

					/////////////// search every gama. And Jump to next round//////////////////////////
					if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
					{
						beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta.
						P_w[cur_round] = p_alpha;  // p or r round.
						x_in[cur_round] = alpha;  //x of round.
						y_in[cur_round] = x_in[cur_round-1];  //y of round.
						beta_in[cur_round] = beta & 0xFFFF; //so,use beta_in[i] to store betai.

						best = round_r_diff(search_round,cur_round+1);

#if 1   //是否找到第一条最优路径就返回？
						if(best == 1)
							return 1;
#endif
					}
				}
			}
			break;
		case 48:
			//x0
			Sa_LSB8 = (Sa) & 0xFF; //8 bit
			Sb_LSB8 = (Sb) & 0xFF; //8 bit
			AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
			gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
			//x1
			Sa_LSB8 = Sa & (0xFF << 8); //8 bit
			Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
			AB_indx[1] = Sa_LSB8  | Sb_LSB8;
			gama_num[1] = DDTAB_8bit[AB_indx[1]][256];
			//x2
			Sa_LSB8 = (Sa>>16) & 0x00FF; //8 bit
			Sb_LSB8 = (Sb>>16) & 0x00FF; //8 bit
			AB_indx[2] = ((Sa_LSB8 << 8) | Sb_LSB8);
			gama_num[2] = DDTAB_8bit[AB_indx[2]][256];

			for(i2=0;i2<gama_num[2];i2++)
			{
				gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
				for(i1=0;i1<gama_num[1];i1++)
				{
					gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
					for(i0=0;i0 < gama_num[0];i0++)
					{
						gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
						gama = (gama_2 << 16) | (gama_1 <<8) | gama_0;

						/////////////// search every gamma. And Jump to next round//////////////////////////
						if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
						{
							beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta.
							P_w[cur_round] = p_alpha;  // p or r round.
							x_in[cur_round] = alpha;  //x of round.
							y_in[cur_round] = x_in[cur_round-1];  //y of round.
							beta_in[cur_round] = beta; //so,use beta_in[i] to store betai. // & 0xFFFFFF

							best = round_r_diff(search_round,cur_round+1);

	#if 1   //是否找到第一条最优路径就返回？
							if(best == 1)
								return 1;
	#endif
						}
					}
				}
			}
			break;
		case 64:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
				Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
				AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
				gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
			}

			for(i3=0;i3<gama_num[3];i3++)
			{
			gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
			for(i2=0;i2<gama_num[2];i2++)
			{
				gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
				for(i1=0;i1<gama_num[1];i1++)
				{
					gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
					for(i0=0;i0 < gama_num[0];i0++)
					{
						gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
						gama = (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

						/////////////// search every gama. And Jump to next round//////////////////////////
						if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
						{
							beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta.
							P_w[cur_round] = p_alpha;  // p or r round.
							x_in[cur_round] = alpha;  //x of round.
							y_in[cur_round] = x_in[cur_round-1];  //y of round.
							beta_in[cur_round] = beta; //so,use beta_in[i] to store betai.

							best = round_r_diff(search_round,cur_round+1);

#if 1   //是否找到第一条最优路径就返回？
							if(best == 1)
								return 1;
#endif
						}
					}
				}
			}
			}
			break;
		case 96:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
				Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
				AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
				gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
			}

			for(i5=0;i5<gama_num[5];i5++)
			{
			gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
			for(i4=0;i4<gama_num[4];i4++)
			{
			gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
			for(i3=0;i3<gama_num[3];i3++)
			{
			gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
			for(i2=0;i2<gama_num[2];i2++)
			{
				gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
				for(i1=0;i1<gama_num[1];i1++)
				{
					gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
					for(i0=0;i0 < gama_num[0];i0++)
					{
						gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
						gama = (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

						/////////////// search every gama. And Jump to next round//////////////////////////
						if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
						{
							beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta.
							P_w[cur_round] = p_alpha;  // p or r round.
							x_in[cur_round] = alpha;  //x of round.
							y_in[cur_round] = x_in[cur_round-1];  //y of round.
							beta_in[cur_round] = beta; //so,use beta_in[i] to store betai.

							best = round_r_diff(search_round,cur_round+1);

#if 1   //是否找到第一条最优路径就返回？
							if(best == 1)
								return 1;
#endif
						}
					}
				}
			}
			}
			}
			}
			break;
		case 128:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
				Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
				AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
				gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
			}

			for(i7=0;i7<gama_num[7];i7++)
			{
			gama_7 = DDTAB_8bit[AB_indx[7]][i7];  //gama_num 4-7 bits
			for(i6=0;i6<gama_num[6];i6++)
			{
			gama_6 = DDTAB_8bit[AB_indx[6]][i6];  //gam2a_num 4-7 bits
			for(i5=0;i5<gama_num[5];i5++)
			{
			gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
			for(i4=0;i4<gama_num[4];i4++)
			{
			gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
			for(i3=0;i3<gama_num[3];i3++)
			{
			gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
			for(i2=0;i2<gama_num[2];i2++)
			{
				gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
				for(i1=0;i1<gama_num[1];i1++)
				{
					gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
					for(i0=0;i0 < gama_num[0];i0++)
					{
						gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
						gama =(gama_7 << 56) | (gama_6 << 48) | (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;


						//gama =  (DDTAB_8bit[AB_indx[7]][i7] << 56) | (DDTAB_8bit[AB_indx[6]][i6] << 48) | \
								(DDTAB_8bit[AB_indx[5]][i5] << 40) | (DDTAB_8bit[AB_indx[4]][i4] << 32) | \
								(DDTAB_8bit[AB_indx[3]][i3] << 24) | (DDTAB_8bit[AB_indx[2]][i2] << 16) | \
								(DDTAB_8bit[AB_indx[1]][i1] <<8) | DDTAB_8bit[AB_indx[0]][i0];
						/////////////// search every gama. And Jump to next round//////////////////////////
						if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
						{
							beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta.
							P_w[cur_round] = p_alpha;  // p or r round.
							x_in[cur_round] = alpha;  //x of round.
							y_in[cur_round] = x_in[cur_round-1];  //y of round.
							beta_in[cur_round] = beta; //so,use beta_in[i] to store betai.

							best = round_r_diff(search_round,cur_round+1);

#if 1   //是否找到第一条最优路径就返回？
							if(best == 1)
								return 1;
#endif
						}
					}
				}
			}
			}
			}
			}
			}
			}
			break;
		default:
			break;
		}
		}
	}
	return best;
}

u16 round_r_Lineartrail(u16 search_round, u16 cur_round)
{
	u16 best = 0;
	u64 beta = 0;  //beta.
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16 P_beta = 0; // p with the output beat.
	u16 i=0,j=0,k=0,t=0;
	//u64 *U_base_tmp;  //
	u64 U_base_tmp[65] = {0};
	u64 U_alpha_base[65] = {0};
	u16 alpha_nmu=0;
	u64 U_alpha_tmp=0;

	if(search_round == cur_round)
	{
		best = round_N_Lineartrail(search_round);
		return best;
	}
	else
	{
		beta = x_in[cur_round-2] ^ beta_in[cur_round-1]   ;  //x of r round.
		P_beta = SIMON_SCorr_weight_check(beta, U_base_tmp); //,&U_base_num);
		for(i=1;i<cur_round;i++)
		{
			p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
		}

		if ((p_sumof_r + P_beta + n_P_bestofR_w[search_round - cur_round]) <= Bn_w)
		{
			P_w[cur_round] = P_beta;
			x_in[cur_round] = beta;

			//if( (beta == 0x2200) && ( Bn_w == 34 ) && (cur_round == 8))
			//	printf("test-R:: beta: %x  P_beta: %d \n",beta,P_beta);  // test.

			j=0;
			for(i=0;i< blocksize_len;i++)
			{
				if(U_base_tmp[i] != 0)
				{
					U_alpha_base[j] = U_base_tmp[i];
					j=j+1;
				}
			}
			alpha_nmu = pow(2,j) ;
			//printf("test-R1:: alpha_nmu: %d \n", alpha_nmu );
			for(k=0; k<alpha_nmu;k++)
			{
				U_alpha_tmp = 0;
				for(t=0;t<j;t++)
				{
					if( (k & (1<<t)) != 0 )
					{
						U_alpha_tmp ^= U_alpha_base[t];
					}
				}
				//printf("test-R2:: beta: %x  P_beta: %d  U_base_tmp[%d]: %x \n",beta,P_beta,i,U_alpha_tmp);  // test.
				beta_in[cur_round] = (RIGHT_rotation_64(U_alpha_tmp,rol_b,blocksize_len))
								^ (RIGHT_rotation_64(beta,rol_c,blocksize_len));

				//if((x_in[1] == 0x80) && (beta == 0x0800) &&  (Bn_w == 34 ) && (cur_round == 7)){
				//if((beta_in[cur_round] == 0x08a2) && ( Bn_w == 34 ) && (cur_round == 8))
				//	printf("test-R::beta:%x  U_alpha_tmp: %x \n",beta,U_alpha_tmp );  // test.
				//}

				best = round_r_Lineartrail(search_round,cur_round+1);// Call the next round.

#if 1   //是否找到第一条最优路径就返回？
					if(best==1)
	 					return best;
#endif
				}
			}
	}
	return best;
}

u16 round_r_LinearHull(u16 search_round, u16 cur_round)
{
	u16 best = 0;
	u64 beta = 0;  //beta.
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16 P_beta = 0; // p with the output beat.
	u16 i=0,j=0,k=0,t=0;
	//u64 *U_base_tmp;  //
	u64 U_base_tmp[65] = {0};
	u64 U_alpha_base[65] = {0};
	u16 alpha_nmu=0;
	u64 U_alpha_tmp=0;


	if(search_round == cur_round)
	{
		best = round_N_LinearHull(search_round);
		return best;
	}
	else
	{
		beta = x_in[cur_round-2] ^ beta_in[cur_round-1]   ;  //x of r round.
		P_beta = SIMON_SCorr_weight_check(beta, U_base_tmp); //,&U_base_num);
		for(i=1;i<cur_round;i++)
		{
			p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
		}

		if ((p_sumof_r + P_beta + n_P_bestofR_w[search_round - cur_round]) <= wt_max)
		{
			P_w[cur_round] = P_beta;
			x_in[cur_round] = beta;

			j=0;
			for(i=0;i< blocksize_len;i++)
			{
				if(U_base_tmp[i] != 0)
				{
					U_alpha_base[j] = U_base_tmp[i];
					j=j+1;
				}
			}
			alpha_nmu = pow(2,j) ;
			for(k=0; k<alpha_nmu;k++)
			{
				U_alpha_tmp = 0;
				for(t=0;t<j;t++)
				{
					if( (k & (1<<t)) != 0 )
					{
						U_alpha_tmp ^= U_alpha_base[t];
					}
				}

				beta_in[cur_round] = (RIGHT_rotation_64(U_alpha_tmp,rol_b,blocksize_len))
								^ (RIGHT_rotation_64(beta,rol_c,blocksize_len));

				best = round_r_LinearHull(search_round,cur_round+1);// Call the next round.
#if 1   //是否找到第一条最优路径就返回？
					if(best==1)
	 					return best;
#endif
			}
		}
	}
	return best;
}


/**
 * @Search for the min weight of DP of the r>2 Round of SIMON completely.
 * @
 */
u16 round_N(u16 search_round)
{
	u64 alpha = 0;  //x
	u64 beta = 0;  //beta.
	u64 gama = 0;  //gama.andout.
	u16 p_alpha = 0; // p with the input alpha.
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 Sa,Sb;
	u64 Sa_LSB8,Sb_LSB8;
	u16 best = 0;
	u64 AB_indx[16] = {0};  // Sa and Sb
	u16 gama_num[]={0};
	u64 gama_0 = 0,gama_1 = 0,gama_2 = 0,gama_3 = 0,gama_4 = 0,gama_5 = 0,gama_6 = 0,gama_7 = 0;
	u16 i=0,i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0,j=0,k=0;


	x_in[search_round] = x_in[search_round-2] ^ beta_in[search_round-1]   ;  //x of N round.
	alpha = x_in[search_round];
	p_alpha = SIMON_DP_weight_compute(alpha);

	for(i=1;i<search_round;i++)
	{
		p_sumof_r = p_sumof_r + P_w[i];  // p_sumof_r is the sum of r-1 rounds weight.
	}

	if ((p_sumof_r + p_alpha) == Bn_w)//compute and check validity.
	{
#if 0  //Do not find the output of the last round.
		for(i=1;i<search_round ;i++)
		{
			n_P_w[i] = P_w[i];
			n_x_in[i] = x_in[i];  //x of round N.
			n_y_in[i] = y_in[i];  //y of round N.
			n_beta_in[i] = beta_in[i]; //so,use beta_in[i] to store betai.
		}
		n_y_in[1] = n_x_in[2] ^ n_beta_in[1];  //y of round 1.
		n_P_w[search_round] = p_alpha;  // p or N round.
		n_x_in[search_round] = alpha;  //x of round N.
		n_y_in[search_round] = n_x_in[search_round-1];  //y of round N.
		n_beta_in[search_round] = beta; //so,use beta_in[i] to store betai.???????

		n_x_in[search_round+1] = n_y_in[search_round] ^ n_beta_in[search_round];  //x of round N+1.
		n_y_in[search_round+1] = n_x_in[search_round];  //y of round N+1.

		n_P_bestofR_w[search_round] = p_sumof_r + p_alpha; //Terminal  // Update the Expected n_P_bestofR_w.
		//Bn_w = n_P_bestofR_w[search_round];


		best=1;
		return 1;
#else  //Find the output of the last round.
		//////look up the DDTAB_4bit_init table to find the gama.//////
		Sa = ROTATE_LEFT(alpha,rol_a,blocksize_len);
		Sb = ROTATE_LEFT(alpha,rol_a,blocksize_len);

		switch(sc_blocksize)
		{
		case 32:
			//x0
			Sa_LSB8 = (Sa) & 0xFF; //8 bit
			Sb_LSB8 = (Sb) & 0xFF; //8 bit
			AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
			gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
			//x1
			Sa_LSB8 = Sa & 0xFF00; //8 bit
			Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
			AB_indx[1] = Sa_LSB8  | Sb_LSB8;
			gama_num[1] = DDTAB_8bit[AB_indx[1]][256];

			gama_cnt[sc_rounds] = gama_num[0] * gama_num[1];


			for(i1=0;i1 < gama_num[1];i1++)
			{
				gama_1 = (u16)DDTAB_8bit[AB_indx[1]][i1];  //memcpy(&gama_1,&DDTAB_8bit[AB_indx[1]][i1],1)
				for(i0=0;i0 < gama_num[0];i0++)
				{
					gama_0 = (u16)DDTAB_8bit[AB_indx[0]][i0]; //memcpy(&gama_0,&DDTAB_8bit[AB_indx[0]][i0],1);
					gama = (gama_1 << 8) | gama_0;  //gama = gama_1 * 256 + gama_0;

					/////////////// search every gama. And Jump to next round//////////////////////////
					if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
					{
						beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta2.

						n_P_w[1] = P_w[1];
						n_x_in[1] = x_in[1];  //x of round N.
						n_y_in[1] = x_in[2] ^ beta_in[1]; //y of round N.
						n_beta_in[1] = beta_in[1]; //so,use beta_in[i] to store betai.
						for(i=2;i<search_round ;i++)
						{
							n_P_w[i] = P_w[i];
							n_x_in[i] = x_in[i];  //x of round N.
							n_y_in[i] = y_in[i];  //y of round N.
							n_beta_in[i] = beta_in[i]; //so,use beta_in[i] to store betai.
						}
						n_P_w[search_round] = p_alpha;  // p or N round.
						n_x_in[search_round] = alpha;  //x of round N.
						n_y_in[search_round] = x_in[search_round-1];  //y of round N.
						n_beta_in[search_round] = beta; //so,use beta_in[i] to store betai.
						n_x_in[search_round+1] = n_y_in[search_round] ^ n_beta_in[search_round];  //x of round N+1.
						n_y_in[search_round+1] = n_x_in[search_round];  //y of round N+1.

						n_P_bestofR_w[search_round] = Bn_w; //Terminal  // Update the Expected n_P_bestofR_w.
						best = 1;
					}
				}
			}
			break;
		case 48:
			//x0
			Sa_LSB8 = (Sa) & 0xFF; //8 bit
			Sb_LSB8 = (Sb) & 0xFF; //8 bit
			AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
			gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
			//x1
			Sa_LSB8 = Sa & (0xFF << 8); //8 bit
			Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
			AB_indx[1] = Sa_LSB8  | Sb_LSB8;
			gama_num[1] = DDTAB_8bit[AB_indx[1]][256];
			//x2
			Sa_LSB8 = (Sa>>16) & 0x00FF; //8 bit
			Sb_LSB8 = (Sb>>16) & 0x00FF; //8 bit
			AB_indx[2] = ((Sa_LSB8 << 8) | Sb_LSB8);
			gama_num[2] = DDTAB_8bit[AB_indx[2]][256];

			for(i2=0;i2<gama_num[2];i2++)
			{
			gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
			for(i1=0;i1 < gama_num[1];i1++)
			{
				gama_1 = (u16)DDTAB_8bit[AB_indx[1]][i1];  //memcpy(&gama_1,&DDTAB_8bit[AB_indx[1]][i1],1)
				for(i0=0;i0 < gama_num[0];i0++)
				{
					gama_0 = (u16)DDTAB_8bit[AB_indx[0]][i0]; //memcpy(&gama_0,&DDTAB_8bit[AB_indx[0]][i0],1);
					gama = (gama_2 << 16) | (gama_1 <<8) | gama_0;
					/////////////// search every gama. And Jump to next round//////////////////////////
					if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
					{
						beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta2.

						n_P_w[1] = P_w[1];
						n_x_in[1] = x_in[1];  //x of round N.
						n_y_in[1] = x_in[2] ^ beta_in[1]; //y of round N.
						n_beta_in[1] = beta_in[1]; //so,use beta_in[i] to store betai.
						for(i=2;i<search_round ;i++)
						{
							n_P_w[i] = P_w[i];
							n_x_in[i] = x_in[i];  //x of round N.
							n_y_in[i] = y_in[i];  //y of round N.
							n_beta_in[i] = beta_in[i]; //so,use beta_in[i] to store betai.
						}
						n_P_w[search_round] = p_alpha;  // p or N round.
						n_x_in[search_round] = alpha;  //x of round N.
						n_y_in[search_round] = x_in[search_round-1];  //y of round N.
						n_beta_in[search_round] = beta; //so,use beta_in[i] to store betai.

						n_x_in[search_round+1] = n_y_in[search_round] ^ n_beta_in[search_round];  //x of round N+1.
						n_y_in[search_round+1] = n_x_in[search_round];  //y of round N+1.

						n_P_bestofR_w[search_round] = Bn_w; //Terminal  // Update the Expected n_P_bestofR_w.
						best = 1;
					}
				}
			}
			}
			break;
		case 64:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
				Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
				AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
				gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
			}

			for(i3=0;i3<gama_num[3];i3++)
			{
			gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
			for(i2=0;i2<gama_num[2];i2++)
			{
				gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
				for(i1=0;i1<gama_num[1];i1++)
				{
					gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
					for(i0=0;i0 < gama_num[0];i0++)
					{
						gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
						gama = (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

						/////////////// search every gama. And Jump to next round//////////////////////////
						if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
						{
							beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta2.

							n_P_w[1] = P_w[1];
							n_x_in[1] = x_in[1];  //x of round N.
							n_y_in[1] = x_in[2] ^ beta_in[1]; //y of round N.
							n_beta_in[1] = beta_in[1]; //so,use beta_in[i] to store betai.
							for(i=2;i<search_round ;i++)
							{
								n_P_w[i] = P_w[i];
								n_x_in[i] = x_in[i];  //x of round N.
								n_y_in[i] = y_in[i];  //y of round N.
								n_beta_in[i] = beta_in[i]; //so,use beta_in[i] to store betai.
							}
							n_P_w[search_round] = p_alpha;  // p or N round.
							n_x_in[search_round] = alpha;  //x of round N.
							n_y_in[search_round] = x_in[search_round-1];  //y of round N.
							n_beta_in[search_round] = beta; //so,use beta_in[i] to store betai.

							n_x_in[search_round+1] = n_y_in[search_round] ^ n_beta_in[search_round];  //x of round N+1.
							n_y_in[search_round+1] = n_x_in[search_round];  //y of round N+1.

							n_P_bestofR_w[search_round] = Bn_w; //Terminal  // Update the Expected n_P_bestofR_w.
							best = 1;
						}
					}
				}
			}
			}
			break;
		case 96:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
				Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
				AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
				gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
			}

			for(i5=0;i5<gama_num[5];i5++)
			{
			gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
			for(i4=0;i4<gama_num[4];i4++)
			{
			gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
			for(i3=0;i3<gama_num[3];i3++)
			{
			gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
			for(i2=0;i2<gama_num[2];i2++)
			{
				gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
				for(i1=0;i1<gama_num[1];i1++)
				{
					gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
					for(i0=0;i0 < gama_num[0];i0++)
					{
						gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
						gama = (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

						/////////////// search every gama. And Jump to next round//////////////////////////
						if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
						{
							beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta2.

							n_P_w[1] = P_w[1];
							n_x_in[1] = x_in[1];  //x of round N.
							n_y_in[1] = x_in[2] ^ beta_in[1]; //y of round N.
							n_beta_in[1] = beta_in[1]; //so,use beta_in[i] to store betai.
							for(i=2;i<search_round ;i++)
							{
								n_P_w[i] = P_w[i];
								n_x_in[i] = x_in[i];  //x of round N.
								n_y_in[i] = y_in[i];  //y of round N.
								n_beta_in[i] = beta_in[i]; //so,use beta_in[i] to store betai.
							}
							n_P_w[search_round] = p_alpha;  // p or N round.
							n_x_in[search_round] = alpha;  //x of round N.
							n_y_in[search_round] = x_in[search_round-1];  //y of round N.
							n_beta_in[search_round] = beta; //so,use beta_in[i] to store betai.

							n_x_in[search_round+1] = n_y_in[search_round] ^ n_beta_in[search_round];  //x of round N+1.
							n_y_in[search_round+1] = n_x_in[search_round];  //y of round N+1.

							n_P_bestofR_w[search_round] = Bn_w; //Terminal  // Update the Expected n_P_bestofR_w.
							best = 1;
						}
					}
				}
			}
			}
			}
			}

			break;
		case 128:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
				Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
				AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
				gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
			}

			for(i7=0;i7<gama_num[7];i7++)
			{
			gama_7 = DDTAB_8bit[AB_indx[7]][i7];  //gama_num 4-7 bits
			for(i6=0;i6<gama_num[6];i6++)
			{
			gama_6 = DDTAB_8bit[AB_indx[6]][i6];  //gam2a_num 4-7 bits
			for(i5=0;i5<gama_num[5];i5++)
			{
			gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
			for(i4=0;i4<gama_num[4];i4++)
			{
			gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
			for(i3=0;i3<gama_num[3];i3++)
			{
			gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
			for(i2=0;i2<gama_num[2];i2++)
			{
				gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
				for(i1=0;i1<gama_num[1];i1++)
				{
					gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
					for(i0=0;i0 < gama_num[0];i0++)
					{
						gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
						gama =(gama_7 << 56) | (gama_6 << 48) | (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

						/////////////// search every gama. And Jump to next round//////////////////////////
						if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
						{
							beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta2.

							n_P_w[1] = P_w[1];
							n_x_in[1] = x_in[1];  //x of round N.
							n_y_in[1] = x_in[2] ^ beta_in[1]; //y of round N.
							n_beta_in[1] = beta_in[1]; //so,use beta_in[i] to store betai.
							for(i=2;i<search_round ;i++)
							{
								n_P_w[i] = P_w[i];
								n_x_in[i] = x_in[i];  //x of round N.
								n_y_in[i] = y_in[i];  //y of round N.
								n_beta_in[i] = beta_in[i]; //so,use beta_in[i] to store betai.
							}
							n_P_w[search_round] = p_alpha;  // p or N round.
							n_x_in[search_round] = alpha;  //x of round N.
							n_y_in[search_round] = x_in[search_round-1];  //y of round N.
							n_beta_in[search_round] = beta; //so,use beta_in[i] to store betai.

							n_x_in[search_round+1] = n_y_in[search_round] ^ n_beta_in[search_round];  //x of round N+1.
							n_y_in[search_round+1] = n_x_in[search_round];  //y of round N+1.

							n_P_bestofR_w[search_round] = Bn_w; //Terminal  // Update the Expected n_P_bestofR_w.
							best = 1;
						}
					}
				}
			}
			}
			}
			}
			}
			}
			break;
		default:
			break;
		}
#endif
	}
	return best;
}
/**
 * @Search for the min weight of DP of the r>2 Round of SIMON completely.
 * @
 */
u16 round_N_diff(u16 search_round)
{
	u64 alpha = 0;  //x
	u64 beta = 0;  //beta.
	u64 gama = 0;  //gama.andout.
	u16 p_alpha = 0; // p with the input alpha.
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 Sa,Sb;
	u64 Sa_LSB8,Sb_LSB8;
	u16 best = 0;
	u64 AB_indx[16] = {0};  // Sa and Sb
	u16 gama_num[]={0};
	u64 gama_0 = 0,gama_1 = 0,gama_2 = 0,gama_3 = 0,gama_4 = 0,gama_5 = 0,gama_6 = 0,gama_7 = 0;
	u16 i=0,i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0,j=0;
	u64 output_left = 0;

	alpha = x_in[search_round-2] ^ beta_in[search_round-1]   ;  //x of N round.
	//printf("---------------alpha: %x------------------\n",alpha);

	if (alpha == output_diff_R)  //Last round output right part is the input left part of last-1 round.
	{
		//////look up the DDTAB_4bit_init table to find the gama.///////
		Sa = ROTATE_LEFT(alpha,rol_a,blocksize_len);
		Sb = ROTATE_LEFT(alpha,rol_b,blocksize_len);

		//printf("count: %d    weight: %d \n",count,p_sumof_r + p_alpha);
		switch(sc_blocksize)
			{
			case 32:
				//x0
				Sa_LSB8 = (Sa) & 0xFF; //8 bit
				Sb_LSB8 = (Sb) & 0xFF; //8 bit
				AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
				gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
				//x1
				Sa_LSB8 = Sa & 0xFF00; //8 bit
				Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
				AB_indx[1] = Sa_LSB8  | Sb_LSB8;
				gama_num[1] = DDTAB_8bit[AB_indx[1]][256];

				for(i1=0;i1 < gama_num[1];i1++)
				{
					gama_1 = (u16)DDTAB_8bit[AB_indx[1]][i1];  //memcpy(&gama_1,&DDTAB_8bit[AB_indx[1]][i1],1)
					for(i0=0;i0 < gama_num[0];i0++)
					{
						gama_0 = (u16)DDTAB_8bit[AB_indx[0]][i0]; //memcpy(&gama_0,&DDTAB_8bit[AB_indx[0]][i0],1);
						gama = (gama_1 << 8) | gama_0;  //gama = gama_1 * 256 + gama_0;
						/////////////// search every gama. And Jump to next round//////////////////////////
						if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
						{
							beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta2.

							output_left = (beta & 0xFFFF) ^ x_in[search_round-1];
							//printf("---------------output_left: %x------------------\n",output_left);
							if(output_left == output_diff_L)
							{
								count++;
								p_alpha = SIMON_DP_weight_compute(alpha);
								for(i=1;i<search_round;i++)
								{
									p_sumof_r = p_sumof_r + P_w[i];  // p_sumof_r is the sum of r-1 rounds weight.
								}
								Bn_w = p_sumof_r + p_alpha;
								printf("count: %d    weight: %d \n",count,p_sumof_r + p_alpha);
								wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
								//prob = prob + pow(2,-Bn_w);

								//通过参数trail_number和wt_max两个参数来选择:
								//-若trail_number=0,则穷搜小于wt_max的所有路径,直到搜完为止
								//-若trail_number不等于0,则搜小于wt_max且小于trail_num的路径
								// --当搜索的路径大于trail_num时结束,或者搜完了小于wt_max的路径数量仍然小于trail_num也结束.
								if((trail_nmu > 0) && (count >= trail_nmu))
								{								//通过参数trail_number和wt_max两个参数来选择:
									//-若trail_number=0,则穷搜小于wt_max的所有路径,直到搜完为止
									//-若trail_number不等于0,则搜小于wt_max且小于trail_num的路径
									// --当搜索的路径大于trail_num时结束,或者搜完了小于wt_max的路径数量仍然小于trail_num也结束.
									best = 1;
								}
							}
							else
							{
								best = 0;
							}
						}
					}
				}
				break;
			case 48:
				//x0
				Sa_LSB8 = (Sa) & 0xFF; //8 bit
				Sb_LSB8 = (Sb) & 0xFF; //8 bit
				AB_indx[0] = (Sa_LSB8 << 8) | Sb_LSB8;
				gama_num[0] = DDTAB_8bit[AB_indx[0]][256];
				//x1
				Sa_LSB8 = Sa & (0xFF << 8); //8 bit
				Sb_LSB8 = ( Sb >> 8) & 0xFF; //8 bit
				AB_indx[1] = Sa_LSB8  | Sb_LSB8;
				gama_num[1] = DDTAB_8bit[AB_indx[1]][256];
				//x2
				Sa_LSB8 = (Sa>>16) & 0x00FF; //8 bit
				Sb_LSB8 = (Sb>>16) & 0x00FF; //8 bit
				AB_indx[2] = ((Sa_LSB8 << 8) | Sb_LSB8);
				gama_num[2] = DDTAB_8bit[AB_indx[2]][256];

				for(i2=0;i2<gama_num[2];i2++)
				{
				gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
				for(i1=0;i1 < gama_num[1];i1++)
				{
					gama_1 = (u16)DDTAB_8bit[AB_indx[1]][i1];  //memcpy(&gama_1,&DDTAB_8bit[AB_indx[1]][i1],1)
					for(i0=0;i0 < gama_num[0];i0++)
					{
						gama_0 = (u16)DDTAB_8bit[AB_indx[0]][i0]; //memcpy(&gama_0,&DDTAB_8bit[AB_indx[0]][i0],1);
						gama = (gama_2 << 16) | (gama_1 <<8) | gama_0;
						/////////////// search every gama. And Jump to next round//////////////////////////
						if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
						{
							beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta2.

							output_left = beta ^ x_in[search_round-1];
							if(output_left == output_diff_L)
							{
								count++;
								p_alpha = SIMON_DP_weight_compute(alpha);
								for(i=1;i<search_round;i++)
								{
									p_sumof_r = p_sumof_r + P_w[i];  // p_sumof_r is the sum of r-1 rounds weight.
								}
								Bn_w = p_sumof_r + p_alpha;
								printf("count: %d    weight: %d \n",count,p_sumof_r + p_alpha);
								wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
								//prob = prob + pow(2,-Bn_w);

								//通过参数trail_number和wt_max两个参数来选择:
								//-若trail_number=0,则穷搜小于wt_max的所有路径,直到搜完为止
								//-若trail_number不等于0,则搜小于wt_max且小于trail_num的路径
								// --当搜索的路径大于trail_num时结束,或者搜完了小于wt_max的路径数量仍然小于trail_num也结束.
								if((trail_nmu > 0) && (count >= trail_nmu))
								{								//通过参数trail_number和wt_max两个参数来选择:
									//-若trail_number=0,则穷搜小于wt_max的所有路径,直到搜完为止
									//-若trail_number不等于0,则搜小于wt_max且小于trail_num的路径
									// --当搜索的路径大于trail_num时结束,或者搜完了小于wt_max的路径数量仍然小于trail_num也结束.
									best = 1;
								}
							}
							else
							{
								best = 0;
							}
						}
					}
				}
				}
				break;
			case 64:
				for(j=0;j<nBytes;j++)  //nBytes
				{
					Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
					Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
					AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
					gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
				}

				for(i3=0;i3<gama_num[3];i3++)
				{
				gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
				for(i2=0;i2<gama_num[2];i2++)
				{
					gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
					for(i1=0;i1<gama_num[1];i1++)
					{
						gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
						for(i0=0;i0 < gama_num[0];i0++)
						{
							gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
							gama = (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

							/////////////// search every gama. And Jump to next round//////////////////////////
							if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
							{
								beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta2.

								output_left = beta ^ x_in[search_round-1];
								if(output_left == output_diff_L)
								{
									count++;
									p_alpha = SIMON_DP_weight_compute(alpha);
									for(i=1;i<search_round;i++)
									{
										p_sumof_r = p_sumof_r + P_w[i];  // p_sumof_r is the sum of r-1 rounds weight.
									}
									Bn_w = p_sumof_r + p_alpha;
									printf("count: %d    weight: %d \n",count,p_sumof_r + p_alpha);
									wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
									//prob = prob + pow(2,-Bn_w);

									//通过参数trail_number和wt_max两个参数来选择:
									//-若trail_number=0,则穷搜小于wt_max的所有路径,直到搜完为止
									//-若trail_number不等于0,则搜小于wt_max且小于trail_num的路径
									// --当搜索的路径大于trail_num时结束,或者搜完了小于wt_max的路径数量仍然小于trail_num也结束.
									if((trail_nmu > 0) && (count >= trail_nmu))
									{								//通过参数trail_number和wt_max两个参数来选择:
										//-若trail_number=0,则穷搜小于wt_max的所有路径,直到搜完为止
										//-若trail_number不等于0,则搜小于wt_max且小于trail_num的路径
										// --当搜索的路径大于trail_num时结束,或者搜完了小于wt_max的路径数量仍然小于trail_num也结束.
										best = 1;
									}
								}
								else
								{
									best = 0;
								}
							}
						}
					}
				}
				}
				break;
			case 96:
				for(j=0;j<nBytes;j++)  //nBytes
				{
					Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
					Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
					AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
					gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
				}

				for(i5=0;i5<gama_num[5];i5++)
				{
				gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
				for(i4=0;i4<gama_num[4];i4++)
				{
				gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
				for(i3=0;i3<gama_num[3];i3++)
				{
				gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
				for(i2=0;i2<gama_num[2];i2++)
				{
					gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
					for(i1=0;i1<gama_num[1];i1++)
					{
						gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
						for(i0=0;i0 < gama_num[0];i0++)
						{
							gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
							gama = (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

							/////////////// search every gama. And Jump to next round//////////////////////////
							if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
							{
								beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta2.

								output_left = beta ^ x_in[search_round-1];
								if(output_left == output_diff_L)
								{
									count++;
									p_alpha = SIMON_DP_weight_compute(alpha);
									for(i=1;i<search_round;i++)
									{
										p_sumof_r = p_sumof_r + P_w[i];  // p_sumof_r is the sum of r-1 rounds weight.
									}
									Bn_w = p_sumof_r + p_alpha;
									printf("count: %d    weight: %d \n",count,p_sumof_r + p_alpha);
									wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
									//prob = prob + pow(2,-Bn_w);

									//通过参数trail_number和wt_max两个参数来选择:
									//-若trail_number=0,则穷搜小于wt_max的所有路径,直到搜完为止
									//-若trail_number不等于0,则搜小于wt_max且小于trail_num的路径
									// --当搜索的路径大于trail_num时结束,或者搜完了小于wt_max的路径数量仍然小于trail_num也结束.
									if((trail_nmu > 0) && (count >= trail_nmu))
									{								//通过参数trail_number和wt_max两个参数来选择:
										//-若trail_number=0,则穷搜小于wt_max的所有路径,直到搜完为止
										//-若trail_number不等于0,则搜小于wt_max且小于trail_num的路径
										// --当搜索的路径大于trail_num时结束,或者搜完了小于wt_max的路径数量仍然小于trail_num也结束.
										best = 1;
									}
								}
								else
								{
									best = 0;
								}
							}
						}
					}
				}
				}
				}
				}

				break;
			case 128:
				for(j=0;j<nBytes;j++)  //nBytes
				{
					Sa_LSB8 = (Sa>>(8*j)) & 0x00FF; //8 bit
					Sb_LSB8 = (Sb>>(8*j)) & 0x00FF; //8 bit
					AB_indx[j] = ((Sa_LSB8 << 8) | Sb_LSB8);
					gama_num[j] = DDTAB_8bit[AB_indx[j]][256];
				}

				for(i7=0;i7<gama_num[7];i7++)
				{
				gama_7 = DDTAB_8bit[AB_indx[7]][i7];  //gama_num 4-7 bits
				for(i6=0;i6<gama_num[6];i6++)
				{
				gama_6 = DDTAB_8bit[AB_indx[6]][i6];  //gam2a_num 4-7 bits
				for(i5=0;i5<gama_num[5];i5++)
				{
				gama_5 = DDTAB_8bit[AB_indx[5]][i5];  //gama_num 4-7 bits
				for(i4=0;i4<gama_num[4];i4++)
				{
				gama_4 = DDTAB_8bit[AB_indx[4]][i4];  //gam2a_num 4-7 bits
				for(i3=0;i3<gama_num[3];i3++)
				{
				gama_3 = DDTAB_8bit[AB_indx[3]][i3];  //gama_num 4-7 bits
				for(i2=0;i2<gama_num[2];i2++)
				{
					gama_2 = DDTAB_8bit[AB_indx[2]][i2];  //gama_num 4-7 bits
					for(i1=0;i1<gama_num[1];i1++)
					{
						gama_1 = DDTAB_8bit[AB_indx[1]][i1];  //gama_num 4-7 bits
						for(i0=0;i0 < gama_num[0];i0++)
						{
							gama_0 = DDTAB_8bit[AB_indx[0]][i0];  //gama_num 0-3 bitssearch_round
							gama =(gama_7 << 56) | (gama_6 << 48) | (gama_5 << 40) | (gama_4 << 32) | (gama_3 << 24) | (gama_2 << 16) | (gama_1 <<8) | gama_0;

							printf("Gama: %d \n",gama_num[0]*gama_num[1]*gama_num[2]*gama_num[3]*gama_num[4]*gama_num[5]*gama_num[6]*gama_num[7]);

							/////////////// search every gama. And Jump to next round//////////////////////////
							if(SIMON_DP_weight_check(alpha,gama) == 1) //valid gama.
							{
								beta = gama ^ ROTATE_LEFT(alpha,rol_c,blocksize_len); //beta2.

								output_left = beta ^ x_in[search_round-1];
								if(output_left == output_diff_L)
								{
									count++;
									p_alpha = SIMON_DP_weight_compute(alpha);
									for(i=1;i<search_round;i++)
									{
										p_sumof_r = p_sumof_r + P_w[i];  // p_sumof_r is the sum of r-1 rounds weight.
									}
									Bn_w = p_sumof_r + p_alpha;
									printf("count: %d    weight: %d \n",count,p_sumof_r + p_alpha);
									wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
									//prob = prob + pow(2,-Bn_w);

									//通过参数trail_number和wt_max两个参数来选择:
									//-若trail_number=0,则穷搜小于wt_max的所有路径,直到搜完为止
									//-若trail_number不等于0,则搜小于wt_max且小于trail_num的路径
									// --当搜索的路径大于trail_num时结束,或者搜完了小于wt_max的路径数量仍然小于trail_num也结束.
									if((trail_nmu > 0) && (count >= trail_nmu))
									{
										best = 1;
									}
								}
								else
								{
									best = 0;
								}
							}
						}
					}
				}
				}
				}
				}
				}
				}
				break;
			default:
				break;
			}
	}
	return best;
}

u16 round_N_Lineartrail(u16 search_round)
{
	u16 best = 0;
	u64 beta = 0;  //beta.
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16 P_beta = 0; // p with the output beat.
	u16 i=0,j=0,k=0,t=0;
	u64 U_base_tmp[65] = {0};
	//u64 *U_base_tmp;  //
	u64 U_alpha_base[65] = {0};
	u16 alpha_nmu=0;
	u64 U_alpha_tmp=0;


	beta = x_in[search_round-2] ^ beta_in[search_round-1]   ;  //x of N round.
	P_beta = SIMON_SCorr_weight_check(beta, U_base_tmp); //,&U_base_num);
	//if ((x_in[1] == 0x80) && (x_in[2] == 0))
	//printf("test-N:: beta: %x  P_beta: %d \n",beta,P_beta);  // test.

	for(i=1;i<search_round;i++)
	{
		p_sumof_r = p_sumof_r + P_w[i];  // p_sumof_r is the sum of r-1 rounds weight.
	}

	if ((p_sumof_r + P_beta) == Bn_w)//compute and check validity.
	{
		P_w[search_round] = P_beta;  //
		x_in[search_round] = beta;

		j=0;
		for(i=0;i<blocksize_len;i++)
		{
			if(U_base_tmp[i] != 0)
			{
				U_alpha_base[j] = U_base_tmp[i];
				j=j+1;
			}
		}
		alpha_nmu = pow(2,j) ;
		//printf("test-N1:: alpha_nmu: %d \n", alpha_nmu );
		for(k=0; k<alpha_nmu;k++)
		{
			U_alpha_tmp = 0;
			for(t=0;t<j;t++)
			{
				if( (k & (1<<t)) != 0 )
				{
					U_alpha_tmp ^= U_alpha_base[t];
				}
			}
			//printf("test-N2:: beta: %x  P_beta: %d  U_alpha_tmp: %x \n",beta,P_beta,U_alpha_tmp);  // test.

			beta_in[search_round] = (RIGHT_rotation_64(U_alpha_tmp,rol_b,blocksize_len))
							^ (RIGHT_rotation_64(beta,rol_c,blocksize_len));

			x_in[0] = x_in[2] ^ beta_in[1];  //alpha
			n_x_in[1] = x_in[0];  //x of round N.
			//n_y_in[1] = x_in[1];
			for(i=1;i<=search_round ;i++)
			{
				n_P_w[i] = P_w[i];
				n_y_in[i] = x_in[i];  //y of round N.
				n_x_in[i+1] = x_in[i];  //x of round N.
				n_beta_in[i] = beta_in[i];  //so,use beta_in[i] to store betai.
			}
			n_y_in[search_round+1] = x_in[search_round-1] ^ n_beta_in[search_round];

			n_P_bestofR_w[search_round] = Bn_w; //Terminal  // Update the Expected n_P_bestofR_w.


			if(flag_stop == 0)
			{
				flag_stop +=1;
			best = 0;
			return best;
			}
			else
			{
				best = 1;
				return best;
			}


		}
	}
	return best;
}

u16 round_N_LinearHull(u16 search_round)
{
	u16 best = 0;
	u64 beta = 0;  //beta.
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16 P_beta = 0; // p with the output beat.
	u16 i=0,j=0,k=0,t=0;
	u64 U_base_tmp[65] = {0};
	//u64 *U_base_tmp;  //
	u64 U_alpha_base[65] = {0};
	u16 alpha_nmu=0;
	u64 U_alpha_tmp=0;
	u64 output_right = 0;


	beta = x_in[search_round-2] ^ beta_in[search_round-1]   ;  //x of N round.
	if (beta == output_mask_L)  //Last round output check.
	{
		P_beta = SIMON_SCorr_weight_check(beta, U_base_tmp); //,&U_base_num);

		P_w[search_round] = P_beta;  //
		x_in[search_round] = beta;
		//printf("output_mask_L:: %x \n", beta );

		j=0;
		for(i=0;i<blocksize_len;i++)
		{
			if(U_base_tmp[i] != 0)
			{
				U_alpha_base[j] = U_base_tmp[i];
				j=j+1;
			}
		}
		alpha_nmu = pow(2,j) ;
		for(k=0; k<alpha_nmu;k++)
		{
			U_alpha_tmp = 0;
			for(t=0;t<j;t++)
			{
				if( (k & (1<<t)) != 0 )
				{
					U_alpha_tmp ^= U_alpha_base[t];
				}
			}

			beta_in[search_round] = (RIGHT_rotation_64(U_alpha_tmp,rol_b,blocksize_len))
							^ (RIGHT_rotation_64(beta,rol_c,blocksize_len));
			output_right = x_in[search_round-1] ^ beta_in[search_round];
			//printf("output_mask_R:%x  output_right:: %x \n",output_mask_R, output_right );

			if(output_right == output_mask_R)
			{
				count++;

				for(i=1;i<search_round;i++)
				{
					p_sumof_r = p_sumof_r + P_w[i];  // p_sumof_r is the sum of r-1 rounds weight.
				}
				Bn_w = p_sumof_r + P_beta;

				printf("count: %d    weight: %d \n",count,Bn_w);
				wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
				//prob = prob + pow(2,-Bn_w);

			}
			else
			{
				return 0;
			}
		}

	}

return best;
}

u16 sepck_round_1(u16 search_round  )
{
	u16 best = 0;
	u16 thr_d = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;


	u64 M0 = 0;
	u64 N0 = blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;
	u16 j_abc = 0;


///////////////////round 1 entry/////////////////////
	if( search_round == 1)
	{
		best = round_1_j(1);
		return best;
	}
	else
	{	// 可以选择是否限定第1轮的概率重量
		for(thr_d = 0; thr_d < blocksize_len-1 ;thr_d++)  //0::n-1 //blocksize_len-1
		{
			// thr_d : the bits number of alpha/beta/gamma that the position not equal at the same time.
			if ((thr_d + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
			{
				return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
			}

			M0 = thr_d;  //三个alpha,beta和gamma同时考虑
			P_w[1] = M0;  //pro; //Speck_XDP_compute(Input_Alpha,Input_Beta,Input_Gamma );
			p_sumof_r_P_w[1] = P_w[1];
			if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
			{
				for(j_abc = 1; j_abc < 4;j_abc++)
				{
					if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
					{
						Input_alpha = V_MSB;
					}
					else
					{
						Input_alpha = 0;  // & Bit_Align;
					}

					if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
					{
						Input_beta = V_MSB;
					}
					else
					{
						Input_beta = 0; // & Bit_Align;
					}

					if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
					{
						Input_gamma = V_MSB;
					}
					else
					{
						Input_gamma = 0;  // & Bit_Align;
					}

					best = sepck_round_r(search_round, 2,Input_gamma,Input_gamma ^ (ROTATE_LEFT(Input_beta, rol_b,blocksize_len) & Bit_Align));
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			n_x_in[1] = (ROTATE_LEFT(Input_alpha, rol_a,blocksize_len)) & Bit_Align; // left part of Input of the first round.
			n_y_in[1] = Input_beta;  // right part of Input of the first round.

			n_x_in[2 ] = Input_gamma;  // left part output of fisrt round.
			n_y_in[2 ] = Input_gamma ^ (ROTATE_LEFT(Input_beta, rol_b,blocksize_len) & Bit_Align);
			return 1;
		}
#endif
					}
				}
				else  //M0 > 0.
				{
					for ( i=0; i<=(N0-M0); i++) A0[i] = 0;
					for ( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
					for ( i = 1; i<=M0; i++) { C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
					T0[N0-M0] = -1;
					T0[1] = 0;
					F0[N0] = N0 - M0 + 1;
					I0 = N0 - M0; L0 = N0;

/*
					if(Bn_w == 5 ){
				//第一种模式输出 //These bits position are SET. LSB-->MSB.
					for( i=1; i<=M0; i++)
					{
						printf("%d\t",C0[i]);
					}
				printf("\n");
					}
*/
					best = sepck_input_MSB(search_round,Input_alpha, Input_beta, Input_gamma,thr_d,C0);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		return 1;
	}
#endif

////////////////////
				do
				{
					if (I0 == 0)
					{
						break;
					}
					else
					{
						if (T0[I0] < 0)
						{
							if ((-T0[I0]) != (I0-1))
							{
								T0[I0-1] = T0[I0];
							}
							T0[I0] = I0-1;
						}
						if ( A0[I0]==0 )
						{
							X0 = I0;
							Y0 = F0[L0];
							if (A0[I0-1] == 1)
							{
								F0[I0] = F0[I0 - 1];
							}
							else
							{
								F0[I0] = I0;
							}
							if (F0[L0] == L0)
							{
								L0 = I0; I0 = T0[I0];
								goto CHANGE1;
							}
							if (L0 == N0)
							{
								T0[F0[N0]] = -I0 - 1;
								T0[I0 + 1] = T0[I0];
								I0 = F0[N0];
								F0[N0] = F0[N0] + 1;
								goto CHANGE1;
							}
							T0				[L0] = -I0-1;
							T0[I0+1] = T0[I0];
							F0[L0] = F0[L0] + 1;
							I0 = L0;
							goto CHANGE1;
						}
						Y0 = I0;
						if (I0 != L0)
						{
							F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
							if (L0 == N0)
							{
								if (I0 == (F0[N0] - 1))
								{
									I0 = T0[I0];
									goto CHANGE1;
								}
								T0[F0[N0]-1] = -I0-1;
								T0[I0+1] = T0[I0];
								I0 = F0[N0] - 1;
								goto CHANGE1;
							}
							T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0; goto CHANGE1;
						}
						X0 = N0;
						F0[L0 - 1] = F0[L0];
						F0[N0] = N0;
						L0 = N0;
						if (I0 == N0 - 1)
						{
							I0 = T0[N0 - 1];
							goto CHANGE1;
						}
						T0[N0 - 1] = -I0 - 1;
						T0[I0 + 1] = T0[I0];
						I0 = N0 - 1;
			CHANGE1:
					A0[X0] = 1;
					A0[Y0] = 0;
					H0[X0] = Z0 = H0[Y0];
					C0[Z0] = X0;
					}

/////////////////////////////////
			best = sepck_input_MSB(search_round,Input_alpha, Input_beta, Input_gamma,thr_d,C0);

#if 1   //是否找到第一条最优路径就返回？
			if(best == 1 )
			{
				return 1;
			}
#endif
///////////////////////////////////////
					} while(1);
				}
		}
	}
	return best;
}

u16 sepck_round_1_diff(u16 search_round  )
{
	u16 best = 0;
	u64 Alpha = 0;  //alpha
	u64 Beta = 0;  //beta.
	u64 input_left = 0;  //x
	u64 input_right = 0;  //y
	u64 xor_alpha_beta = 0;
	u16 w_xor = 0;
	u16 w_cmp = 0;
	u64 carry_tmp[8] ={0};
	u64 alpha_bloc[8] = {0};
	u64 beta_bloc[8] = {0};
	u64 gamma_bloc[8] = {0};
	u64 AB_block[8] = {0};
	u64 carry[8] ={0};
	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 gamma_temp = 0;


	if( search_round == 1)
	{
		return 1;
	}

	input_left = input_diff_L;
	input_right = input_diff_R;
	Alpha = (ROTATE_RIGHT(input_left,rol_a, blocksize_len)) & Bit_Align; //
	Beta = input_right & Bit_Align; // ^ ROTATE_LEFT(input_right,rol_b,blocksize_len) )& Bit_Align;
	xor_alpha_beta = Beta ^ Alpha ;
	w_xor = HM_weight(xor_alpha_beta & ValueMax_Align);

	w_cmp = wt_max - n_P_bestofR_w[search_round - 1];
	if ( w_xor > w_cmp)
	{
		return 0;
	}


	switch(sc_blocksize)
	{
	case 32:
		//m0
		alpha_bloc[0] = (Alpha) & 0xFF; //8 bit
		beta_bloc[0]  = (Beta) & 0xFF; //8 bit
		AB_block[0] = (alpha_bloc[0] << 8) | beta_bloc[0];
		carry[0] = 0;
		//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
		//m1
		alpha_bloc[1]= (Alpha >> 8) & 0xFF; //8 bit
		beta_bloc[1] = ( Beta >> 8) & 0xFF; //8 bit
		AB_block[1] = (alpha_bloc[1] << 8) | beta_bloc[1];

//#pragma omp parallel for
		for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
		{
			//if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
		{
			gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
			carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
					+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
					+ (gamma_bloc[0] >> 7); // gamma MSB
		for(i1 = 0; i1 <= MSB_cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < MSB_cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
		{
			gamma_bloc[1] = MSB_cDDT_v[carry[1]][AB_block[1]][i1][j1];
			gamma_temp = (gamma_bloc[1] <<8) | gamma_bloc[0];

			P_w[1] = i0 + i1;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
			best = sepck_round_r_diff(search_round,2,gamma_temp,Beta);

#if 0   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[1] = input_left;  // output part of the r-th round..
			n_y_in[1] = input_right;
			n_x_in[2] = gamma_temp;  // output part of the r-th round..
			n_y_in[2] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
			return 1;
		}
#endif
		}
		}
		}
		}
		break;
	case 48:
		for(j=0;j<nBytes;j++)  //nBytes
		{
			alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
			beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
			AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
		}
		carry[0] = 0;
		for(j=1;j<nBytes;j++)  //nBytes
		{
			carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
				+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
		}

		for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
		{
			if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
		{
			gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
			//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
			carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB

		for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
		{
			gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
			//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
			carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

		for(i2 = 0; i2 <= MSB_cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
		{
			if(i0 + i1 +i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2=0; j2 < MSB_cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
		{
			gamma_bloc[2] = MSB_cDDT_v[carry[2]][AB_block[2]][i2][j2];
			gamma_temp = (gamma_bloc[2] << 16) | (gamma_bloc[1] <<8) | gamma_bloc[0];

			P_w[1] = i0 + i1 +i2;   // Speck_XDP_compute(Alpha, Beta, gamma_temp);
			best = sepck_round_r_diff(search_round,2,gamma_temp,Beta);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[1] = input_left;  // output part of the r-th round..
			n_y_in[1] = input_right;
			n_x_in[2] = gamma_temp;  // output part of the r-th round..
			n_y_in[2] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
			return 1;
		}
#endif
		}
		}
		}
		}
		}
		}
		break;
	case 64:
		for(j=0;j<nBytes;j++)  //nBytes
		{
			alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
			beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
			AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
		}
		carry[0] = 0;
		for(j=1;j<nBytes;j++)  //nBytes
		{
			carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
				+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
		}

		for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
		{
			if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
		{
			gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
			//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
			carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB

		for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
		{
			gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
			//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
			carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

		for(i2 = 0; i2 <= cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
		{
			if(i0 + i1 +i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
		{
			gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
			//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
			carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB

		for(i3 = 0; i3 <= MSB_cDDT_wt_max[carry[3]][AB_block[3]]; i3++)
		{
			if(i0 + i1 +i2 +i3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < MSB_cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
		{
			gamma_bloc[3] = MSB_cDDT_v[carry[3]][AB_block[3]][i3][j3];
			gamma_temp = (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
					   | (gamma_bloc[1] <<8) | gamma_bloc[0];

			P_w[1] = i0 + i1 +i2 +i3;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
			best = sepck_round_r_diff(search_round,2,gamma_temp,Beta);
#if 0   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[1] = input_left;  // output part of the r-th round..
			n_y_in[1] = input_right;
			n_x_in[2] = gamma_temp;  // output part of the r-th round..
			n_y_in[2] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
			return 1;
		}
#endif
		}
		}
		}
		}
		}
		}
		}
		}
		break;
	case 96:
		for(j=0;j<nBytes;j++)  //nBytes
		{
			alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
			beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
			AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
		}
		carry[0] = 0;
		for(j=1;j<nBytes;j++)  //nBytes
		{
			carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
				+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
		}

		for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
		{
			if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
		{
			gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
			//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
			carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB
		for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
		{
			gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
			//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
			carry[2] = carry_tmp[2]	+ (gamma_bloc[1] >> 7); // gamma MSB
		for(i2 = 0; i2 <= cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
		{
			if(i0 + i1 +i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
		{
			gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
			//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
			carry[3] = carry_tmp[3]	+ (gamma_bloc[2] >> 7); // gamma MSB
		for(i3 = 0; i3 <= cDDT_wt_max[carry[3]][AB_block[3]]; i3++)
		{
			if(i0 + i1 +i2 +i3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
		{
			gamma_bloc[3] = cDDT_v[carry[3]][AB_block[3]][i3][j3];
			//carry[4] = ((alpha_bloc[3] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[3] >> 7) << 1)   //beta MSB
			carry[4] = carry_tmp[4]	+ (gamma_bloc[3] >> 7); // gamma MSB
		for(i4 = 0; i4 <= cDDT_wt_max[carry[4]][AB_block[4]]; i4++)
		{
			if(i0 + i1 +i2 +i3 +i4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j4=0; j4 < cDDT_n[carry[4]][AB_block[4]][i4]; j4++)
		{
			gamma_bloc[4] = cDDT_v[carry[4]][AB_block[4]][i4][j4];
			//carry[5] = ((alpha_bloc[4] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[4] >> 7) << 1)   //beta MSB
			carry[5] = carry_tmp[5]	+ (gamma_bloc[4] >> 7); // gamma MSB
		for(i5 = 0; i5 <= MSB_cDDT_wt_max[carry[5]][AB_block[5]]; i5++)
		{
			if(i0 + i1 +i2 +i3 +i4 +i5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j5=0; j5 < MSB_cDDT_n[carry[5]][AB_block[5]][i5]; j5++)
		{
			gamma_bloc[5] = MSB_cDDT_v[carry[5]][AB_block[5]][i5][j5];
			gamma_temp = (gamma_bloc[5] << 40) | (gamma_bloc[4] << 32)
					| (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
					| (gamma_bloc[1] <<8) | gamma_bloc[0];

			P_w[1] = i0 + i1 +i2 +i3 +i4 +i5;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
			best = sepck_round_r_diff(search_round,2,gamma_temp,Beta);
#if 0   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[1] = input_left;  // output part of the r-th round..
			n_y_in[1] = input_right;
			n_x_in[2] = gamma_temp;  // output part of the r-th round..
			n_y_in[2] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
			return 1;
		}
#endif
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		break;
	case 128:
		for(j=0;j<nBytes;j++)  //nBytes
		{
			alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
			beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
			AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
		}
		carry[0] = 0;
		for(j=1;j<nBytes;j++)  //nBytes
		{
			carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
				+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
		}

		for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
		{
			if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
		{
			gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
			//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
			carry[1] = carry_tmp[1]	+ (gamma_bloc[0] >> 7); // gamma MSB

		for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
		{
			gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
			//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
			carry[2] = carry_tmp[2]	+ (gamma_bloc[1] >> 7); // gamma MSB

		for(i2 = 0; i2 <= cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
		{
			if(i0 + i1 +i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
		{
			gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
			//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
			carry[3] = carry_tmp[3]	+ (gamma_bloc[2] >> 7); // gamma MSB
		for(i3 = 0; i3 <= cDDT_wt_max[carry[3]][AB_block[3]]; i3++)
		{
			if(i0 + i1 +i2 +i3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
		{
			gamma_bloc[3] = cDDT_v[carry[3]][AB_block[3]][i3][j3];
			//carry[4] = ((alpha_bloc[3] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[3] >> 7) << 1)   //beta MSB
			carry[4] = carry_tmp[4]	+ (gamma_bloc[3] >> 7); // gamma MSB

		for(i4 = 0; i4 <= cDDT_wt_max[carry[4]][AB_block[4]]; i4++)
		{
			if(i0 + i1 +i2 +i3 +i4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j4=0; j4 < cDDT_n[carry[4]][AB_block[4]][i4]; j4++)
		{
			gamma_bloc[4] = cDDT_v[carry[4]][AB_block[4]][i4][j4];
			//carry[5] = ((alpha_bloc[4] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[4] >> 7) << 1)   //beta MSB
			carry[5] = carry_tmp[5]	+ (gamma_bloc[4] >> 7); // gamma MSB

		for(i5 = 0; i5 <= cDDT_wt_max[carry[5]][AB_block[5]]; i5++)
		{
			if(i0 + i1 +i2 +i3 +i4 +i5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j5=0; j5 < cDDT_n[carry[5]][AB_block[5]][i5]; j5++)
		{
			gamma_bloc[5] = cDDT_v[carry[5]][AB_block[5]][i5][j5];
			//carry[6] = ((alpha_bloc[5] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[5] >> 7) << 1)   //beta MSB
			carry[6] = carry_tmp[6]	+ (gamma_bloc[5] >> 7); // gamma MSB

		for(i6 = 0; i6 <= cDDT_wt_max[carry[6]][AB_block[6]]; i6++)
		{
			if(i0 + i1 +i2 +i3 +i4 +i5 +i6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j6=0; j6 < cDDT_n[carry[6]][AB_block[6]][i6]; j6++)
		{
			gamma_bloc[6] = cDDT_v[carry[6]][AB_block[6]][i6][j6];
			//carry[7] = ((alpha_bloc[6] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[6] >> 7) << 1)   //beta MSB
			carry[7] = carry_tmp[7]	+ (gamma_bloc[6] >> 7); // gamma MSB

		for(i7 = 0; i7 <= MSB_cDDT_wt_max[carry[7]][AB_block[7]]; i7++)
		{
			if(i0 + i1 +i2 +i3 +i4 +i5 +i6 +i7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j7=0; j7 < MSB_cDDT_n[carry[7]][AB_block[7]][i7]; j7++)
		{
			gamma_bloc[7] = MSB_cDDT_v[carry[7]][AB_block[7]][i7][j7];
			gamma_temp = (gamma_bloc[7] << 56) | (gamma_bloc[6] << 48)
					| (gamma_bloc[5] << 40) | (gamma_bloc[4] << 32)
					| (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
					| (gamma_bloc[1] <<8) | gamma_bloc[0];

			P_w[1] = i0 + i1 +i2 +i3 +i4 +i5 +i6 +i7;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
			best = sepck_round_r_diff(search_round,2,gamma_temp,Beta);

#if 0   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[1] = input_left;  // output part of the r-th round..
			n_y_in[1] = input_right;
			n_x_in[2] = gamma_temp;  // output part of the r-th round..
			n_y_in[2] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
			return 1;
		}
#endif

		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		break;
	default:
		break;
	}


	return best;
}

u16 sepck_input_MSB
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi )
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 j_abc = 0;

/*  //只考虑了set-A
	for(j_abc = 0; j_abc < 4;j_abc++)   // MSB
	{
		if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = V_MSB;
		}
		else
		{
			Input_alpha = 0;  // & Bit_Align;
		}

		if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
		{
			Input_beta = V_MSB;
		}
		else
		{
			Input_beta = 0; // & Bit_Align;
		}

		if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
		{
			Input_gamma = V_MSB;
		}
		else
		{
			Input_gamma = 0;  // & Bit_Align;
		}
*/


	// MSB of of alpha/beta/gamma
	for(j_abc = 0; j_abc < 8;j_abc++)   // MSB
	{
		//set A of MSB.
		if((j_abc==0) || (j_abc==3) || (j_abc==5) || (j_abc==6) )
		{
			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = V_MSB;
			}
			else
			{
				Input_alpha = 0;  // & Bit_Align;
			}

			if((j_abc & 0x2) != 0) // beta bit j.
			{
				Input_beta = V_MSB;
			}
			else
			{
				Input_beta = 0; // & Bit_Align;
			}

			if((j_abc & 0x1) != 0) // gamma bit j.
			{
				Input_gamma = V_MSB;
			}
			else
			{
				Input_gamma = 0;  // & Bit_Align;
			}

			state = sepck_input_Middle(search_round,Input_alpha,Input_beta, Input_gamma,P_1,posi,P_1);
		}
		else //set B of MSB //if((j_abc==1) || (j_abc==2) || (j_abc==4) || (j_abc==7) )
		{
			//对于speck96和speck128,不考虑导致后续比特全确定情况
			//若为{0,3,5,6}则除MSB外其它后面比特全为0
			//若为{1、2、4,7}则除MSB外其它后面比特全为1
		if((j_abc & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = Bit_Align;
		}
		else
		{
			Input_alpha = ValueMax_Align;  // & Bit_Align;
		}

		if((j_abc & 0x2) != 0) // beta bit j.
		{
			Input_beta = Bit_Align;
		}
		else
		{
			Input_beta = ValueMax_Align; // & Bit_Align;
		}

		if((j_abc & 0x1) != 0) // gamma bit j.
		{
			Input_gamma = ValueMax_Align;
		}
		else
		{
			Input_gamma = Bit_Align;  // & Bit_Align;
		}

		state = sepck_input_Middle(search_round,Input_alpha,Input_beta, Input_gamma,P_1,posi,P_1);
		}

		//state = sepck_input_Middle(search_round,Input_alpha,Input_beta, Input_gamma,P_1,posi,P_1);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
}
	return state;
}

//由高位到低位逐步判断
u16 sepck_input_Middle
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi, u16 cur_posi)
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u64 indx_tmp = 0;
	u16 i = 0;
	u64 bit_i = 1;


	indx_tmp = posi[cur_posi] - 1;

	// 考虑到产生概率重量的位置为全部可能的状态{3/5/6,1/2/4}
	// Middle bit positionsof of alpha/beta/gamma
	if( cur_posi > 1)  // Middle bit positionsof of alpha/beta/gamma
	{
		//只有{3/5/6,1/2/4}会导致该位置产生概率重量
		for(j_abc = 1; j_abc < 7; j_abc++)   //概率重量位置的可能取值组合
		{
			//判断该位置对应的alpha、beta、gamma的比特值为0还是1；
			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = alpha | (bit_i << indx_tmp);
			}
			else
			{
				//Input_alpha = alpha; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_alpha = (alpha & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x2) != 0) // alpha bit j.
			{
				Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_beta = beta; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_beta = (beta & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x1) != 0) // alpha bit j.
			{
				Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}


			//判断该位置是属于{3/5/6}，后续比特位置全清0
			if( (j_abc==3) || (j_abc==5) || (j_abc==6) )
			{
				// setA对应到下一个不全同比特位置,全设置为0才满足差分有效性条件.
				for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
				{
					Input_alpha &= ~(bit_i << j_last);
					Input_beta  &= ~(bit_i << j_last);
					Input_gamma &= ~(bit_i << j_last);
				}
			}
			else //判断该位置是属于{1/2/4}，后续比特位置全部置1；
			{
				// setB_3对应到下一个不全同比特位置,全设置为 1 才满足差分有效性条件.
				for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
				{
					Input_alpha ^= (bit_i << j_last);
					Input_beta  ^= (bit_i << j_last);
					Input_gamma ^= (bit_i << j_last);
				}
			}


/*  //只考虑了产生概率重量的比特位置为{3/5/6}的情况，可能会忽略部分组合
	//indx_tmp = 1 << (posi[cur_posi] - 1);
	indx_tmp = posi[cur_posi] - 1;

	// Middle bit positionsof of alpha/beta/gamma
	if( cur_posi > 1)  // Middle bit positionsof of alpha/beta/gamma
	{

		//for(j_abc = 1; j_abc < 7; j_abc++)   // MSB //for speck32/48/64
		for(i = 0; i < 3; i++)   // MSB //for speck96/128
		{
			j_abc = set_A_3[i];  //for speck96/128

			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = alpha | (bit_i << indx_tmp);
			}
			else
			{
				Input_alpha = alpha; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				//Input_alpha = (alpha & ( ~(1 << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x2) != 0) // alpha bit j.
			{
				Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				Input_beta = beta; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				//Input_beta = (beta & ( ~(1 << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x1) != 0) // alpha bit j.
			{
				Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				//Input_gamma = (gamma & ( ~(1 << indx_tmp)) ); // & Bit_Align;
			}
*/


			state = sepck_input_Middle(search_round,Input_alpha,Input_beta, Input_gamma,P_1,posi,cur_posi-1);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
		}
	}
	else 	//call last position.
	{
		state = sepck_input_Last(search_round,
				alpha,beta,	gamma,P_1,posi );
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
	}
	return state;
}

u16 sepck_input_Last
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi )
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u64 indx_tmp = 0;

	u64 bit_i = 1;


	indx_tmp = posi[1] - 1;

	// 最后的一个产生概率重量的比特位置只能为{3、5/6}，在该位置之后的更低的比特位置都全部清0；
	for(j_abc = 0; j_abc < 3;j_abc++)// Last bit position.
	{
		if((set_A_3[j_abc] & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = alpha | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_alpha = alpha; // & ( ~(1 << indx_tmp))) & Bit_Align;
			Input_alpha = (alpha & ( ~(bit_i << indx_tmp))) & Bit_Align;
		}

		if((set_A_3[j_abc] & 0x2) != 0) // alpha bit j.
		{
			Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_beta = beta; // & ( ~(1 << indx_tmp))) & Bit_Align;
			Input_beta = (beta & ( ~(bit_i << indx_tmp))) & Bit_Align;
		}

		if((set_A_3[j_abc] & 0x1) != 0) // alpha bit j.
		{
			Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ) & Bit_Align;
			Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ) & Bit_Align;
		}

 	 	 // 需要在此将产生概率重量位置更低的比特位置全部清零
		if(posi[1] > 1)  //若产生概率重量的最后一个位置是LSB，则不用清0
			for(j_last=0; j_last< indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
			{
				Input_alpha &= ~(bit_i << j_last);
				Input_beta  &= ~(bit_i << j_last);
				Input_gamma &= ~(bit_i << j_last);
			}


		//基于构造的第1轮的输入输出差分组合，调用下一轮
		//P_w[1] = P_1;
		state = sepck_round_r(search_round, 2,(Input_gamma & Bit_Align),Input_gamma ^ (ROTATE_LEFT(Input_beta, rol_b,blocksize_len) & Bit_Align));
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		n_x_in[1] = (ROTATE_LEFT(Input_alpha, rol_a, blocksize_len)) & Bit_Align; // left part of Input of the first round.
		n_y_in[1] = Input_beta;  // right part of Input of the first round.

		n_x_in[2 ] = Input_gamma;  // left part output of fisrt round.
		n_y_in[2 ] = Input_gamma ^ (ROTATE_LEFT(Input_beta, rol_b,blocksize_len) & Bit_Align);
		return 1;
	}
#endif
	}
	return state;
}


u16 sepck_round_r(u16 search_round, u16 cur_round, u64 x, u64 y)
{
	u16 best = 0;
	u64 Alpha = 0;
	u64 Beta = 0;
	u64 next_Beta_tmp = 0;
	u64 xor_alpha_beta = 0;
//	u64 and_alpha_beta = 0;
	u16 w_xor = 0;
	u16	w_cmp = 0;
	u16 i = 0;
//	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
//	u64 rol_left = 0;
//	u64 rol_right = 0;
	u64 alpha_bloc[8] = {0};
//	u64 gamma_block_tmp[8] = {0};
	u64 beta_bloc[8] = {0};
	u64 gamma_bloc[8] = {0};
	u64 AB_block[8] = {0};
	u64 carry[8] ={0};
	u64 carry_tmp[8] ={0};
	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 beta_temp = 0;
	u64 gamma_temp = 0;
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;
	u8 w_xor_block[8] = {0};
//	u16 wt_purning = 63;
//	u16 wt_purning_chk = 63;

	if(search_round == cur_round)
	{
		best = speck_round_N(search_round, x, y );
		return best;
	}

	Alpha = (ROTATE_RIGHT(x,rol_a, blocksize_len)) & Bit_Align;
	Beta = y & Bit_Align;
	next_Beta_tmp = ROTATE_LEFT(y,rol_b,blocksize_len) & Bit_Align;

//	rol_right = ((x) >> (rol_a)) | ((x) << (blocksize_len - rol_a)); //right
//	rol_left = (((y) << rol_b) | ((y) >> (blocksize_len - rol_b)));
//	Beta = (x ^ rol_left) & Bit_Align;
//	Alpha = rol_right & Bit_Align; // alpha = gama_uper <<< rol_a;
	//Beta = (x ^ ROTATE_LEFT(y,rol_b,blocksize_len) )& Bit_Align;
	//Alpha = (ROTATE_RIGHT(x,rol_a, blocksize_len)) & Bit_Align; // alpha = gama_uper <<< rol_a;
	xor_alpha_beta = (Beta ^ Alpha) & ValueMax_Align ;
	w_xor = HM_weight(xor_alpha_beta );
	//w_xor = Speck_XDP_Max(Alpha, Beta);

/*
	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
*/

	w_cmp = Bn_w - p_sumof_r_P_w[cur_round -1] - n_P_bestofR_w[search_round - cur_round];
	if ( w_xor > w_cmp)
	{
		return 0;
	}

//双目剪枝方法，另外一种判断变量逻辑关系，理论支撑？

////////////////////////////选择SPECK的对应分组版本////////////////////////////
#if (SPECK_BYTE  == 32)  //SPECK-32
		//m0
		alpha_bloc[0] = (Alpha) & 0xFF; //8 bit
		beta_bloc[0]  = (Beta) & 0xFF; //8 bit
		AB_block[0] = (alpha_bloc[0] << 8) | beta_bloc[0];
		carry[0] = 0;
		//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
		//m1
		alpha_bloc[1]= (Alpha >> 8) & 0xFF; //8 bit
		beta_bloc[1] = ( Beta >> 8) & 0xFF; //8 bit
		AB_block[1] = (alpha_bloc[1] << 8) | beta_bloc[1];


		for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
		{
			if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
		{
			gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
			carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
					+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
					+ (gamma_bloc[0] >> 7); // gamma MSB
		for(i1 = 0; i1 <= MSB_cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < MSB_cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
		{
			gamma_bloc[1] = MSB_cDDT_v[carry[1]][AB_block[1]][i1][j1];
			gamma_temp = (gamma_bloc[1] <<8) | gamma_bloc[0];
			beta_temp = gamma_temp ^ next_Beta_tmp;
			P_w[cur_round] = i0 + i1;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
			p_sumof_r_P_w[cur_round] = p_sumof_r_P_w[cur_round -1] + P_w[cur_round];
			best = sepck_round_r(search_round,cur_round +1,gamma_temp, beta_temp);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[cur_round +1] = gamma_temp;  // output part of the r-th round..
			n_y_in[cur_round +1] = beta_temp; // Y
			return 1;
		}
#endif
		}}}}
////////////////////////////
#elif (SPECK_BYTE  == 48)  //SPECK-48
	case 48:
		for(j=0;j<nBytes;j++)  //nBytes
		{
			alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
			beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
			AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
		}
		for(j=1;j<nBytes;j++)  //nBytes
		{
			w_xor_block[j] = (u8)_mm_popcnt_u64((xor_alpha_beta >> (j*8)));
		}
		carry[0] = 0;
		for(j=1;j<nBytes;j++)  //nBytes
		{
			carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
				+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
		}

		for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
		{
			if(i0 + w_xor_block[1] > w_cmp ){break;}
		for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
		{
			gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
			//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
			carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB

		for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
		{
			w1 = i0 + i1;
			if(w1 + w_xor_block[2] > w_cmp ){break;}
		for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
		{
			gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
			//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
			carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

		for(i2 = 0; i2 <= MSB_cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
		{
			w2 = w1 + i2;
			if(w2 > w_cmp ){break;}
		for(j2=0; j2 < MSB_cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
		{
			gamma_bloc[2] = MSB_cDDT_v[carry[2]][AB_block[2]][i2][j2];
			gamma_temp = (gamma_bloc[2] << 16) | (gamma_bloc[1] <<8) | gamma_bloc[0];
			beta_temp = gamma_temp ^ next_Beta_tmp;

			P_w[cur_round] = w2;  //i0 + i1 +i2;
			p_sumof_r_P_w[cur_round] = p_sumof_r_P_w[cur_round -1] + P_w[cur_round];

			best = sepck_round_r(search_round,cur_round +1,gamma_temp, beta_temp);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[cur_round +1] = gamma_temp;  // output part of the r-th round..
			n_y_in[cur_round +1] = beta_temp; // Y
			return 1;
		}
#endif
		}}}}}}
////////////////////////////
#elif (SPECK_BYTE  == 64)  //SPECK-64
		for(j=0;j<nBytes;j++)  //nBytes
		{
			alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
			beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
			AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
		}
		for(j=1;j<nBytes;j++)  //nBytes
		{
			w_xor_block[j] = (u8)_mm_popcnt_u64((xor_alpha_beta >> (j*8)));
		}
		carry[0] = 0;
		for(j=1;j<nBytes;j++)  //nBytes
		{
			carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
				+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
		}

		for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
		{
			if(i0 + w_xor_block[1] > w_cmp ){break;}
		for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
		{
			gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
			//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
			carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB

		for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
		{
			w1 = i0 + i1;
			if(w1 + w_xor_block[2] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
		{
			gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
			//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
			carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

		for(i2 = 0; i2 <= cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
		{
			w2 = w1 + i2;
			if(w2 + w_xor_block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
		{
			gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
			//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
			carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB

		for(i3 = 0; i3 <= MSB_cDDT_wt_max[carry[3]][AB_block[3]]; i3++)
		{
			w3 = w2 + i3;
			if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < MSB_cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
		{
			gamma_bloc[3] = MSB_cDDT_v[carry[3]][AB_block[3]][i3][j3];
			gamma_temp = (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
					   | (gamma_bloc[1] <<8) | gamma_bloc[0];

			beta_temp = gamma_temp ^ next_Beta_tmp;

			P_w[cur_round] = w3; //i0 + i1 +i2 +i3;
			p_sumof_r_P_w[cur_round] = p_sumof_r_P_w[cur_round -1] + P_w[cur_round];

			best = sepck_round_r(search_round,cur_round +1,gamma_temp, beta_temp);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[cur_round +1] = gamma_temp;  // output part of the r-th round..
			n_y_in[cur_round +1] = beta_temp; // Y
			return 1;
		}
#endif
		}}}}}}}}
////////////////////////////
#elif (SPECK_BYTE  == 96)  //SPECK-96
		for(j=0;j<nBytes;j++)  //nBytes
		{
			alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
			beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
			AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
		}
		for(j=1;j<nBytes;j++)  //nBytes
		{
			w_xor_block[j] = (u8)_mm_popcnt_u64((xor_alpha_beta >> (j*8)));
		}

		carry[0] = 0;
		for(j=1;j<nBytes;j++)  //nBytes
		{
			carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
				+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
		}

		for(i0 = cDDT_wt_min[carry[0]][AB_block[0]];
				i0 <= cDDT_wt_min[carry[0]][AB_block[0]]; i0++)  //cDDT_wt_max[carry[0]][AB_block[0]]
		{
			//w0 = i0;
			if(i0 + w_xor_block[1] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
			{
				gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
				carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB
		for(i1 = cDDT_wt_min[carry[1]][AB_block[1]];
				i1 <= cDDT_wt_min[carry[1]][AB_block[1]]; i1++)  //cDDT_wt_max[carry[1]][AB_block[1]]
		{
			w1 = i0 + i1;
			if(w1 + w_xor_block[2] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
			{
				gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
				carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB
		for(i2 = cDDT_wt_min[carry[2]][AB_block[2]];
				i2 <= cDDT_wt_min[carry[2]][AB_block[2]]; i2++)  // cDDT_wt_max[carry[2]][AB_block[2]]
		{
			w2 = w1 + i2;
			if(w2 + w_xor_block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
			{
			gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
			carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB
		for(i3 = cDDT_wt_min[carry[3]][AB_block[3]];
				i3 <= cDDT_wt_min[carry[3]][AB_block[3]]; i3++)  //cDDT_wt_max[carry[3]][AB_block[3]]
		{
			w3 = w2 + i3;
			if(w3 + w_xor_block[4] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j3=0; j3 < cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
			{
				gamma_bloc[3] = cDDT_v[carry[3]][AB_block[3]][i3][j3];
				carry[4] = carry_tmp[4] + (gamma_bloc[3] >> 7); // gamma MSB
		for(i4 = cDDT_wt_min[carry[4]][AB_block[4]];
				i4 <= cDDT_wt_min[carry[4]][AB_block[4]]; i4++)  //cDDT_wt_max[carry[4]][AB_block[4]]
		{
			w4 = w3 + i4;
			if(w4 + w_xor_block[5]> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j4=0; j4 < cDDT_n[carry[4]][AB_block[4]][i4]; j4++)
			{
				gamma_bloc[4] = cDDT_v[carry[4]][AB_block[4]][i4][j4];
				carry[5] = carry_tmp[5] + (gamma_bloc[4] >> 7); // gamma MSB
		for(i5 = MSB_cDDT_wt_min[carry[5]][AB_block[5]];
				i5 <= MSB_cDDT_wt_min[carry[5]][AB_block[5]]; i5++)  //MSB_cDDT_wt_max[carry[5]][AB_block[5]]
		{
			w5 = w4 + i5;
			if(w5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			P_w[cur_round] = w5;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
			p_sumof_r_P_w[cur_round] = p_sumof_r_P_w[cur_round -1] + P_w[cur_round];

			for(j5=0; j5 < MSB_cDDT_n[carry[5]][AB_block[5]][i5]; j5++)
			{
			gamma_bloc[5] = MSB_cDDT_v[carry[5]][AB_block[5]][i5][j5];
			gamma_temp = (gamma_bloc[5] << 40) | (gamma_bloc[4] << 32)
					| (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
					| (gamma_bloc[1] <<8) | gamma_bloc[0];

			beta_temp = gamma_temp ^ next_Beta_tmp;

/*
 	 	 	 //限定每一个生产的beta的汉明重量
			wt_purning_chk = HM_weight(beta_temp);
			if(wt_purning_chk <= wt_purning )
			{
				wt_purning = wt_purning_chk;
				best = sepck_round_r(search_round,cur_round +1,gamma_temp, beta_temp);
			}
*/
			//if(w_xor + 9 > w5 ) //对应的DDT的概率在一个范围内
			{
				best = sepck_round_r(search_round,cur_round +1,gamma_temp, beta_temp);
			}

			//best = sepck_round_r(search_round,cur_round +1,gamma_temp, beta_temp);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[cur_round +1] = gamma_temp;  // output part of the r-th round..
			n_y_in[cur_round +1] = beta_temp; // Y
			return 1;
		}
#endif
		}
		}}}}}}}}}}}

/*
//////////////贪婪算法////////////每一轮的都只是概率最大的分支,该相同概率下的分支会有很多,但是这里只搜了其中一条,因此,遍历
		///的总的分支数就是第1轮的输入组合分支数

		//xor_alpha_beta = Beta ^ Alpha ;
		//w_xor = HM_weight(xor_alpha_beta & ValueMax_Align);
		and_alpha_beta = Beta & Alpha;
		w_and = HM_weight(and_alpha_beta & ValueMax_Align);

		P_w[cur_round] = w_xor + w_and;  // 00-->0;01,10-->1; 11-->0,概率的和
		if ( P_w[cur_round] > w_cmp)
		{
			return 0;
		}

//		gamma_temp |= V_MSB;
		gamma_temp = xor_alpha_beta; // 00-->1; 01,10--->0;11-->1;的情况先不考虑,因此只贪婪的考虑SetA的情况.

		best = sepck_round_r(search_round,cur_round +1,gamma_temp,Beta);
#if 1   //是否找到第一条最优路径就返回？
	if( best == 1 )
	{
		n_x_in[cur_round +1] = gamma_temp;  // output part of the r-th round..
		n_y_in[cur_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
		return 1;
	}
#endif
//////////////贪婪算法////////////
	*/
		////////////////////////////
#elif (SPECK_BYTE  == 128)  //SPECK-128
		for(j=0;j<nBytes;j++)  //nBytes
		{
			alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
			beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
			AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
			//w_xor_block[j] = cDDT_AB_wt_min[AB_block[j]];
		}

		for(j=1;j<nBytes;j++)  //nBytes
		{
			w_xor_block[j] = (u8)_mm_popcnt_u64((xor_alpha_beta >> (j*8)));
		}

		carry[0] = 0;
		for(j=1;j<nBytes;j++)  //nBytes
		{
			carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
				+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
		}

		for(i0 = cDDT_wt_min[carry[0]][AB_block[0]];
				i0 <= cDDT_wt_min[carry[0]][AB_block[0]]; i0++)  //cDDT_wt_max[carry[0]][AB_block[0]];
		{
			//w0 = i0;
			if(i0 + w_xor_block[1] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
		{
			gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
			//gamma_block_tmp[0] = gamma_bloc[0];
			carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB
		for(i1 = cDDT_wt_min[carry[1]][AB_block[1]];
				i1 <= cDDT_wt_min[carry[1]][AB_block[1]]; i1++)  //cDDT_wt_max[carry[1]][AB_block[1]]
		{
			w1 = i0 + i1;
			if(w1 + w_xor_block[2] > w_cmp ){break;}  //break
		for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
		{
			gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
			carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB
		for(i2 = cDDT_wt_min[carry[2]][AB_block[2]];
				i2 <= cDDT_wt_min[carry[2]][AB_block[2]]; i2++)  //cDDT_wt_max[carry[2]][AB_block[2]]
		{
			w2 = w1 + i2;
			if(w2 + w_xor_block[3] > w_cmp ){break;}  //break
		for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
		{
			gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
			carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB
		for(i3 = cDDT_wt_min[carry[3]][AB_block[3]];
				i3 <= cDDT_wt_min[carry[3]][AB_block[3]]; i3++)  //cDDT_wt_max[carry[3]][AB_block[3]]
		{
			w3 = w2 + i3;
			if(w3 + w_xor_block[4] > w_cmp ){break;}  //break
		for(j3=0; j3 < cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
		{
			gamma_bloc[3] = cDDT_v[carry[3]][AB_block[3]][i3][j3];
			carry[4] = carry_tmp[4] + (gamma_bloc[3] >> 7); // gamma MSB
		for(i4 = cDDT_wt_min[carry[4]][AB_block[4]];
				i4 <= cDDT_wt_min[carry[4]][AB_block[4]]; i4++) //cDDT_wt_max[carry[4]][AB_block[4]]
		{
			w4 = w3 + i4;
			if(w4 + w_xor_block[5] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j4=0; j4 < cDDT_n[carry[4]][AB_block[4]][i4]; j4++)
		{
			gamma_bloc[4] = cDDT_v[carry[4]][AB_block[4]][i4][j4];
			carry[5] = carry_tmp[5] + (gamma_bloc[4] >> 7); // gamma MSB
		for(i5 = cDDT_wt_min[carry[5]][AB_block[5]];
				i5 <= cDDT_wt_min[carry[5]][AB_block[5]]; i5++)  //cDDT_wt_max[carry[5]][AB_block[5]]
		{
			w5 = w4 + i5;
			if(w5 + w_xor_block[6] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j5=0; j5 < cDDT_n[carry[5]][AB_block[5]][i5]; j5++)
		{
			gamma_bloc[5] = cDDT_v[carry[5]][AB_block[5]][i5][j5];
			carry[6] = carry_tmp[6] + (gamma_bloc[5] >> 7); // gamma MSB
		for(i6 = cDDT_wt_min[carry[6]][AB_block[6]];
				i6 <= cDDT_wt_min[carry[6]][AB_block[6]]; i6++)  //cDDT_wt_max[carry[6]][AB_block[6]]
		{
			w6 = w5 + i6;
			if(w6 + w_xor_block[7] > w_cmp ){break;}  //break //break 要比 continue 高效,直接结束.
		for(j6=0; j6 < cDDT_n[carry[6]][AB_block[6]][i6]; j6++)
		{
			gamma_bloc[6] = cDDT_v[carry[6]][AB_block[6]][i6][j6];

/*
///////////
			gamma_block_msb[6] = gamma_bloc[6] >> 7;
			if(gamma_block_msb_flag[7] == 0)  //本轮此处第一次进入下一个循环嵌套
			{
				carry[7] = carry_tmp[7] + gamma_block_msb[6]; // gamma MSB

			}
			else //本轮此处不是第一次进入下一个循环嵌套，
			{   //则需要判断gamma_bloc的最高位的值gamma_block_msb[6]以前是否出现过并break了

			}
*/

////////////

			carry[7] = carry_tmp[7] + (gamma_bloc[6] >> 7); // gamma MSB
		for(i7 = MSB_cDDT_wt_min[carry[7]][AB_block[7]];
				i7 <= MSB_cDDT_wt_min[carry[7]][AB_block[7]]; i7++)  //MSB_cDDT_wt_max[carry[7]][AB_block[7]]
		{
			w7 = w6 + i7;
			if(w7> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			P_w[cur_round] = w7;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
			p_sumof_r_P_w[cur_round] = p_sumof_r_P_w[cur_round -1] + P_w[cur_round];

		for(j7=0; j7 < MSB_cDDT_n[carry[7]][AB_block[7]][i7]; j7++)
		{
			gamma_bloc[7] = MSB_cDDT_v[carry[7]][AB_block[7]][i7][j7];
//			gamma_temp = (gamma_bloc[7] << 56) | gamma_block_tmp[6]
//					| gamma_block_tmp[5] | gamma_block_tmp[4]
//					| gamma_block_tmp[3] | gamma_block_tmp[2]
//					| gamma_block_tmp[1] | gamma_bloc[0];
//
			//这个gamma太特么多了，导致分支数太多，搜索复杂度太高
			gamma_temp = (gamma_bloc[7] << 56) | (gamma_bloc[6] << 48)
					| (gamma_bloc[5] << 40) | (gamma_bloc[4] << 32)
					| (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
					| (gamma_bloc[1] <<8) | gamma_bloc[0];
			beta_temp = gamma_temp ^ next_Beta_tmp;

			best = sepck_round_r(search_round,cur_round +1,gamma_temp, beta_temp);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[cur_round +1] = gamma_temp;  // output part of the r-th round..
			n_y_in[cur_round +1] = beta_temp; // Y
			return 1;
		}
#endif
		}
		}}}}}}}}}}}}}}}


/*
//////////////贪婪算法////////////每一轮的都只是概率最大的分支,该相同概率下的分支会有很多,但是这里只搜了其中一条,因此,遍历
				///的总的分支数就是第1轮的输入组合分支数

				//xor_alpha_beta = Beta ^ Alpha ;
				//w_xor = HM_weight(xor_alpha_beta & ValueMax_Align);
				and_alpha_beta = Beta & Alpha;
				w_and = HM_weight(and_alpha_beta & ValueMax_Align);

				P_w[cur_round] = w_xor + w_and;  // 00-->0;01,10-->1; 11-->0,概率的和
				if ( P_w[cur_round] > w_cmp)
				{
					return 0;
				}

		//		gamma_temp |= V_MSB;
				gamma_temp = xor_alpha_beta; //对应最小概率了，00-->1; 01,10--->0;11-->1;的情况先不考虑,因此只贪婪的考虑SetA的情况.

				best = sepck_round_r(search_round,cur_round +1,gamma_temp,Beta);
		#if 1   //是否找到第一条最优路径就返回？
			if( best == 1 )
			{
				n_x_in[cur_round +1] = gamma_temp;  // output part of the r-th round..
				n_y_in[cur_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
				return 1;
			}
		#endif
//////////////贪婪算法////////////
*/
#endif
	return best;
}

u16 sepck_round_r_diff(u16 search_round, u16 cur_round, u64 x, u64 y)
{
	u16 best = 0;
	u64 Alpha = 0;
	u64 Beta = 0;
	u64 xor_alpha_beta = 0;
	u16 w_cmp = 0;
	u16 w_xor = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 rol_left = 0;
	u64 rol_right = 0;
	u64 alpha_bloc[8] = {0};
	u64 beta_bloc[8] = {0};
	u64 gamma_bloc[8] = {0};
	u64 AB_block[8] = {0};
	u64 carry[8] ={0};
	u64 carry_tmp[8];
	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 gamma_temp = 0;

	if(search_round == cur_round)
	{
		best = speck_round_N_diff(search_round, x, y );
		return best;
	}

	rol_right = ((x) >> (rol_a)) | ((x) << (blocksize_len - rol_a)); //right
	rol_left = (((y) << rol_b) | ((y) >> (blocksize_len-rol_b)));
	Beta = (x ^ rol_left) & Bit_Align;
	Alpha = rol_right & Bit_Align; // alpha = gama_uper <<< rol_a;
	//Beta = (x ^ ROTATE_LEFT(y,rol_b,blocksize_len) )& Bit_Align;
	//Alpha = (ROTATE_RIGHT(x,rol_a, blocksize_len)) & Bit_Align; // alpha = gama_uper <<< rol_a;
	xor_alpha_beta = Beta ^ Alpha ;
	w_xor = HM_weight(xor_alpha_beta & ValueMax_Align);

	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	//wt_max限制搜索差分对应的路径的概率的下界
	w_cmp = wt_max - p_sumof_r - n_P_bestofR_w[search_round - cur_round];
	if ( w_xor > w_cmp)
	{
		return 0;
	}

	switch(sc_blocksize)
	{
	case 32:
		//m0
		alpha_bloc[0] = (Alpha) & 0xFF; //8 bit
		beta_bloc[0]  = (Beta) & 0xFF; //8 bit
		AB_block[0] = (alpha_bloc[0] << 8) | beta_bloc[0];
		carry[0] = 0;
		//m1
		alpha_bloc[1]= (Alpha >> 8) & 0xFF; //8 bit
		beta_bloc[1] = ( Beta >> 8) & 0xFF; //8 bit
		AB_block[1] = (alpha_bloc[1] << 8) | beta_bloc[1];


		for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
		{
			if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
		{
			gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
			carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
					+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
					+ (gamma_bloc[0] >> 7); // gamma MSB
		for(i1 = 0; i1 <= MSB_cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < MSB_cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
		{
			gamma_bloc[1] = MSB_cDDT_v[carry[1]][AB_block[1]][i1][j1];
			gamma_temp = (gamma_bloc[1] <<8) | gamma_bloc[0];

			P_w[cur_round] = i0 + i1;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
			best = sepck_round_r_diff(search_round,cur_round +1,gamma_temp,Beta);

#if 0   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[cur_round +1] = gamma_temp;  // output part of the r-th round..
			n_y_in[cur_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
			return 1;
		}
#endif
		}
		}
		}
		}
		break;
	case 48:
		for(j=0;j<nBytes;j++)  //nBytes
		{
			alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
			beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
			AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
		}
		carry[0] = 0;
		for(j=1;j<nBytes;j++)  //nBytes
		{
			carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
				+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
		}

		for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
		{
			if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
		{
			gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
			//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
			carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB

		for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
		{
			gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
			//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
			carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

		for(i2 = 0; i2 <= MSB_cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
		{
			if(i0 + i1 +i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2=0; j2 < MSB_cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
		{
			gamma_bloc[2] = MSB_cDDT_v[carry[2]][AB_block[2]][i2][j2];
			gamma_temp = (gamma_bloc[2] << 16) | (gamma_bloc[1] <<8) | gamma_bloc[0];

			P_w[cur_round] = i0 + i1 +i2;   // Speck_XDP_compute(Alpha, Beta, gamma_temp);
			best = sepck_round_r_diff(search_round,cur_round +1,gamma_temp,Beta);
#if 0   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[cur_round +1] = gamma_temp;  // output part of the r-th round..
			n_y_in[cur_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
			return 1;
		}
#endif
		}
		}
		}
		}
		}
		}
		break;
	case 64:
		for(j=0;j<nBytes;j++)  //nBytes
		{
			alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
			beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
			AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
		}
		carry[0] = 0;
		for(j=1;j<nBytes;j++)  //nBytes
		{
			carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
				+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
		}

		for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
		{
			if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
		{
			gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
			//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
			carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB

		for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
		{
			gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
			//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
			carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

		for(i2 = 0; i2 <= cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
		{
			if(i0 + i1 +i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
		{
			gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
			//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
			carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB

		for(i3 = 0; i3 <= MSB_cDDT_wt_max[carry[3]][AB_block[3]]; i3++)
		{
			if(i0 + i1 +i2 +i3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < MSB_cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
		{
			gamma_bloc[3] = MSB_cDDT_v[carry[3]][AB_block[3]][i3][j3];
			gamma_temp = (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
					   | (gamma_bloc[1] <<8) | gamma_bloc[0];

			P_w[cur_round] = i0 + i1 +i2 +i3;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
			best = sepck_round_r_diff(search_round,cur_round +1,gamma_temp,Beta);
#if 0   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[cur_round +1] = gamma_temp;  // output part of the r-th round..
			n_y_in[cur_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
			return 1;
		}
#endif
		}
		}
		}
		}
		}
		}
		}
		}
		break;
	case 96:
		for(j=0;j<nBytes;j++)  //nBytes
		{
			alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
			beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
			AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
		}
		carry[0] = 0;
		for(j=1;j<nBytes;j++)  //nBytes
		{
			carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
				+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
		}
		//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];

		for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
		{
			if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
		{
			gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
			//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
			carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB
		for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
		{
			gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
			//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
			carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB
		for(i2 = 0; i2 <= cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
		{
			if(i0 + i1 +i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
		{
			gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
			//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
			carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB
		for(i3 = 0; i3 <= cDDT_wt_max[carry[3]][AB_block[3]]; i3++)
		{
			if(i0 + i1 +i2 +i3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
		{
			gamma_bloc[3] = cDDT_v[carry[3]][AB_block[3]][i3][j3];
			//carry[4] = ((alpha_bloc[3] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[3] >> 7) << 1)   //beta MSB
			carry[4] = carry_tmp[4] + (gamma_bloc[3] >> 7); // gamma MSB
		for(i4 = 0; i4 <= cDDT_wt_max[carry[4]][AB_block[4]]; i4++)
		{
			if(i0 + i1 +i2 +i3 +i4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j4=0; j4 < cDDT_n[carry[4]][AB_block[4]][i4]; j4++)
		{
			gamma_bloc[4] = cDDT_v[carry[4]][AB_block[4]][i4][j4];
			//carry[5] = ((alpha_bloc[4] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[4] >> 7) << 1)   //beta MSB
			carry[5] = carry_tmp[5] + (gamma_bloc[4] >> 7); // gamma MSB
		for(i5 = 0; i5 <= MSB_cDDT_wt_max[carry[5]][AB_block[5]]; i5++)
		{
			if(i0 + i1 +i2 +i3 +i4 +i5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j5=0; j5 < MSB_cDDT_n[carry[5]][AB_block[5]][i5]; j5++)
		{
			gamma_bloc[5] = MSB_cDDT_v[carry[5]][AB_block[5]][i5][j5];
			gamma_temp = (gamma_bloc[5] << 40) | (gamma_bloc[4] << 32)
					| (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
					| (gamma_bloc[1] <<8) | gamma_bloc[0];

			P_w[cur_round] = i0 + i1 +i2 +i3 +i4 +i5;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
			best = sepck_round_r_diff(search_round,cur_round +1,gamma_temp,Beta);
#if 0   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[cur_round +1] = gamma_temp;  // output part of the r-th round..
			n_y_in[cur_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
			return 1;
		}
#endif
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		break;
	case 128:
		for(j=0;j<nBytes;j++)  //nBytes
		{
			alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
			beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
			AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
		}
		carry[0] = 0;
		for(j=1;j<nBytes;j++)  //nBytes
		{
			carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
				+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
		}

		for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
		{
			if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
		{
			gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
			//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
			carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB

		for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
		{
			gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
			//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
			carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

		for(i2 = 0; i2 <= cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
		{
			if(i0 + i1 +i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
		{
			gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
			//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
			carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB
		for(i3 = 0; i3 <= cDDT_wt_max[carry[3]][AB_block[3]]; i3++)
		{
			if(i0 + i1 +i2 +i3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
		{
			gamma_bloc[3] = cDDT_v[carry[3]][AB_block[3]][i3][j3];
			//carry[4] = ((alpha_bloc[3] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[3] >> 7) << 1)   //beta MSB
			carry[4] = carry_tmp[4] + (gamma_bloc[3] >> 7); // gamma MSB

		for(i4 = 0; i4 <= cDDT_wt_max[carry[4]][AB_block[4]]; i4++)
		{
			if(i0 + i1 +i2 +i3 +i4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j4=0; j4 < cDDT_n[carry[4]][AB_block[4]][i4]; j4++)
		{
			gamma_bloc[4] = cDDT_v[carry[4]][AB_block[4]][i4][j4];
			//carry[5] = ((alpha_bloc[4] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[4] >> 7) << 1)   //beta MSB
			carry[5] = carry_tmp[5] + (gamma_bloc[4] >> 7); // gamma MSB

		for(i5 = 0; i5 <= cDDT_wt_max[carry[5]][AB_block[5]]; i5++)
		{
			if(i0 + i1 +i2 +i3 +i4 +i5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j5=0; j5 < cDDT_n[carry[5]][AB_block[5]][i5]; j5++)
		{
			gamma_bloc[5] = cDDT_v[carry[5]][AB_block[5]][i5][j5];
			//carry[6] = ((alpha_bloc[5] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[5] >> 7) << 1)   //beta MSB
			carry[6] = carry_tmp[6] + (gamma_bloc[5] >> 7); // gamma MSB

		for(i6 = 0; i6 <= cDDT_wt_max[carry[6]][AB_block[6]]; i6++)
		{
			if(i0 + i1 +i2 +i3 +i4 +i5 +i6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j6=0; j6 < cDDT_n[carry[6]][AB_block[6]][i6]; j6++)
		{
			gamma_bloc[6] = cDDT_v[carry[6]][AB_block[6]][i6][j6];
			//carry[7] = ((alpha_bloc[6] >> 7) << 2) //alpha MSB
			//		+ ((beta_bloc[6] >> 7) << 1)   //beta MSB
			carry[7] = carry_tmp[7] + (gamma_bloc[6] >> 7); // gamma MSB

		for(i7 = 0; i7 <= MSB_cDDT_wt_max[carry[7]][AB_block[7]]; i7++)
		{
			if(i0 + i1 +i2 +i3 +i4 +i5 +i6 +i7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j7=0; j7 < MSB_cDDT_n[carry[7]][AB_block[7]][i7]; j7++)
		{
			gamma_bloc[7] = MSB_cDDT_v[carry[7]][AB_block[7]][i7][j7];
			gamma_temp = (gamma_bloc[7] << 56) | (gamma_bloc[6] << 48)
					| (gamma_bloc[5] << 40) | (gamma_bloc[4] << 32)
					| (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
					| (gamma_bloc[1] <<8) | gamma_bloc[0];

			P_w[cur_round] = i0 + i1 +i2 +i3 +i4 +i5 +i6 +i7;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
			best = sepck_round_r_diff(search_round,cur_round +1,gamma_temp,Beta);
#if 0   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			n_x_in[cur_round +1] = gamma_temp;  // output part of the r-th round..
			n_y_in[cur_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
			return 1;
		}
#endif
		}}
		}}}}
		}}}}}
		}}}}}
		break;
	default:
		break;
	}
	return best;
}

/*
u16 speck_gamma_xor_inc(u16 search_round, u16 cur_round,
		u64 Alpha, u64 Beta, u64 Gamma,
		u16 curr_wt_xor,u16 wt_xor, u16 *xor_sub_1,
		u16 wt_and,u16 *and_sub_1,
		u16 wt_or,u16 *or_sub_1,
		u16 wt_cmp)
{
	u16 state = 0;
	u16 j = 0;
	u64 gamma_temp = 0;


	if(curr_wt_xor < wt_xor)
	{
		for(j=0; j < 2;j++ )
		{
			if(j != 0)
			{
				gamma_temp = (Gamma | (1 << xor_sub_1[curr_wt_xor])) ;
			}
			else
			{
				gamma_temp = (Gamma & (~(1 << xor_sub_1[curr_wt_xor]))) ;  // & Bit_Align;
			}

			state = speck_gamma_xor_inc(search_round, cur_round,
					Alpha, Beta, gamma_temp,
					curr_wt_xor + 1, wt_xor, xor_sub_1,
					wt_and, and_sub_1,
					wt_or,or_sub_1,
					wt_cmp);
#if 1   //是否找到第一条最优路径就返回？
if(state==1)
return state;
#endif
		}
	}
	else //Call infection function.
	{
		state = speck_gamma_and_inc(search_round, cur_round,
				Alpha, Beta, Gamma,
				wt_xor, xor_sub_1,
				wt_and, and_sub_1,
				wt_or,  or_sub_1,
				wt_cmp);
#if 1   //是否找到第一条最优路径就返回？
if(state == 1)
	return state;
#endif
	}
	return state;
}

u16 speck_gamma_and_inc(u16 search_round, u16 cur_round,
		u64 Alpha, u64 Beta, u64 Gamma,
		u16 wt_xor, u16 *xor_sub_1,
		u16 wt_and,u16 *and_sub_1,
		u16 wt_or,u16 *or_sub_1,
		u16 wt_cmp)
{
	u16 state = 0;
	u16 i = 0;
	u16 j = 0;
	u16 and_sub_1_cmb = 0;
	u16 infect_wt = 0;
	//char infect_position[65536] = {0};  ////太小,当分组长度较大时候,且感染位增多时,组合数太多.
	char *infect_position = (char *)malloc(3042312352 * sizeof(char));  // 65536 // //1073741824
	u64 gamma_temp = 0;
	u16 bit_index = 0;


	for(infect_wt = 0; infect_wt <= wt_and; infect_wt++) // infected and-bit.
	{
		if ( wt_xor + infect_wt > wt_cmp)
		{
			free(infect_position );
			return 0;
		}

		if(infect_wt > 0) // 感染比特位置,通过排列组合选择
		{
			//组合生成gamma
			//首先确定当感染比特位置数量为infect_wt时,可能感染不同位置的模式的种数and_sub_1_cmb.
			and_sub_1_cmb = Combination_cal( infect_wt, wt_and, infect_position );

			for( i =0; i< and_sub_1_cmb;i++) //对于每一种infect_wt下的模式都生成对应gamma.
			{
				gamma_temp = Gamma;
				for(j=1; j <= infect_wt; j++) //每种感染模式下,对于每个感染比特
				{
					bit_index = and_sub_1[(u64)infect_position[i * infect_wt + j] - 1];
					gamma_temp = gamma_temp & (~(1 << bit_index));
				}

				state = speck_gamma_or_inc(search_round, cur_round,
						Alpha, Beta, gamma_temp,
						wt_xor, xor_sub_1,
						infect_wt, and_sub_1,
						wt_or,or_sub_1,
						wt_cmp);
#if 1   //是否找到第一条最优路径就返回？
			if( state == 1 )
			{
				free(infect_position );
				return 1;
			}
#endif
			}
		}
		else // 无and-bit感染比特位置,直接跳转查看or-bit感染位置
		{
			state = speck_gamma_or_inc(search_round, cur_round,
					Alpha, Beta, Gamma,
					wt_xor, xor_sub_1,
					infect_wt, and_sub_1,
					wt_or,or_sub_1,
					wt_cmp);
#if 1   //是否找到第一条最优路径就返回？
	if( state == 1 )
	{
		free(infect_position );
		return 1;
	}
#endif
		}
	}
	free(infect_position );
	return state;
}

u16 speck_gamma_or_inc(u16 search_round, u16 cur_round,
		u64 Alpha, u64 Beta, u64 Gamma,
		u16 wt_xor, u16 *xor_sub_1,
		u16 wt_and,u16 *and_sub_1,
		u16 wt_or,u16 *or_sub_1,
		u16 wt_cmp)
{
	u16 state = 0;
	u16 i = 0;
	u16 j = 0;
	u16 or_sub_1_cmb = 0;
	u16 infect_wt = 0;
	//char infect_position[65536] = {0};  ////太小,当分组长度较大时候,且感染位增多时,组合数太多.
	char *infect_position = (char *)malloc(3042312352 * sizeof(char)); // 65536
	u64 gamma_temp = 0;
	u16 bit_index = 0;


	for(infect_wt = 0; infect_wt <= wt_or; infect_wt++) // infected or-bit.
	{
		if ( wt_xor + wt_and + infect_wt > wt_cmp)
		{
			free(infect_position );
			return 0;
		}

		if(infect_wt > 0) // 感染比特位置,通过排列组合选择
		{
			//组合生成gamma
			//首先确定当感染比特位置数量为infect_wt时,可能感染不同位置的模式的种数and_sub_1_cmb.
			or_sub_1_cmb = Combination_cal( infect_wt, wt_or, infect_position );

			for( i =0; i< or_sub_1_cmb;i++) //对于每一种infect_wt下的模式都生成对应gamma.
			{
				gamma_temp = Gamma;
				for(j=1; j <= infect_wt; j++) //每种感染模式下,对于每个感染比特
				{
					bit_index = or_sub_1[(u64)infect_position[i * infect_wt + j] - 1];
					gamma_temp = gamma_temp | (1 << bit_index);
				}
				//判断组合生成的这个gamma是否是有效的.
				if( (Speck_XDP_validcheck(Alpha,Beta,gamma_temp )& Bit_Align) == 0) //如有效则进行下一轮.
				{
					P_w[cur_round] = wt_xor + wt_and + infect_wt;
					state = sepck_round_r(search_round,cur_round +1,gamma_temp,Beta);
#if 1   //是否找到第一条最优路径就返回？
			if( state == 1 )
			{
				n_x_in[cur_round +1] = gamma_temp;  // left output part of the r-th round..
				n_y_in[cur_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
				free(infect_position );
				return 1;
			}
#endif
				}
			}
		}
		else // 无or-bit感染比特位置,直接跳转查看or-bit感染位置
		{
			//判断组合生成的这个gamma是否是有效的.
			if( (Speck_XDP_validcheck(Alpha,Beta,Gamma )& Bit_Align) == 0) //如有效则进行下一轮.
			{
			P_w[cur_round] = wt_xor + wt_and + infect_wt;
			state = sepck_round_r(search_round,cur_round+1,Gamma,Beta);
#if 1   //是否找到第一条最优路径就返回？
	if( state == 1 )
	{
		n_x_in[cur_round +1] = Gamma;  // left output part of the r-th round..
		n_y_in[cur_round +1] = Gamma ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
		free(infect_position );
		return 1;
	}
#endif
			}
		}
	}
	free(infect_position );
	return state;
}


u16 speck_gamma_and_or_inc(u16 search_round, u16 cur_round,
		u64 Alpha, u64 Beta, u64 Gamma,
		u16 wt_xor, u16 *xor_sub_1,
		u16 wt_and,u16 *and_sub_1,
		u16 and_or_sub_1_num,u16 *and_or_sub_1,
		u16 wt_cmp)
{
	u16 state = 0;
	u16 i = 0;
	u16 j = 0;
	u16 g = 0;
	u16 and_sub_1_cmb = 0;
	u16 infect_wt = 0;
	//char infect_position[65536] = {0};  ////太小,当分组长度较大时候,且感染位增多时,组合数太多.
	char *infect_position = (char *)malloc(3042312352 * sizeof(char)); //65536
	u64 gamma_temp = 0;
	u16 AND_FLAG = 0;
	u16 bit_index = 0;

	for(infect_wt = 0; infect_wt <= and_or_sub_1_num; infect_wt++)
	{
		if ( wt_xor + infect_wt > wt_cmp)
		{
			free(infect_position );
			return 0;
		}

		if(infect_wt > 0) // 感染比特位置,分两种感染方法.
		{
			//组合生成gamma
			//首先确定当感染比特位置数量为infect_wt时,可能感染不同位置的模式的种数and_sub_1_cmb.
			and_sub_1_cmb = Combination_cal( infect_wt, and_or_sub_1_num, infect_position );

			for( i =0; i< and_sub_1_cmb;i++) //对于每一种infect_wt下的模式都生成对应gamma.
			{
				gamma_temp = Gamma;
				for(j=1; j <= infect_wt; j++) //每种感染模式下,对于每个感染比特
				{
					AND_FLAG = 0;
					bit_index = and_or_sub_1[(u64)infect_position[i * infect_wt + j] -1];
					for(g=0; g < wt_and; g++) //判断每个感染比特的位置是否对应alpha和beta相与为1的位置.
					{
						if(and_sub_1[g] == bit_index)//若该比特对应alpha和beta相与为1.
						{
							gamma_temp = gamma_temp & (~(1 << and_sub_1[g]));
							AND_FLAG = 1;
							break;
						}
					}

					if(AND_FLAG == 0)
					{
						gamma_temp = gamma_temp | (1 << bit_index);
					}
				}

				//判断组合生成的这个gamma是否是有效的.
				if( (Speck_XDP_validcheck(Alpha,Beta,gamma_temp )& Bit_Align) == 0) //如有效则进行下一轮.
				{
					P_w[cur_round] = wt_xor + infect_wt;
					state = sepck_round_r(search_round,cur_round +1,gamma_temp,Beta);
#if 1   //是否找到第一条最优路径就返回？
			if( state == 1 )
			{
				n_x_in[cur_round +1] = gamma_temp;  // left output part of the r-th round..
				n_y_in[cur_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
				free(infect_position );
				return 1;
			}
#endif
				}
			}
		}
		else // 无感染比特位置,直接跳转下一轮
		{
			//判断组合生成的这个gamma是否是有效的.
			if( (Speck_XDP_validcheck(Alpha,Beta,Gamma )& Bit_Align) == 0) //如有效则进行下一轮.
			{
			P_w[cur_round] = wt_xor;
			state = sepck_round_r(search_round,cur_round+1,Gamma,Beta);
#if 1   //是否找到第一条最优路径就返回？
	if( state == 1 )
	{
		n_x_in[cur_round +1] = Gamma;  // left output part of the r-th round..
		n_y_in[cur_round +1] = Gamma ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
		free(infect_position );
		return 1;
	}
#endif
		}
		}
	}
	free(infect_position );
	return state;
}


u16 speck_gamma(u16 xor_curr_sub,u16 xor_sub_1_num, u16 *xor_sub_1,
		u16 and_curr_sub,u16 and_sub_1_num, u16 *and_sub_1,
		u16 search_round, u16 cur_round,
		u64 Alpha, u64 Beta, u64 Gamma,
		u16 sum_wt_bf,u16 wt_xor,u16 wt_and)
{
	u16 state = 0;
	u64 gamma_temp = 0;
	u16 pro = 0;
	u64 *sub_and;
	u64 and_1_mode_num = 0;
	u64 i =0;
	u64 j =0;

	if(wt_xor == 0 )  //0--0
	{
		if(wt_and == 0 )
		{
			gamma_temp = Gamma & V_MSB;  //只保留最高位.
			P_w[cur_round] = wt_xor;
			//go to next rounds.
			state = sepck_round_r(search_round,cur_round+1,gamma_temp,Beta);
		}
		else  //0--!0
		{
			if ((sum_wt_bf + wt_xor + wt_and + n_P_bestofR_w[search_round - cur_round]) > Bn_w)
			{
				return 0;
			}
			P_w[cur_round] = wt_xor + wt_and;
			and_1_mode_num = Combination_cal( wt_and, blocksize_len-1, sub_and );

			if( wt_and > 1)  // and-bit  >1.
			{
				for( i = 0; i< and_1_mode_num; i++) //gamma of these bit ==0.
				{
					gamma_temp = Gamma & V_MSB;  //只保留最高位.gamma 相同.


// 在alpha和beta与值为1的所有比特位置中,最后一个位置的gamma位置设置为0,之前的位置遍历0和1.
				//	state = speck_gamma_11x_inc(search_round, cur_round,
				//			and_sub_1_num, sub_and,
				//			Alpha, Beta, Gamma,
				//			sum_wt_bf, wt_xor + wt_and);

#if 1   //是否找到第一条最优路径就返回？
	if(state==1)
 		return state;
#endif
				}
			}
			else  //0 --!0--1//and-bit = 1.
			{
				gamma_temp = Gamma & V_MSB;  //只保留最高位.gamma 相同.
				//go to next rounds.
				state = sepck_round_r(search_round,cur_round+1,gamma_temp,Beta);
#if 1   //是否找到第一条最优路径就返回？
if(state==1)
		return state;
#endif
// 在alpha和beta与值为1的比特位置,设置gamma的比特为0,同时在该比特之前遍历001的情况.
				for( i = 1; i<= and_1_mode_num; i++) //gamma of these bit ==0.
				{
					//sub_and[i]

					//state = speck_gamma_001_inc( );
#if 1   //是否找到第一条最优路径就返回？
	if(state==1)
 		return state;
#endif
				}
			}
		}
	}
	else
	{
		if(and_sub_1_num == 0 ) // !0--0
		{
		}
		else  //!0--!0
		{
			if ((sum_wt_bf + wt_xor + wt_and + n_P_bestofR_w[search_round - cur_round]) > Bn_w)
			{
				return 0;
			}
		}
	}
	return 1;
}

u16 speck_gamma_combine(u16 curr_sub,u16 sub_1_num, u16 *sub_1,
		u16 curr_sub_0,u16 sub_0_num, u16 *sub_0,
		u16 search_round, u16 cur_round, u64 Alpha, u64 Beta, u64 Gamma,u16 sum_wt_bf,u16 P_r)
{
	u16 state = 0;
	u16 gamma_j = 0;
	u64 gamma_temp = 0;
	u16 pro = 0;

	if(sub_1_num == 0) // Call next round.
	{
		pro = Speck_XDP_compute(Alpha,Beta,Gamma );
		if((sum_wt_bf + pro + n_P_bestofR_w[search_round - cur_round]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}
		if(Speck_XDP_validcheck(Alpha,Beta,Gamma ) == 0 )
		{
			P_w[cur_round] = pro; //P_r; // Speck_XDP_compute(Alpha,Beta,gamma_temp );
			state = sepck_round_r(search_round,cur_round + 1,Gamma,Beta);
#if 1   //是否找到第一条最优路径就返回？
		if( state == 1 )
		{
			n_x_in[cur_round +1] = Gamma;   // left output part of the r-th round..
			n_y_in[cur_round +1] = Gamma ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
			return 1;
		}
#endif
		}

		state = speck_gamma_wt_inc( 0, sub_0_num, sub_0,
						search_round, cur_round, Alpha, Beta, Gamma,sum_wt_bf,P_r);  //curr_sub_0
#if 1   //是否找到第一条最优路径就返回？
		if( state == 1 )
		{
			return 1;
		}
#endif
	}
	else {
	if(sub_1_num == (curr_sub + 1)) // Call next round.
	{
		for(gamma_j=0; gamma_j < 2;gamma_j++ )
		{
			if(gamma_j != 0)
			{
				gamma_temp = (Gamma ^ (1 << sub_1[curr_sub])) & Bit_Align;
			}
			else
			{
				gamma_temp = (Gamma);  // & Bit_Align;
			}

			pro = Speck_XDP_compute(Alpha,Beta,gamma_temp );
			if((sum_wt_bf + pro + n_P_bestofR_w[search_round - cur_round]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
			{
				return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
			}

			if(Speck_XDP_validcheck(Alpha,Beta,gamma_temp ) == 0 )
			{
				P_w[cur_round] = pro; // P_r; // Speck_XDP_compute(Alpha,Beta,gamma_temp );
				state = sepck_round_r(search_round,cur_round+1,gamma_temp,Beta);
#if 1   //是否找到第一条最优路径就返回？
			if( state == 1 )
			{
				n_x_in[cur_round +1] = gamma_temp;   // left output part of the r-th round..
				n_y_in[cur_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
				return 1;
			}
#endif
			}

			if( sub_0_num > 0 )
			{
				state = speck_gamma_wt_inc( 0, sub_0_num, sub_0,
							search_round, cur_round, Alpha, Beta, gamma_temp,sum_wt_bf,P_r);
#if 1   //是否找到第一条最优路径就返回？
			if( state == 1 )
			{
				return 1;
			}
#endif
			}
		}
	}
	else // Call next speck_gamma_base_combine.
	{
		for(gamma_j=0; gamma_j < 2;gamma_j++ )
		{
			if(gamma_j != 0)  // bit = 1.
			{
				gamma_temp = (Gamma ^ (1 << sub_1[curr_sub])) & Bit_Align;
			}
			else
			{
				gamma_temp = (Gamma);  // & Bit_Align;
			}

			state = speck_gamma_combine(curr_sub+1,sub_1_num, sub_1,
					0,sub_0_num, sub_0,
					search_round,cur_round,Alpha, Beta, gamma_temp,sum_wt_bf,P_r);
			if(state == 1)
			{
				return state;
			}
		}
	}
	}
	return 0;
}
*/

u16 speck_round_N(u16 search_round, u64 x, u64 y)
{
	u16 best = 0;
	u64 Alpha = 0;
	u64 Beta = 0;
	u64 next_Beta_tmp = 0;
	u64 xor_alpha_beta = 0; u64 and_alpha_beta = 0;
	u16 w_xor = 0;   u16 w_and = 0;
	u16 w_cmp = 0;
	u16 i = 0;
//	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 rol_left = 0;
	u64 rol_right = 0;
	u64 alpha_bloc[8] = {0};
	u64 beta_bloc[8] = {0};
	u64 gamma_bloc[8] = {0};
	u64 AB_block[8] = {0};
	u64 carry[8] ={0};
	u64 carry_tmp[8] ={0};
	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 gamma_temp = 0;
//	u64 gamma_block_tmp[8] = {0};
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;
	u8 w_xor_block[8] = {0};


	Alpha = (ROTATE_RIGHT(x,rol_a, blocksize_len)) & Bit_Align;
	Beta = y & Bit_Align;
	next_Beta_tmp = ROTATE_LEFT(y,rol_b,blocksize_len) & Bit_Align;


//	rol_right = ((x) >> (rol_a)) | ((x) << (blocksize_len - rol_a)); //right
//	rol_left = (((y) << rol_b) | ((y) >> (blocksize_len-rol_b)));
//	Beta = (x ^ rol_left) & Bit_Align;
//	Alpha = rol_right & Bit_Align; // alpha = gama_uper <<< rol_a;
	//Beta = x ^ (ROTATE_LEFT(y,rol_b,blocksize_len) & Bit_Align);
	//Alpha = (ROTATE_RIGHT(x,rol_a, blocksize_len)) & Bit_Align; // alpha = gama_uper <<< rol_a;
	xor_alpha_beta = (Beta ^ Alpha)  & ValueMax_Align;
	w_xor = HM_weight(xor_alpha_beta);

	//w_xor = Speck_XDP_Max(Alpha, Beta, &gamma_temp);
/*
	for(i=1; i < search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
*/
	w_cmp = Bn_w - p_sumof_r_P_w[search_round -1];
	if (w_xor > w_cmp)
	{
		return 0;
	}

	/*
	if (w_xor == w_cmp)
	{
		P_w[search_round] = w_xor;
		//gamma_temp = Speck_XDP_Max_Gamma(Alpha, Beta);
		best  = 1;
		n_P_bestofR_w[search_round] = Bn_w;
		n_x_in[search_round +1] = gamma_temp;  // output part of the r-th round..
		n_y_in[search_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
		return 1;
	}
	else
	{
		return 0;
	}
	*/


////////////////////////////选择SPECK的对应分组版本////////////////////////////
#if (SPECK_BYTE  == 32)  //SPECK-32
			//m0
			alpha_bloc[0] = (Alpha) & 0xFF; //8 bit
			beta_bloc[0]  = (Beta) & 0xFF; //8 bit
			AB_block[0] = (alpha_bloc[0] << 8) | beta_bloc[0];
			carry[0] = 0;
			//m1
			alpha_bloc[1]= (Alpha >> 8) & 0xFF; //8 bit
			beta_bloc[1] = ( Beta >> 8) & 0xFF; //8 bit
			AB_block[1] = (alpha_bloc[1] << 8) | beta_bloc[1];


			for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
			{
				if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
			{
				gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
				carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
						+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
						+ (gamma_bloc[0] >> 7); // gamma MSB
			for(i1 = 0; i1 <= MSB_cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
			{
				if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j1=0; j1 < MSB_cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
			{
				P_w[search_round] = i0 + i1;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);

				if (P_w[search_round] == w_cmp) //概率满足Matsui条件
				{
					gamma_bloc[1] = MSB_cDDT_v[carry[1]][AB_block[1]][i1][j1];
					gamma_temp = (gamma_bloc[1] <<8) | gamma_bloc[0];

					//printf("gamma[%d]: %x   \n", j2, gamma_temp);

					//best = sepck_round_r(search_round,cur_round +1,gamma_temp,Beta);
#if 1   //是否找到第一条最优路径就返回？
			//if( best == 1 )
			{
				best  = 1;
				n_P_bestofR_w[search_round] = Bn_w;
				n_x_in[search_round +1] = gamma_temp;  // output part of the r-th round..
				n_y_in[search_round +1] = gamma_temp ^ next_Beta_tmp;
				return 1;
			}
#endif
		}}}}}
////////////////////////////
#elif (SPECK_BYTE  == 48)  //SPECK-48
			for(j=0;j<nBytes;j++)  //nBytes
				{
					alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
					beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
					AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
				}
			for(j=1;j<nBytes;j++)  //nBytes
			{
				w_xor_block[j] = (u8)_mm_popcnt_u64((xor_alpha_beta >> (j*8)));
			}
					carry[0] = 0;
					for(j=1;j<nBytes;j++)  //nBytes
					{
						carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
									+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
					}

					for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
					{
						if(i0 + w_xor_block[1] > w_cmp ){break;}
					for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
					{
						gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
						//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
						carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB
					for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
					{
						w1 = i0 + i1;
						if(w1 + w_xor_block[2] > w_cmp ){break;}
					for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
					{
						gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
						//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
						carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

					for(i2 = 0; i2 <= MSB_cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
					{
						w2 = w1 + i2;
						if(w2 > w_cmp ){break;}
					for(j2=0; j2 < MSB_cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
					{
						gamma_bloc[2] = MSB_cDDT_v[carry[2]][AB_block[2]][i2][j2];
						gamma_temp = (gamma_bloc[2] << 16) | (gamma_bloc[1] <<8) | gamma_bloc[0];

						P_w[search_round] = w2; //i0 + i1 +i2;
						if (P_w[search_round] == w_cmp) //概率满足Matsui条件
						{
				#if 1   //是否找到第一条最优路径就返回？
						//if( best == 1 )
						{
							best  = 1;
							n_P_bestofR_w[search_round] = Bn_w;
							n_x_in[search_round +1] = gamma_temp;  // output part of the r-th round..
							n_y_in[search_round +1] = gamma_temp ^ next_Beta_tmp;
							return 1;
						}
				#endif
						}
					}
					}
					}
					}
					}
					}
////////////////////////////
#elif (SPECK_BYTE  == 64)  //SPECK-64
			for(j=0;j<nBytes;j++)  //nBytes
			{
				alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
				beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
				AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
			}
			for(j=1;j<nBytes;j++)  //nBytes
			{
				w_xor_block[j] = (u8)_mm_popcnt_u64((xor_alpha_beta >> (j*8)));
			}

			carry[0] = 0;
			for(j=1;j<nBytes;j++)  //nBytes
			{
				carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
							+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
			}

			for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
			{
				if(i0 + w_xor_block[1] > w_cmp ){break;}
					for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
					{
						gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
						//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
						carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB

					for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
					{
						w1 = i0 + i1;
						if(w1 + w_xor_block[2] > w_cmp ){break;}
					for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
					{
						gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
						//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
						carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

					for(i2 = 0; i2 <= cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
					{
						w2 = w1 + i2;
						if(w2 + w_xor_block[3] > w_cmp ){break;}
					for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
					{
						gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
						//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
						carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB

					for(i3 = 0; i3 <= MSB_cDDT_wt_max[carry[3]][AB_block[3]]; i3++)
					{
						w3 = w2 + i3;
						if(w3 > w_cmp ){break;}
					for(j3=0; j3 < MSB_cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
					{
						gamma_bloc[3] = MSB_cDDT_v[carry[3]][AB_block[3]][i3][j3];
						gamma_temp = (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
								   | (gamma_bloc[1] <<8) | gamma_bloc[0];
						P_w[search_round] = w3; //i0 + i1 +i2 +i3;
						if (P_w[search_round] == w_cmp) //概率满足Matsui条件
						{
			#if 1   //是否找到第一条最优路径就返回？
					//if( best == 1 )
					{
						best  = 1;
						n_P_bestofR_w[search_round] = Bn_w;
						n_x_in[search_round +1] = gamma_temp;  // output part of the r-th round..
						n_y_in[search_round +1] = gamma_temp ^ next_Beta_tmp;
						return 1;
/*
						if(flag == 0)
						{
							flag =1;
							return 0;
						}
						else
						{
							return 1;
						}
*/
					}
			#endif
					}}}}}}}}}
////////////////////////////
#elif (SPECK_BYTE  == 96)  //SPECK-96
				for(j=0;j<nBytes;j++)  //nBytes
				{
					alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
					beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
					AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
				}
				for(j=1;j<nBytes;j++)  //nBytes
				{
					w_xor_block[j] = (u8)_mm_popcnt_u64((xor_alpha_beta >> (j*8)));
				}

				carry[0] = 0;
				for(j=1;j<nBytes;j++)  //nBytes
				{
					carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
						+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
				}

					for(i0 = cDDT_wt_min[carry[0]][AB_block[0]];
							i0 <= cDDT_wt_min[carry[0]][AB_block[0]]; i0++) //cDDT_wt_max[carry[0]][AB_block[0]]
					{
						if(i0 + w_xor_block[1] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
					for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
					{
						gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
						//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
						carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB
					for(i1 = cDDT_wt_min[carry[1]][AB_block[1]];
							i1 <= cDDT_wt_min[carry[1]][AB_block[1]]; i1++) //cDDT_wt_max[carry[1]][AB_block[1]]
					{
						w1 = i0 + i1;
						if(w1 + w_xor_block[2] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
					for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
					{
						gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
						//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
						carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB
					for(i2 = cDDT_wt_min[carry[2]][AB_block[2]];
							i2 <= cDDT_wt_min[carry[2]][AB_block[2]];i2++) // cDDT_wt_max[carry[2]][AB_block[2]];
					{
						w2 = w1 + i2;
						if(w2 + w_xor_block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
					for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
					{
						gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
						//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
						carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB
					for(i3 = cDDT_wt_min[carry[3]][AB_block[3]];
							i3 <= cDDT_wt_min[carry[3]][AB_block[3]]; i3++) //cDDT_wt_max[carry[3]][AB_block[3]]
					{
						w3 = w2 + i3;
						if(w3 + w_xor_block[4] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.

					for(j3=0; j3 < cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
					{
						gamma_bloc[3] = cDDT_v[carry[3]][AB_block[3]][i3][j3];
						//carry[4] = ((alpha_bloc[3] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[3] >> 7) << 1)   //beta MSB
						carry[4] = carry_tmp[4] + (gamma_bloc[3] >> 7); // gamma MSB
					for(i4 = cDDT_wt_min[carry[4]][AB_block[4]];
							i4 <= cDDT_wt_min[carry[4]][AB_block[4]]; i4++) //cDDT_wt_max[carry[4]][AB_block[4]]
					{
						w4 = w3 + i4;
						if(w4 + w_xor_block[5] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
					for(j4=0; j4 < cDDT_n[carry[4]][AB_block[4]][i4]; j4++)
					{
						gamma_bloc[4] = cDDT_v[carry[4]][AB_block[4]][i4][j4];
						//carry[5] = ((alpha_bloc[4] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[4] >> 7) << 1)   //beta MSB
						carry[5] = carry_tmp[5] + (gamma_bloc[4] >> 7); // gamma MSB
					for(i5 = MSB_cDDT_wt_min[carry[5]][AB_block[5]];
							i5 <= MSB_cDDT_wt_min[carry[5]][AB_block[5]]; i5++) //MSB_cDDT_wt_max[carry[5]][AB_block[5]];
					{
						w5 = w4 + i5;
						if(w5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
						P_w[search_round] = w5; //Speck_XDP_compute(Alpha, Beta, gamma_temp);
					for(j5=0; j5 < MSB_cDDT_n[carry[5]][AB_block[5]][i5]; j5++)
					{
						gamma_bloc[5] = MSB_cDDT_v[carry[5]][AB_block[5]][i5][j5];
						gamma_temp = (gamma_bloc[5] << 40) | (gamma_bloc[4] << 32)
								| (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
								| (gamma_bloc[1] <<8) | gamma_bloc[0];

						if (P_w[search_round] == w_cmp) //概率满足Matsui条件
						//if ((P_w[search_round] <= w_cmp) && (P_w[search_round] != 0))
						{
#if 1   //是否找到第一条最优路径就返回？
		//if( best == 1 )
		{
			best  = 1;
			n_P_bestofR_w[search_round] = Bn_w;
			n_x_in[search_round +1] = gamma_temp;  // output part of the r-th round..
			n_y_in[search_round +1] = gamma_temp ^ next_Beta_tmp;
			return 1;
		}
#endif
	    }}}}}}}}}}}}}
/*
//////////////贪婪算法////////////每一轮的都只是概率最大的分支,该相同概率下的分支会有很多,但是这里只搜了其中一条,因此,遍历
							///的总的分支数就是第1轮的输入组合分支数

							//xor_alpha_beta = Beta ^ Alpha ;
							//w_xor = HM_weight(xor_alpha_beta & ValueMax_Align);
							and_alpha_beta = Beta & Alpha;
							w_and = HM_weight(and_alpha_beta & ValueMax_Align);

							P_w[search_round] = w_xor + w_and;  // 00-->0;01,10-->1; 11-->0,概率的和
							if ( P_w[search_round] == w_cmp)
							{
							gamma_temp = xor_alpha_beta; // 00-->1; 01,10--->0;11-->1;的情况先不考虑,因此只贪婪的考虑SetA的情况.

							//best = sepck_round_r(search_round,cur_round +1,gamma_temp,Beta);
					#if 1   //是否找到第一条最优路径就返回？
						//if( best == 1 )
						{
							best  = 1;
							n_P_bestofR_w[search_round] = Bn_w;
							n_x_in[search_round +1] = gamma_temp;  // output part of the r-th round..
							n_y_in[search_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
							return 1;
						}
					#endif
							}
//////////////贪婪算法////////////
*/
////////////////////////////
#elif (SPECK_BYTE  == 128)  //SPECK-128
			for(j=0;j<nBytes;j++)  //nBytes
			{
				alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
				beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
				AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
			}

			for(j=1;j<nBytes;j++)  //nBytes
			{
				w_xor_block[j] = (u8)_mm_popcnt_u64((xor_alpha_beta >> (j*8)));
			}

			carry[0] = 0;
			for(j=1;j<nBytes;j++)  //nBytes
			{
				carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
					+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
			}

			for(i0 = cDDT_wt_min[carry[0]][AB_block[0]];
					i0 <= cDDT_wt_min[carry[0]][AB_block[0]]; i0++)  //cDDT_wt_max[carry[0]][AB_block[0]]
			{
				if(i0 + w_xor_block[1] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
			{
				gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
				//gamma_block_tmp[0] = gamma_bloc[0];
				//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
				//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
				carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB

			for(i1 = cDDT_wt_min[carry[1]][AB_block[1]];
					i1 <= cDDT_wt_min[carry[1]][AB_block[1]]; i1++)  //cDDT_wt_max[carry[1]][AB_block[1]]
			{
				w1 = i0 + i1;
				if(w1 + w_xor_block[2] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
			{
				gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
				//gamma_block_tmp[1] = gamma_bloc[1] << 8;
				//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
				//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
				carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

			for(i2 = cDDT_wt_min[carry[2]][AB_block[2]];
					i2 <= cDDT_wt_min[carry[2]][AB_block[2]]; i2++)  //cDDT_wt_max[carry[2]][AB_block[2]]
			{
				w2 = w1 + i2;
				if(w2 + w_xor_block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
			{
				gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
				//gamma_block_tmp[2] = gamma_bloc[2] << 16;
				//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
				//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
				carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB
			for(i3 = cDDT_wt_min[carry[3]][AB_block[3]];
					i3 <= cDDT_wt_min[carry[3]][AB_block[3]]; i3++)  //cDDT_wt_max[carry[3]][AB_block[3]]
			{
				w3 = w2 + i3;
				if(w3 + w_xor_block[4] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j3=0; j3 < cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
			{
				gamma_bloc[3] = cDDT_v[carry[3]][AB_block[3]][i3][j3];
				//gamma_block_tmp[3] = gamma_bloc[3] << 24;
				//carry[4] = ((alpha_bloc[3] >> 7) << 2) //alpha MSB
				//		+ ((beta_bloc[3] >> 7) << 1)   //beta MSB
				carry[4] = carry_tmp[4] + (gamma_bloc[3] >> 7); // gamma MSB

			for(i4 = cDDT_wt_min[carry[4]][AB_block[4]];
					i4 <= cDDT_wt_min[carry[4]][AB_block[4]]; i4++)  //cDDT_wt_max[carry[4]][AB_block[4]]
			{
				w4 = w3 + i4;
				if(w4 + w_xor_block[5] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j4=0; j4 < cDDT_n[carry[4]][AB_block[4]][i4]; j4++)
			{
				gamma_bloc[4] = cDDT_v[carry[4]][AB_block[4]][i4][j4];
				//gamma_block_tmp[4] = gamma_bloc[4] << 32;
				//carry[5] = ((alpha_bloc[4] >> 7) << 2) //alpha MSB
				//		+ ((beta_bloc[4] >> 7) << 1)   //beta MSB
				carry[5] = carry_tmp[5] + (gamma_bloc[4] >> 7); // gamma MSB

			for(i5 = cDDT_wt_min[carry[5]][AB_block[5]];
					i5 <= cDDT_wt_min[carry[5]][AB_block[5]]; i5++)  //cDDT_wt_max[carry[5]][AB_block[5]]
			{
				w5 = w4 + i5;
				if(w5 + w_xor_block[6] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j5=0; j5 < cDDT_n[carry[5]][AB_block[5]][i5]; j5++)
			{
				gamma_bloc[5] = cDDT_v[carry[5]][AB_block[5]][i5][j5];
				//gamma_block_tmp[5] = gamma_bloc[5] << 40;
				//carry[6] = ((alpha_bloc[5] >> 7) << 2) //alpha MSB
				//		+ ((beta_bloc[5] >> 7) << 1)   //beta MSB
				carry[6] = carry_tmp[6] + (gamma_bloc[5] >> 7); // gamma MSB

			for(i6 = cDDT_wt_min[carry[6]][AB_block[6]];
					i6 <= cDDT_wt_min[carry[6]][AB_block[6]]; i6++)  //cDDT_wt_max[carry[6]][AB_block[6]]
			{
				w6 = w5 + i6;
				if(w6 + w_xor_block[7] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j6=0; j6 < cDDT_n[carry[6]][AB_block[6]][i6]; j6++)
			{
				gamma_bloc[6] = cDDT_v[carry[6]][AB_block[6]][i6][j6];
				//gamma_block_tmp[6] = gamma_bloc[6] << 48;
				//carry[7] = ((alpha_bloc[6] >> 7) << 2) //alpha MSB
				//		+ ((beta_bloc[6] >> 7) << 1)   //beta MSB
				carry[7] = carry_tmp[7] + (gamma_bloc[6] >> 7); // gamma MSB

			for(i7 = MSB_cDDT_wt_min[carry[7]][AB_block[7]];
					i7 <= MSB_cDDT_wt_min[carry[7]][AB_block[7]]; i7++)  //MSB_cDDT_wt_max[carry[7]][AB_block[7]]
			{
				w7 = w6 + i7;
				if(w7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				P_w[search_round] = w7; //Speck_XDP_compute(Alpha, Beta, gamma_temp);
			for(j7=0; j7 < MSB_cDDT_n[carry[7]][AB_block[7]][i7]; j7++)
			{
				gamma_bloc[7] = MSB_cDDT_v[carry[7]][AB_block[7]][i7][j7];
//								gamma_temp = (gamma_bloc[7] << 56) | gamma_block_tmp[6]
//								| gamma_block_tmp[5] | gamma_block_tmp[4]
//								| gamma_block_tmp[3] | gamma_block_tmp[2]
//								| gamma_block_tmp[1] | gamma_bloc[0];
//
				gamma_temp = (gamma_bloc[7] << 56) | (gamma_bloc[6] << 48)
						| (gamma_bloc[5] << 40) | (gamma_bloc[4] << 32)
						| (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
						| (gamma_bloc[1] <<8) | gamma_bloc[0];

				if (P_w[search_round] == w_cmp) //概率满足Matsui条件
				{
	#if 1   //是否找到第一条最优路径就返回？
			//if( best == 1 )
			{
				best  = 1;
				n_P_bestofR_w[search_round] = Bn_w;
				n_x_in[search_round +1] = gamma_temp;  // output part of the r-th round..
				n_y_in[search_round +1] = gamma_temp ^ next_Beta_tmp;
				return 1;
			}
	#endif
				}
			}}}}}}}}}}}}}}}}

/*
//////////////贪婪算法////////////每一轮的都只是概率最大的分支,该相同概率下的分支会有很多,但是这里只搜了其中一条,因此,遍历
							///的总的分支数就是第1轮的输入组合分支数

							//xor_alpha_beta = Beta ^ Alpha ;
							//w_xor = HM_weight(xor_alpha_beta & ValueMax_Align);
							and_alpha_beta = Beta & Alpha;
							w_and = HM_weight(and_alpha_beta & ValueMax_Align);

							P_w[search_round] = w_xor + w_and;  // 00-->0;01,10-->1; 11-->0,概率的和
							if ( P_w[search_round] == w_cmp)
							{

							gamma_temp = xor_alpha_beta; // 00-->1; 01,10--->0;11-->1;的情况先不考虑,因此只贪婪的考虑SetA的情况.

							//best = sepck_round_r(search_round,cur_round +1,gamma_temp,Beta);
					#if 1   //是否找到第一条最优路径就返回？
						//if( best == 1 )
						{
							best  = 1;
							n_P_bestofR_w[search_round] = Bn_w;
							n_x_in[search_round +1] = gamma_temp;  // output part of the r-th round..
							n_y_in[search_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
							return 1;
						}
					#endif
//////////////贪婪算法////////////
*/
#endif
return  best;
}

u16 speck_round_N_diff(u16 search_round, u64 x, u64 y)
{
	u16 best = 0;
	u64 Alpha = 0;
	u64 Beta = 0;
	u64 Gamma_base = 0;
	u64 xor_alpha_beta = 0;
	u64 and_alpha_beta = 0;
	u16 w_xor = 0;
	u16 w_cmp = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 rol_left = 0;
	u64 rol_right = 0;
	u64 alpha_bloc[8] = {0};
	u64 beta_bloc[8] = {0};
	u64 gamma_bloc[8] = {0};
	u64 AB_block[8] = {0};
	u64 carry[8] ={0};
	u64 carry_tmp[8] ={0};
	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 gamma_temp = 0;


	rol_right = ((x) >> (rol_a)) | ((x) << (blocksize_len - rol_a)); //right
	rol_left = (((y) << rol_b) | ((y) >> (blocksize_len-rol_b)));
	Beta = (x ^ rol_left) & Bit_Align;
	Alpha = rol_right & Bit_Align; // alpha = gama_uper <<< rol_a;
	//Beta = x ^ (ROTATE_LEFT(y,rol_b,blocksize_len) & Bit_Align);
	//Alpha = (ROTATE_RIGHT(x,rol_a, blocksize_len)) & Bit_Align; // alpha = gama_uper <<< rol_a;
	xor_alpha_beta = (Beta ^ Alpha)  & ValueMax_Align;
	w_xor = HM_weight(xor_alpha_beta);

	for(i=1; i < search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}

	w_cmp = wt_max - p_sumof_r;
	if (w_xor > w_cmp)
	{
		return 0;
	}


	switch(sc_blocksize)
		{
		case 32:
			//m0
			alpha_bloc[0] = (Alpha) & 0xFF; //8 bit
			beta_bloc[0]  = (Beta) & 0xFF; //8 bit
			AB_block[0] = (alpha_bloc[0] << 8) | beta_bloc[0];
			carry[0] = 0;
			//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
			//m1
			alpha_bloc[1]= (Alpha >> 8) & 0xFF; //8 bit
			beta_bloc[1] = ( Beta >> 8) & 0xFF; //8 bit
			AB_block[1] = (alpha_bloc[1] << 8) | beta_bloc[1];


			for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
			{
				if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
			{
				gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
				carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
						+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
						+ (gamma_bloc[0] >> 7); // gamma MSB
			for(i1 = 0; i1 <= MSB_cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
			{
				if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j1=0; j1 < MSB_cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
			{
				gamma_bloc[1] = MSB_cDDT_v[carry[1]][AB_block[1]][i1][j1];
				gamma_temp = (gamma_bloc[1] <<8) | gamma_bloc[0];

				if((gamma_temp & Bit_Align)== output_diff_L) //gamma等于输出差分的左半边
				{
					if((gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align)) ==output_diff_R) //右半边
					{
						count++;
						P_w[search_round] = i0 + i1;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
						Bn_w = p_sumof_r + P_w[search_round] ;
						printf("count: %d    weight: %d \n",count,Bn_w);
						wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
						//if(Bn_w >= wt_ctr_max)
						//	wt_ctr_max = Bn_w;
					}
				}
			}
			}
			}
			}
			return 1;
			break;
		case 48:
			for(j=0;j<nBytes;j++)  //nBytes
				{
					alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
					beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
					AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
				}
				carry[0] = 0;
				for(j=1;j<nBytes;j++)  //nBytes
				{
					carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
								+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
				}
//#pragma omp parallel for
					for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
					{
						if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
					for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
					{
						gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
						//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
						carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB
					for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
					{
						if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
					for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
					{
						gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
						//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
						carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

					for(i2 = 0; i2 <= MSB_cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
					{
						if(i0 + i1 +i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
					for(j2=0; j2 < MSB_cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
					{
						gamma_bloc[2] = MSB_cDDT_v[carry[2]][AB_block[2]][i2][j2];
						gamma_temp = (gamma_bloc[2] << 16) | (gamma_bloc[1] <<8) | gamma_bloc[0];

						if((gamma_temp & Bit_Align)== output_diff_L) //gamma等于输出差分的左半边
						{
							if((gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align)) ==output_diff_R) //右半边
							{
								count++;
								P_w[search_round] = i0 + i1 + i2;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
								Bn_w = p_sumof_r + P_w[search_round] ;
								printf("count: %d    weight: %d \n",count,Bn_w);
								wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
								if(Bn_w >= wt_ctr_max)
									wt_ctr_max = Bn_w;
							}
						}
					}
					}
					}
					}
					}
					}
					return 1;
			break;
		case 64:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
				beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
				AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
			}
			carry[0] = 0;
			for(j=1;j<nBytes;j++)  //nBytes
			{
				carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
							+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
			}

			for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
					{
						if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
					for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
					{
						gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
						//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
						carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB

					for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
					{
						if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
					for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
					{
						gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
						//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
						carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

					for(i2 = 0; i2 <= cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
					{
						if(i0 + i1 +i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
					for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
					{
						gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
						//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
						//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
						carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB

					for(i3 = 0; i3 <= MSB_cDDT_wt_max[carry[3]][AB_block[3]]; i3++)
					{
						if(i0 + i1 +i2 +i3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
					for(j3=0; j3 < MSB_cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
					{
						gamma_bloc[3] = MSB_cDDT_v[carry[3]][AB_block[3]][i3][j3];
						gamma_temp = (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
								   | (gamma_bloc[1] <<8) | gamma_bloc[0];

						if((gamma_temp & Bit_Align)== output_diff_L) //gamma等于输出差分的左半边
						{
							if((gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align)) ==output_diff_R) //右半边
							{
								count++;
								P_w[search_round] = i0 + i1 +i2 +i3;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
								Bn_w = p_sumof_r + P_w[search_round] ;
								printf("count: %d    weight: %d \n",count,Bn_w);
								wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
								if(Bn_w >= wt_ctr_max)
									wt_ctr_max = Bn_w;
							}
						}
					}
					}
					}
					}
					}
					}
					}
					}
			break;
		case 96:
			for(j=0;j<nBytes;j++)  //nBytes
					{
						alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
						beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
						AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
					}
					carry[0] = 0;
					for(j=1;j<nBytes;j++)  //nBytes
					{
						carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
									+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
					}

					for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
							{
								if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
							for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
							{
								gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
								//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
								//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
								carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB
							for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
							{
								if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
							for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
							{
								gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
								//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
								//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
								carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB
							for(i2 = 0; i2 <= cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
							{
								if(i0 + i1 +i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
							for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
							{
								gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
								//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
								//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
								carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB
							for(i3 = 0; i3 <= cDDT_wt_max[carry[3]][AB_block[3]]; i3++)
							{
								if(i0 + i1 +i2 +i3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
							for(j3=0; j3 < cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
							{
								gamma_bloc[3] = cDDT_v[carry[3]][AB_block[3]][i3][j3];
								//carry[4] = ((alpha_bloc[3] >> 7) << 2) //alpha MSB
								//		+ ((beta_bloc[3] >> 7) << 1)   //beta MSB
								carry[4] = carry_tmp[4] + (gamma_bloc[3] >> 7); // gamma MSB
							for(i4 = 0; i4 <= cDDT_wt_max[carry[4]][AB_block[4]]; i4++)
							{
								if(i0 + i1 +i2 +i3 +i4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
							for(j4=0; j4 < cDDT_n[carry[4]][AB_block[4]][i4]; j4++)
							{
								gamma_bloc[4] = cDDT_v[carry[4]][AB_block[4]][i4][j4];
								//carry[5] = ((alpha_bloc[4] >> 7) << 2) //alpha MSB
								//		+ ((beta_bloc[4] >> 7) << 1)   //beta MSB
								carry[5] = carry_tmp[5] + (gamma_bloc[4] >> 7); // gamma MSB
							for(i5 = 0; i5 <= MSB_cDDT_wt_max[carry[5]][AB_block[5]]; i5++)
							{
								if(i0 + i1 +i2 +i3 +i4 +i5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
							for(j5=0; j5 < MSB_cDDT_n[carry[5]][AB_block[5]][i5]; j5++)
							{
								gamma_bloc[5] = MSB_cDDT_v[carry[5]][AB_block[5]][i5][j5];
								gamma_temp = (gamma_bloc[5] << 40) | (gamma_bloc[4] << 32)
										| (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
										| (gamma_bloc[1] <<8) | gamma_bloc[0];

								if((gamma_temp & Bit_Align)== output_diff_L) //gamma等于输出差分的左半边
								{
									if((gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align)) ==output_diff_R) //右半边
									{
										count++;
										P_w[search_round] = i0 + i1 +i2 +i3 +i4 +i5;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
										Bn_w = p_sumof_r + P_w[search_round] ;
										printf("count: %d    weight: %d \n",count,Bn_w);
										wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
										if(Bn_w >= wt_ctr_max)
											wt_ctr_max = Bn_w;
									}
								}
							}
							}
							}
							}
							}
							}
							}
							}
							}
							}
							}
							}
					break;
		case 128:
			for(j=0;j<nBytes;j++)  //nBytes
					{
						alpha_bloc[j] = (Alpha >> (8*j)) & 0xFF; //8 bit
						beta_bloc[j]  = (Beta >> (8*j))  & 0xFF; //8 bit
						AB_block[j] = ((alpha_bloc[j] << 8) | beta_bloc[j]);
					}
					carry[0] = 0;
					for(j=1;j<nBytes;j++)  //nBytes
					{
						carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
									+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
					}

					for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
							{
								if(i0 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
							for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
							{
								gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
								//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
								//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
								carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB

							for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
							{
								if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
							for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
							{
								gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
								//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
								//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
								carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

							for(i2 = 0; i2 <= cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
							{
								if(i0 + i1 +i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
							for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
							{
								gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
								//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
								//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
								carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB
							for(i3 = 0; i3 <= cDDT_wt_max[carry[3]][AB_block[3]]; i3++)
							{
								if(i0 + i1 +i2 +i3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
							for(j3=0; j3 < cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
							{
								gamma_bloc[3] = cDDT_v[carry[3]][AB_block[3]][i3][j3];
								//carry[4] = ((alpha_bloc[3] >> 7) << 2) //alpha MSB
								//		+ ((beta_bloc[3] >> 7) << 1)   //beta MSB
								carry[4] = carry_tmp[4] + (gamma_bloc[3] >> 7); // gamma MSB

							for(i4 = 0; i4 <= cDDT_wt_max[carry[4]][AB_block[4]]; i4++)
							{
								if(i0 + i1 +i2 +i3 +i4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
							for(j4=0; j4 < cDDT_n[carry[4]][AB_block[4]][i4]; j4++)
							{
								gamma_bloc[4] = cDDT_v[carry[4]][AB_block[4]][i4][j4];
								//carry[5] = ((alpha_bloc[4] >> 7) << 2) //alpha MSB
								//		+ ((beta_bloc[4] >> 7) << 1)   //beta MSB
								carry[5] = carry_tmp[5] + (gamma_bloc[4] >> 7); // gamma MSB

							for(i5 = 0; i5 <= cDDT_wt_max[carry[5]][AB_block[5]]; i5++)
							{
								if(i0 + i1 +i2 +i3 +i4 +i5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
							for(j5=0; j5 < cDDT_n[carry[5]][AB_block[5]][i5]; j5++)
							{
								gamma_bloc[5] = cDDT_v[carry[5]][AB_block[5]][i5][j5];
								//carry[6] = ((alpha_bloc[5] >> 7) << 2) //alpha MSB
								//		+ ((beta_bloc[5] >> 7) << 1)   //beta MSB
								carry[6] = carry_tmp[6] + (gamma_bloc[5] >> 7); // gamma MSB

							for(i6 = 0; i6 <= cDDT_wt_max[carry[6]][AB_block[6]]; i6++)
							{
								if(i0 + i1 +i2 +i3 +i4 +i5 +i6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
							for(j6=0; j6 < cDDT_n[carry[6]][AB_block[6]][i6]; j6++)
							{
								gamma_bloc[6] = cDDT_v[carry[6]][AB_block[6]][i6][j6];
								//carry[7] = ((alpha_bloc[6] >> 7) << 2) //alpha MSB
								//		+ ((beta_bloc[6] >> 7) << 1)   //beta MSB
								carry[7] = carry_tmp[7] + (gamma_bloc[6] >> 7); // gamma MSB

							for(i7 = 0; i7 <= MSB_cDDT_wt_max[carry[7]][AB_block[7]]; i7++)
							{
								if(i0 + i1 +i2 +i3 +i4 +i5 +i6 +i7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
							for(j7=0; j7 < MSB_cDDT_n[carry[7]][AB_block[7]][i7]; j7++)
							{
								gamma_bloc[7] = MSB_cDDT_v[carry[7]][AB_block[7]][i7][j7];
								gamma_temp = (gamma_bloc[7] << 56) | (gamma_bloc[6] << 48)
										| (gamma_bloc[5] << 40) | (gamma_bloc[4] << 32)
										| (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
										| (gamma_bloc[1] <<8) | gamma_bloc[0];

							if((gamma_temp & Bit_Align)== output_diff_L) //gamma等于输出差分的左半边
							{
								if((gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align)) ==output_diff_R) //右半边
								{
									count++;
									P_w[search_round] = i0 + i1 +i2 +i3 +i4 +i5 +i6 +i7;  //Speck_XDP_compute(Alpha, Beta, gamma_temp);
									Bn_w = p_sumof_r + P_w[search_round] ;
									printf("count: %d    weight: %d \n",count,Bn_w);
									wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
									if(Bn_w >= wt_ctr_max)
										wt_ctr_max = Bn_w;
								}
							}
							}
							}
							}
							}
							}
							}
							}
							}
							}
							}
							}
							}
							}
							}
							}
							}
			break;
		default:
			break;
		}
	return  best;
}



/*
u16 speck_N_gamma_xor_inc(u16 search_round, u16 cur_round,
		u64 Alpha, u64 Beta, u64 Gamma,
		u16 curr_wt_xor,u16 wt_xor, u16 *xor_sub_1,
		u16 wt_and,u16 *and_sub_1,
		u16 wt_or,u16 *or_sub_1,
		u16 wt_cmp)
{
	u16 state = 0;
	u16 j = 0;
	u64 gamma_temp = 0;

	if(curr_wt_xor < wt_xor)
	{
		for(j=0; j < 2;j++ )
		{
			if(j != 0)
			{
				gamma_temp = (Gamma | (1 << xor_sub_1[curr_wt_xor])) ;
			}
			else
			{
				gamma_temp = (Gamma & (~(1 << xor_sub_1[curr_wt_xor]))) ;  // & Bit_Align;
			}

			state = speck_N_gamma_xor_inc(search_round, cur_round,
					Alpha, Beta, gamma_temp,
					curr_wt_xor + 1, wt_xor, xor_sub_1,
					wt_and, and_sub_1,
					wt_or, or_sub_1,
					wt_cmp);
#if 1   //是否找到第一条最优路径就返回？
if(state==1)
return state;
#endif
		}
	}
	else //Call infection function.
	{
		state = speck_N_gamma_and_inc(search_round, cur_round,
				Alpha, Beta, Gamma,
				wt_xor, xor_sub_1,
				wt_and, and_sub_1,
				wt_or, or_sub_1,
				wt_cmp);
#if 1   //是否找到第一条最优路径就返回？
if(state == 1)
	return state;
#endif
	}
	return state;
}

u16 speck_N_gamma_and_inc(u16 search_round, u16 cur_round,
		u64 Alpha, u64 Beta, u64 Gamma,
		u16 wt_xor, u16 *xor_sub_1,
		u16 wt_and,u16 *and_sub_1,
		u16 wt_or,u16 *or_sub_1,
		u16 wt_cmp)
{
	u16 state = 0;
	u16 i = 0;
	u16 j = 0;
	u16 and_sub_1_cmb = 0;
	u16 infect_wt = 0;
	//char infect_position[65536] = {0};  ////太小,当分组长度较大时候,且感染位增多时,组合数太多.
	char *infect_position = (char *)malloc(3042312352 * sizeof(char));  // 65536 // //1073741824
	u64 gamma_temp = 0;
	u16 bit_index = 0;

	for(infect_wt = 0; infect_wt <= wt_and; infect_wt++) // infected and-bit.
	{
		if ( wt_xor + infect_wt > wt_cmp)
		{
			free(infect_position );
			return 0;
		}

		if(infect_wt > 0) // 感染比特位置,通过排列组合选择
		{
			//组合生成gamma
			//首先确定当感染比特位置数量为infect_wt时,可能感染不同位置的模式的种数and_sub_1_cmb.
			and_sub_1_cmb = Combination_cal( infect_wt, wt_and, infect_position );

			for( i =0; i< and_sub_1_cmb;i++) //对于每一种infect_wt下的模式都生成对应gamma.
			{
				gamma_temp = Gamma;
				for(j=1; j <= infect_wt; j++) //每种感染模式下,对于每个感染比特
				{
					bit_index = and_sub_1[(u64)infect_position[i * infect_wt + j] -1];
					gamma_temp = gamma_temp & (~(1 << bit_index));
				}

				state = speck_gamma_or_inc(search_round, cur_round,
						Alpha, Beta, gamma_temp,
						wt_xor, xor_sub_1,
						infect_wt, and_sub_1,
						wt_or,or_sub_1,
						wt_cmp);
#if 1   //是否找到第一条最优路径就返回？
			if( state == 1 )
			{
				free(infect_position );
				return 1;
			}
#endif
			}
		}
		else // 无and-bit感染比特位置,直接跳转查看or-bit感染位置
		{
			state = speck_N_gamma_or_inc(search_round, search_round,
					Alpha, Beta, Gamma,
					wt_xor, xor_sub_1,
					infect_wt, and_sub_1,
					wt_or,or_sub_1,
					wt_cmp);
#if 1   //是否找到第一条最优路径就返回？
	if( state == 1 )
	{
		free(infect_position );
		return 1;
	}
#endif
		}
	}
	free(infect_position );
	return state;
}


u16 speck_N_gamma_or_inc(u16 search_round, u16 cur_round,
		u64 Alpha, u64 Beta, u64 Gamma,
		u16 wt_xor, u16 *xor_sub_1,
		u16 wt_and,u16 *and_sub_1,
		u16 wt_or,u16 *or_sub_1,
		u16 wt_cmp)
{
	u16 state = 0;
	u16 i = 0;
	u16 j = 0;
	u16 or_sub_1_cmb = 0;
	u16 infect_wt = 0;
	//char infect_position[65536] = {0};  ////太小,当分组长度较大时候,且感染位增多时,组合数太多.
	char *infect_position = (char *)malloc(3042312352 * sizeof(char)); // 65536
	u64 gamma_temp = 0;
	u16 bit_index = 0;


	for(infect_wt = 0; infect_wt <= wt_or; infect_wt++) // infected and-bit.
	{
		if ( wt_xor + wt_and + infect_wt > wt_cmp)
		{
			free(infect_position );
			return 0;
		}

		if(infect_wt > 0) // 感染比特位置,通过排列组合选择
		{
			//组合生成gamma
			//首先确定当感染比特位置数量为infect_wt时,可能感染不同位置的模式的种数and_sub_1_cmb.
			or_sub_1_cmb = Combination_cal( infect_wt, wt_or, infect_position );

			for( i =0; i< or_sub_1_cmb;i++) //对于每一种infect_wt下的模式都生成对应gamma.
			{
				gamma_temp = Gamma;
				for(j=1; j <= infect_wt; j++) //每种感染模式下,对于每个感染比特
				{
					bit_index = or_sub_1[(u64)infect_position[i * infect_wt + j] -1];
					gamma_temp = gamma_temp | (1 << bit_index);
				}

				//判断组合生成的这个gamma是否是有效的.
				if ( wt_xor + wt_and + infect_wt == wt_cmp)
				{
				if( (Speck_XDP_validcheck(Alpha,Beta,gamma_temp )& Bit_Align) == 0) //如有效则进行下一轮.
				{
					P_w[cur_round] = wt_xor + wt_and+ infect_wt;
					state = 1; //sepck_round_r(search_round,cur_round+1,gamma_temp,Beta);
					n_x_in[cur_round +1] = gamma_temp;  // left output part of the r-th round..
					n_y_in[cur_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
					n_P_bestofR_w[search_round] = Bn_w;
					free(infect_position );
					return 1;
				}
				}
			}
		}
		else // 无or-bit感染比特位置,直接跳转查看or-bit感染位置
		{
			if ( wt_xor + wt_and + infect_wt == wt_cmp)
			{
				if((Speck_XDP_validcheck(Alpha,Beta,Gamma) & Bit_Align) == 0) //如有效则进行下一轮.
				{
					P_w[cur_round] = wt_xor + wt_and + infect_wt;
					state = 1;  //sepck_round_r(search_round,cur_round+1,Gamma,Beta);
					n_x_in[cur_round +1] = Gamma;  // left output part of the r-th round..
					n_y_in[cur_round +1] = Gamma ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
					n_P_bestofR_w[search_round] = Bn_w;
					free(infect_position );
					return 1;
				}
			}
		}
	}
	free(infect_position );
	return state;
}

u16 speck_N_gamma_and_or_inc(u16 search_round, u16 cur_round,
		u64 Alpha, u64 Beta, u64 Gamma,
		u16 wt_xor, u16 *xor_sub_1,
		u16 wt_and,u16 *and_sub_1,
		u16 and_or_sub_1_num,u16 *and_or_sub_1,
		u16 wt_cmp)
{
	u16 state = 0;
	u64 i = 0;
	u16 j = 0;
	u16 g = 0;
	u16 bit_index = 0;
	u64 and_sub_1_cmb = 0;
	u64 infect_wt = 0;
	//char infect_position[65536] = {0};
	char *infect_position = (char *)malloc(3042312352* sizeof(char));
	u64 gamma_temp = 0;
	u16 AND_FLAG = 0;

	for(infect_wt = 0; infect_wt <= and_or_sub_1_num; infect_wt++)
	{
		if ( wt_xor + infect_wt > wt_cmp)
		{
			free(infect_position );
			return 0;
		}

		if(infect_wt > 0) // 感染比特位置,分两种感染方法.
		{
			if ( wt_xor + infect_wt == wt_cmp)
			{
			//组合生成gamma,确定最后一轮的输出差分
			//首先确定当感染比特位置数量为infect_wt时,可能感染不同位置的模式的种数and_sub_1_cmb.
			and_sub_1_cmb = Combination_cal( infect_wt, and_or_sub_1_num, infect_position );

			for( i =0; i< and_sub_1_cmb;i++) //对于每一种infect_wt下的模式都生成对应gamma.
			{
				gamma_temp = Gamma;

				for(j=1; j <= infect_wt; j++) //每种感染模式下,对于每个感染比特
				{
					AND_FLAG = 0;
					bit_index = and_or_sub_1[(u64)infect_position[i * infect_wt + j] - 1];
					for(g=0; g < wt_and; g++) //判断每个感染比特的位置是否对应alpha和beta相与为1的位置.
					{
						if(and_sub_1[g] == bit_index)//若该比特对应alpha和beta相与为1.
						{
							gamma_temp = gamma_temp & (~(1 << and_sub_1[g]));
							AND_FLAG = 1;
						}
					}

					if(AND_FLAG == 0)
					{
						gamma_temp = gamma_temp | (1 << bit_index);
					}
				}


				//判断组合生成的这个gamma是否是有效的.
				//if(Speck_XDP_validcheck(Alpha&Bit_Align,Beta&Bit_Align,gamma_temp&Bit_Align ) == 0) //如有效则进行下一轮.
				//判断组合生成的这个gamma是否是有效的.
				if( (Speck_XDP_validcheck(Alpha,Beta,gamma_temp )& Bit_Align) == 0) //如有效则进行下一轮.
				{
					P_w[cur_round] = wt_xor + infect_wt;
					state = 1; //sepck_round_r(search_round,cur_round+1,gamma_temp,Beta);
					n_x_in[cur_round +1] = gamma_temp;  // left output part of the r-th round..
					n_y_in[cur_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
					n_P_bestofR_w[search_round] = Bn_w;
					free(infect_position );
					return 1;
				}
				//printf("gamma_temp : %x  \n", gamma_temp);
				}
			}
		}
		else // 无感染比特位置,直接跳转下一轮
		{
			if ( wt_xor + infect_wt == wt_cmp)
			{
				if((Speck_XDP_validcheck(Alpha,Beta,Gamma) & Bit_Align) == 0) //如有效则进行下一轮.
				{
					P_w[cur_round] = wt_xor + infect_wt;
					state = 1;  //sepck_round_r(search_round,cur_round+1,Gamma,Beta);
					n_x_in[cur_round +1] = Gamma;  // left output part of the r-th round..
					n_y_in[cur_round +1] = Gamma ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
					n_P_bestofR_w[search_round] = Bn_w;
					free(infect_position );
					return 1;
				}
			}
		}
	}
	free(infect_position );
	return state;
}

u16 speck_gamma_combine_last(u16 curr_sub,u16 sub_1_num, u16 *sub_1,
		u16 curr_sub_0,u16 sub_0_num, u16 *sub_0,
		u16 search_round, u16 cur_round, u64 Alpha, u64 Beta, u64 Gamma,u16 sum_wt_bf,u16 P_N)
{
	u16 state = 0;
	u16 gamma_j = 0;
	u64 gamma_temp = 0;
	u16 pro = 0;


	if(sub_1_num == 0) // Call next round.
	{
		if(Speck_XDP_validcheck(Alpha,Beta,Gamma ) == 0 )
		{
			pro = Speck_XDP_compute(Alpha,Beta,Gamma );
			if(sum_wt_bf + pro == Bn_w )  //pro
			{
				P_w[cur_round] = pro; //P_N;  // Speck_XDP_compute(Alpha,Beta,gamma_temp );
				n_P_bestofR_w[search_round] = Bn_w;
				n_x_in[search_round +1] = Gamma;  // left output part of the last round..
				n_y_in[search_round +1] = Gamma ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
				return 1;
			}
		}

		state = speck_gamma_wt_inc_last( curr_sub_0, sub_0_num, sub_0,
						search_round, cur_round, Alpha, Beta, Gamma,sum_wt_bf,P_N);
#if 1   //是否找到第一条最优路径就返回？
		if( state == 1 )
		{
			return 1;
		}
#endif
	}
	else {
	if(sub_1_num == (curr_sub + 1)) // Call next round.
	{
		for(gamma_j=0; gamma_j < 2;gamma_j++ )
		{
			if(gamma_j != 0)
			{
				gamma_temp = (Gamma ^ (1 << sub_1[curr_sub])) & Bit_Align;
			}
			else
			{
				gamma_temp = (Gamma); // & Bit_Align;
			}

			if(Speck_XDP_validcheck(Alpha,Beta,gamma_temp ) == 0 )
			{
				pro = Speck_XDP_compute(Alpha,Beta,gamma_temp );
				if(sum_wt_bf + pro == Bn_w )  //pro
				{
					P_w[cur_round] = pro;  //P_N; // Speck_XDP_compute(Alpha,Beta,gamma_temp );
					n_P_bestofR_w[search_round] = Bn_w;
					n_x_in[search_round +1] = gamma_temp;  // left output part of the last round..
					n_y_in[search_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
					return 1;
				}
			}

			if( sub_0_num > 0 )
			{
				state = speck_gamma_wt_inc_last( curr_sub_0, sub_0_num, sub_0,
							search_round, cur_round, Alpha, Beta, gamma_temp,sum_wt_bf,P_N);
#if 1   //是否找到第一条最优路径就返回？
			if( state == 1 )
			{
				return 1;
			}
#endif
			}
		}
	}
	else // Call next speck_gamma_base_combine.
	{
		for(gamma_j=0; gamma_j < 2;gamma_j++ )
		{
			if(gamma_j != 0)  // bit = 1.
			{
				gamma_temp = (Gamma ^ (1 << sub_1[curr_sub])) & Bit_Align;
			}
			else
			{
				gamma_temp = (Gamma); // & Bit_Align;
			}

			state = speck_gamma_combine_last(curr_sub+1,sub_1_num, sub_1,
					0,sub_0_num, sub_0,
					search_round,cur_round,Alpha, Beta, gamma_temp,sum_wt_bf,P_N);
			if(state == 1)
			{
				return state;
			}
		}
	}
	}
	return 0;
}


u16 speck_gamma_wt_inc_last(u16 curr_sub_0,u16 sub_0_num, u16 *sub_0,
u16 search_round, u16 cur_round, u64 Alpha, u64 Beta, u64 Gamma,u16 sum_wt_bf,u16 P_N)
{

	u16 state = 0;
	u64 gamma_temp = 0;
	u16 pro =0;


	if ((sum_wt_bf + P_N + (curr_sub_0 +1)
			+ n_P_bestofR_w[search_round - cur_round]) > Bn_w)
		{
			return 0;
		}

	gamma_temp = (Gamma ^ (1 << sub_0[curr_sub_0])) & Bit_Align; // gamma different to alpha and beta in this position.

	if(Speck_XDP_validcheck(Alpha,Beta,gamma_temp ) == 0)
	{
		pro = Speck_XDP_compute(Alpha,Beta,gamma_temp );

		if((sum_wt_bf + pro ) == Bn_w )  // P_N + (curr_sub_0 +1)
		{
			P_w[cur_round] = pro; // P_N + (curr_sub_0 +1);  //Speck_XDP_compute(Alpha,Beta,gamma_temp ); //P_r + curr_sub_0 +1;
			n_P_bestofR_w[search_round] = Bn_w;
			n_x_in[search_round +1] = gamma_temp;   // left output part of the last round.
			n_y_in[search_round +1] = gamma_temp ^ (ROTATE_LEFT(Beta, rol_b,blocksize_len) & Bit_Align);
			return 1;
		}
	}

	if( sub_0_num  > curr_sub_0+1)
	{
		state = speck_gamma_wt_inc(curr_sub_0 + 1, sub_0_num, sub_0,
			search_round, cur_round, Alpha, Beta, gamma_temp,sum_wt_bf,P_N);
#if 1   //是否找到第一条最优路径就返回？
	if( state == 1 )
	{
		return 1;
	}
#endif
	}
return state;
}
u16 round_N_sepck(u16 search_round,u16 cur_round, u16 bit_position, u64 input_a, u64 input_b, u64 output_c)
{
	u16 i =0;
	u16 best = 0;
	u16 bit_abc =0;
	u16 bit_a =0;
	u16 bit_b =0;
	u16 bit_c =0;

	u16 p_r =0;
	u64 input_a_next = 0;
	u64 input_b_next = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 input_a_tmp = 0;
	u64 input_b_tmp = 0;
	u64 input_c_tmp = 0;


	if( bit_position ==  (blocksize_len -1))
	{
		P_sepck[cur_round] = xdp_speck(input_a, input_b,output_c);  // output_c
		n_x_in[cur_round] = input_a;
		n_y_in[cur_round] = input_b;
		input_a_next = RIGHT_rotation_64(output_c,rol_a,blocksize_len);
		input_b_next = LEFT_rotation_64( input_b, rol_b,blocksize_len) ^ output_c;

		//P_sepck[cur_round] = xdp_speck(0x8000, 0x40,0x8040);  // output_c
		//printf("P_sepck[]: %d \n",P_sepck[cur_round]);  // write.

		for(i=1;i<cur_round;i++)
		{
			p_sumof_r += P_sepck[i]; // p_sumof_r is the sum of r-1 rounds weight.
		}
		if ((p_sumof_r + P_sepck[cur_round] ) == Bn_w)
		{
			Bn_w  = p_sumof_r + P_sepck[cur_round] ;  // update bound.
			n_P_bestofR_w[search_round] = Bn_w;
			best = 1;

			printf("succccccccccccccccccesss \n");

#if 1   //是否找到第一条最优路径就返回？
			if(best == 1)
				return best;
#endif
		}
		else
		{
			return 0;
		}
		//round_1_sepck(search_round, cur_round+1, 0, input_a_next, input_b_next, 0);//next round.
	}
	else
	{
		for(bit_c=0; bit_c < 2; bit_c++)
		{
			//bit_a = bit_abc & 4;
			//bit_b = bit_abc & 2;
			//bit_c = bit_abc & 1;

			if(bit_c != 0)
			{
				input_c_tmp = output_c ^ (u64)(1 << bit_position );
			}

			for(i=0; i< bit_position; i++)
			{
				input_a_tmp ^= (input_a & (u64)pow(2,i));
				input_b_tmp ^= (input_b & (u64)pow(2,i));
			}

			p_r = xdp_speck(input_a_tmp, input_b_tmp,input_c_tmp);
			for(i=1;i<cur_round;i++)
			{
				p_sumof_r += P_sepck[i]; // p_sumof_r is the sum of r-1 rounds weight.
			}

			if ((p_sumof_r + p_r ) <= Bn_w)
			{
				best = round_N_sepck(search_round, search_round, bit_position+1, input_a, input_b, output_c  );//next bit position.

#if 1   //是否找到第一条最优路径就返回？
				if(best == 1)
					return 1;
#endif
			}
		}
	}
	return best;
}
*/

u16 sepck_differential_trail_search_entry (u16 search_round)
{
	speck_best_Bn = fopen ("../tmp/speck_best_Bn_wt.xlsx", "a+"); //  "w+"); //
	u16 i = 0;


	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 state = 0;


	bit_align_fun();
	ARX_carry_DDTm_construct();

	time_ARX_DDT = clock();
	run_time =  (time_ARX_DDT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct ARX_DDT: %.2f seconds.  \n", run_time);

	Bn_w = 0;
	if(search_round > 2)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(speck_best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		Bn_w = n_P_bestofR_w[search_round-1] - 1;
	}

//	Bn_w = 47;  //直接设定开始的概率重量,快速达到期望的概率重量
	do
	{
		Bn_w = Bn_w + 1;
		printf("Searching Bn_w: %d \n", Bn_w);

		/*
/////////////////////////////固定第1轮的输入输出差分///////////////////////////
		//Input_alpha = 0x000000000080;  //speck96--wt=0--1
		//Input_beta  = 0x000000000000;
		//Input_gamma = 0x800000000000;
		//Input_alpha = 0x000000000080;  //speck96--wt=0--2
		//Input_beta  = 0x800000000000;
		//Input_gamma = 0x000000000000;
		  Input_alpha = 0x000000000000;  //speck96--wt=0--3
		  Input_beta  = 0x800000000000;
		  Input_gamma = 0x800000000000;
		*/

/*
		if (Bn_w >= 21)
		{
		 	printf(" Forward=================>>>>>>>>>>>   \n");   // & Bit_Align
			Input_alpha = 0x400000924000;
			Input_beta  = 0x400000104200;
			Input_gamma = 0x000000820200;
			P_w[1] = 6;  //pro;

		 	//state = sepck_round_r(search_round, 2,Input_gamma ,Input_gamma ^ (ROTATE_LEFT(Input_beta, rol_b,blocksize_len) & Bit_Align));
			state = sepck_round_r(search_round,2,0x000000820200,0x000000001202);
			if(state != 0 )
			{
				n_x_in[1] = 0x000092400040;
				n_y_in[1] = 0x400000104200;
				n_x_in[2 ] = 0x000000820200;
				n_y_in[2 ] = 0x000000820200 ^ (ROTATE_LEFT(Input_beta, rol_b,blocksize_len) & Bit_Align);

				break;
			}
		}
*/

		// Search Entry of speck.
		sepck_round_1(search_round );


		time_Round = clock();
		run_time =  (time_Round - time_ARX_DDT) / CLOCKS_PER_SEC;
		printf("Time: %.2f seconds.  \n", run_time);
	}while(Bn_w != n_P_bestofR_w[search_round]);   //end conditions.
//    }while(Bn_w != 38);   //搜索到指定的概率重量值即停止继续搜索.

	fprintf(speck_best_Bn,"%d \n",n_P_bestofR_w[search_round]);  // write.

	for(i=0; i <= search_round; i++)
	{
		n_P_w[i] = P_w[i];
	}
	print_resoult(search_round);

	time_finish = clock();
	run_time =  (double)(time_finish - time_ARX_DDT) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours. \n", run_time,run_time/60.0,run_time/3600.0 );
	printf("Auto-search_speck END! \n");
	printf("|************************************************************************|\n");

	fclose(speck_best_Bn);
	return 1;
}



///////////////////////////////////////////
//2019年01月23日15:25:54
//添加对SPECK的线性分析的代码
u16 sepck_linear_trail_search_entry (u16 search_round)
{
	int i=0;
	FILE* lin_corr_file;
	lin_corr_file = fopen ("../tmp/speck_linear_Bn_wt.xlsx", "a+"); //"a+"); //


	// SPECK bit align.
	bit_align_fun();

	//构造部分的线性相关性近似表cLAT
	ARX_cLAT_construct();
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct ARX_cLAT: %.2f seconds.  \n", run_time);

	Bn_w = 0;
	if(search_round > 3)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(lin_corr_file,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		Bn_w = n_P_bestofR_w[search_round-1] - 1;
	}
	else
	{
		Bn_w = 0;
	}

	Bn_w =17;  //直接设定开始的线性相关性重量,快速达到期望的概率重量
	do
	{
		Bn_w = Bn_w + 1; //线性相关性，单调递增
		printf("Searching correlation weight: %d \n", Bn_w);

		// Search Entry of speck linear trails.
		sepck_round_1_linear(search_round ); //


		time_Round = clock();
		run_time =  (time_Round - time_ARX_cLAT) / CLOCKS_PER_SEC;
		printf("Time: %.2f seconds.  \n", run_time);
	}while(Bn_w != n_P_bestofR_w[search_round]);   //end conditions.
//    }while(Bn_w != ???);   //搜索到指定的概率重量值即停止继续搜索.

	fprintf(lin_corr_file,"%d \n",n_P_bestofR_w[search_round]);  // write.

	for(i=0; i <= search_round; i++)
	{
		n_P_w[i] = P_w[i];
	}

	//打印线性路径
	print_resoult(search_round);
	printf("---------------------------------\n");


	time_finish = clock();
	run_time =  (double)(time_finish - time_ARX_cLAT) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds == %.2f minutes == %.2f hours == %.2f days. \n",
			run_time,run_time/60.0,run_time/3600.0,run_time/86400.0 );
	printf("Auto-search_speck linear trail END! \n");
	printf("|************************************************************************|\n");

	fclose(lin_corr_file);
	return 1;
}

///////
//构造分块的带进位的线性逼近表
void ARX_cLAT_construct(void)
{
	//u16 e_cor[2];
	//e_cor[0] = 0x0, e_cor[1] =0x01;
	volatile u16 ie = 0, je = 0, k =0;
	u16 U,V,W;
	u16 Z=0, A=0, B =0, C =0;
	u16 i_index = 0;
	u16 Cj[8], MT[8];
	u16 wt_cor = 0;
	u16 flag_A=0xFF, flag_B =0xFF;
	u16 bit_v = 0x01;

	u16 i=0;

/*
	memset(cLAT_W,0,sizeof(cLAT_W)); //内存清零函数
	memset(cLAT_U,0,sizeof(cLAT_U)); //内存清零函数
	memset(cLAT_WU_numb,0,sizeof(cLAT_WU_numb)); //内存清零函数
	memset(cLAT_wtcor_min,0xFF,sizeof(cLAT_wtcor_min)); //内存清零函数
	memset(cLAT_UVW_bro,0,sizeof(cLAT_UVW_bro)); //内存清零函数
*/


	for(k=0; k<8; k++)
	{
		MT[k] = 0;
	}

	for(ie=0; ie<2; ie++) //作为索引值，进行查询,级联上一个block
	{
	for(V=0; V<256; V++) //模加的输入掩码，作为索引值，进行查询 =0xFF
	{
		cLAT_wtcor_min[V][ie] = 0xFF;
		wt_cor = 0; // 记录V对应的U和W下的相关性重量

		for(W=0;W<256;W++) //模加的另外一个输入掩码，通过查询得到
		{
			for(U=0;U<256;U++) //模加的输出掩码，通过查询得到
			{
				A = U ^ V;
				B = U ^ W;
				C = U ^ V ^ W;
				for(je=0; je<8; je++)
				{
					Cj[je] = (C >> (7-je)) & 0x1;
				}

				wt_cor = 0; // 记录V对应的U和W下的相关性重量
				if(ie == 1) //block的MSB
				{
					wt_cor++;
					Z = 0x80;  // Z | (bit_v << 7);
					MT[0] = 1;  //0+ie, 0bit,对于完整分组MSB的最高位必须为0
				}
				else
				{
					Z = 00;  // Z | (bit_v << 7);
					MT[0] = 0;  //0+ie, 0bit,对于完整分组MSB的最高位必须为0
				}

				for(i_index=1; i_index<8; i_index++) //1-->7 bit
				{ //我们的目标Mt向量数组，向量中由0-->n-1对应MT分块向量的MSB-->LSB的比特值 异或上 ie
					MT[i_index] = (Cj[i_index -1] + MT[i_index -1]) & 0x1; //% 2;
					if(MT[i_index] == 1 ) //产生相关性重量的位置
					{
						wt_cor++;  //wt_cor为 0 -->8
						Z = Z | (bit_v << (7-i_index)); //构造Z=Mnt向量
					}
				}
				Z = Z & 0xFF; //8bit
				flag_A = A & (~(A&Z));
				flag_B = B & (~(B&Z));

				if( (flag_A==0) && (flag_B ==0) ) // 指标函数，有效性判断 ???
				{
					cLAT_W[V][ie][wt_cor][cLAT_WU_numb[V][ie][wt_cor]] = W;
					cLAT_U[V][ie][wt_cor][cLAT_WU_numb[V][ie][wt_cor]] = U;
					cLAT_WU_numb[V][ie][wt_cor]++;

					//MT[8]
					cLAT_UVW_bro[U][V][W][ie] = (MT[7] + Cj[7]) & 0x01; //% 2; //向右侧下一个分块的递进比特

					if(cLAT_wtcor_min[V][ie] > wt_cor )  //记录V输入掩码下，对应所有UW的最小相关性重量
					{
						cLAT_wtcor_min[V][ie] = wt_cor;
					}
				}
				else
				{
					cLAT_UVW_bro[U][V][W][ie] = 0xFF; //生成对应的UW为无效的输入和输出,判断没通过
				}
	}}
	}}

	/*
		//printf("cLAT_wtcor_min[V][ie]: %d   \n ", cLAT_wtcor_min[0x08][0] );
		printf("cLAT_WU_numb: %d   \n ", cLAT_WU_numb[0x08][0][1] );
		for(i=0; i< cLAT_WU_numb[0x08][0][1]; i++)  //	cLAT_WU_numb: 191
		{
			printf("%d  W: %x \t ",i, cLAT_W[0x08][0][1][i] );
			printf("U: %x \n ", cLAT_U[0x08][0][1][i] );
		}

		//if(V == 0x08)
		//if(cLAT_WU_numb[0x08][0][1] >= 2 )
		{
		//	printf("Z: %x  W: %x  U: %x ie: %d wt_cor: %d \n ", Z, W, U, ie, wt_cor );
		}
		*/

}

/////
u16 sepck_round_1_linear(u16 search_round)
{
	u16 best = 0;
	u16 thrd_cor_1 = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码


	u64 M0 = 0;
	u64 N0 = blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;


	///////////////////round 1 entry/////////////////////
	if( search_round == 1)
	{
		return best;
	}
//	printf("For speck 1-round, thrd_cor_1 = 2; thrd_cor_1 < 5 ;thrd_cor_1++ \n " );
	for(thrd_cor_1 = 2; thrd_cor_1 < 5 ;thrd_cor_1++)  //0::n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if( (thrd_cor_1 + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}

		M0 = thrd_cor_1;  //
		P_w[1] = M0; //相关性重量的记录数组

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;
			//直接跳转到第2轮
			best = sepck_round_2_linear(search_round,Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;
			//直接跳转到第2轮
			best = sepck_round_2_linear(search_round,Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			best = sepck_ADD_mask_Last(search_round,thrd_cor_1,C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHANGE_L_1;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHANGE_L_1;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHANGE_L_1;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHANGE_L_1;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHANGE_L_1;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHANGE_L_1;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHANGE_L_1;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
			CHANGE_L_1:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}

///////////////输出其它的分布模式/////////////////
		best = sepck_ADD_mask_Last(search_round,thrd_cor_1,C0);

#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}
	return best;
}


/////////////////////
u16 sepck_ADD_mask_Last
(u16 search_round,u16 Corr_1, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;
		//跳转到高比特分析
		//跳转到高比特分析
		best = sepck_ADD_mask_Middle(search_round,
				Input_u, Input_v, Input_w,
				Corr_1, Corr_inc, posi,
				1,Fwt );

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;
		//跳转到高比特分析
		//跳转到高比特分析
		best = sepck_ADD_mask_Middle(search_round,
				Input_u, Input_v, Input_w,
				Corr_1, Corr_inc, posi,
				1,Fwt );

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = sepck_ADD_mask_Middle(search_round,
					Input_u, Input_v, Input_w,
					Corr_1, Corr_inc, posi,
					1,Fwt );

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}


//////
u16 sepck_ADD_mask_Middle(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= Corr_1 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = sepck_ADD_mask_MSB(search_round,
				tmp_U,tmp_V,tmp_W,
				Corr_1, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0
				//跳转到高比特分析
				if(current_index <= blocksize_len -2)
				{
					best = sepck_ADD_mask_Middle(search_round,
							tmp_U, tmp_V, tmp_W,
							Corr_1, Corr_tmp_inc, posi,
							current_index +1,Fwt );
				}
				else
				{
					best = sepck_ADD_mask_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Corr_1, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1
				//跳转到高比特分析
				best = sepck_ADD_mask_Middle(search_round,
						Input_u, Input_v, Input_w,
						Corr_1, Corr_tmp_inc, posi,
						current_index +1, Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = sepck_ADD_mask_Middle(search_round,
							Input_u, Input_v, Input_w,
							Corr_1, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = sepck_ADD_mask_Middle(search_round,
							Input_u, Input_v, Input_w,
							Corr_1, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 sepck_ADD_mask_MSB(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;



	if(Corr_tmp_inc > Corr_1)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
	{
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			//跳转 下一轮   Input_u,Input_v,Input_w
			best = sepck_round_2_linear(search_round, tmp_U,tmp_V,tmp_W);
		}
		else
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//跳转 下一轮
			best = sepck_round_2_linear(search_round,Input_u,Input_v,Input_w);
		}
	}
	else
	if( (posi[Corr_1]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
	{
		//Fwt = 0;//当前M向量该比特位无相关性重量
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
			//Input_u = tmp_U | (0 << current_index); //该位置置0
			//Input_v = tmp_V | (0 << current_index); //该位置置0
			//Input_w = tmp_W | (0 << current_index); //该位置置0

			if(current_index <= blocksize_len-2)
			{
				//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
				best = sepck_ADD_mask_MSB(search_round,
						tmp_U,tmp_V,tmp_W,
						Corr_1, Corr_tmp_inc,posi,
						current_index + 1,Fwt);
			}
			else //直接跳转到第3轮
			{
				//跳转 下一轮   Input_u,Input_v,Input_w
				best = sepck_round_2_linear(search_round, tmp_U,tmp_V,tmp_W);
			}
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
			best = sepck_ADD_mask_MSB(search_round,
					Input_u, Input_v, Input_w,
					Corr_1, Corr_tmp_inc,posi,
					current_index + 1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
	}
	else //////当前M向量该比特位you相关性重量, M_i = 1; (posi[Corr_1]-1) == current_index .
	{
		//Fwt = 1;//当前M向量该比特位you相关性重量
		//Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_B_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_B_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_B_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				//跳转 下一轮
				best = sepck_round_2_linear(search_round,Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
			}
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_A_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_A_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_A_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				//跳转 下一轮
				best = sepck_round_2_linear(search_round,Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return best;
}
#endif
			}
		}
	}

	return best;
}

/////////////////////
/////////////////////
////
u16 sepck_round_2_linear(u16 search_round,
		u64 r1_tmp_U, u64 r1_tmp_V, u64 r1_tmp_W)
{
	u16 best = 0;
	u16 thrd_cor = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u64 Input_tmp_right = 0;  //模加输出掩码

	u64 M0 = 0;
	u64 N0 = blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;


	///////////////////round 2 entry/////////////////////
	if( search_round == 2)
	{
		return best;
	}

	for(thrd_cor = 0; thrd_cor < 3 ;thrd_cor++)  //0::n-1 // blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if ((P_w[1] + thrd_cor + n_P_bestofR_w[search_round - 2]) > Bn_w) //
		{
			return 0;  //Return the upper procedure:
		}

		M0 = thrd_cor;  //
		P_w[2] = M0; //相关性重量的记录数组
		if(M0 == 0)  ///
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			//第2轮的输入掩码左右两边
			n_x_in[2] = 0;
			n_y_in[2] = r1_tmp_U;
//			n_x_in[2] = (((Input_v) << rol_a)
//					| ((Input_v) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
//			n_y_in[2] = r1_tmp_U ^ n_x_in[2];
			//第2轮的输出、第3轮的输入掩码
			Input_tmp_right = n_y_in[2];
//			Input_tmp_right = Input_w ^ n_y_in[2];
			n_y_in[3] = (((Input_tmp_right) << rol_b) |
					((Input_tmp_right) >> (blocksize_len-rol_b))) & Bit_Align;//rol left
			n_x_in[3] = n_y_in[3];
//			n_x_in[3] = n_y_in[3] ^ Input_u;
			//直接跳转到第3轮
			best = sepck_round_r_linear(search_round, 3,n_x_in[3],n_y_in[3]);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		n_x_in[1] = (((r1_tmp_V) << rol_a)
				| ((r1_tmp_V) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
		n_y_in[1] = (((n_y_in[2]) >> (rol_b))
				| ((n_y_in[2] ) << (blocksize_len - rol_b))) & Bit_Align;//rol right
		n_y_in[1] = n_y_in[1] ^ r1_tmp_W; // 第1轮右侧输入掩码

		return 1;
	}
#endif
			//UVW = 7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;
			//第2轮的输入掩码左右两边
			n_x_in[2] = ((Input_v << rol_a)
					| (Input_v >> (blocksize_len-rol_a))) & Bit_Align;//rol left
			n_y_in[2] = r1_tmp_U ^ n_x_in[2];
			//第2轮的输出、第3轮的输入掩码
			Input_tmp_right = Input_w ^ n_y_in[2];
			n_y_in[3] = ((Input_tmp_right << rol_b) |
					(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align;//rol left
			n_x_in[3] = n_y_in[3] ^ Input_u;
			//直接跳转到第3轮
			best = sepck_round_r_linear(search_round, 3,n_x_in[3],n_y_in[3]);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		n_x_in[1] = (((r1_tmp_V) << rol_a)
				| ((r1_tmp_V) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
		n_y_in[1] = (((n_y_in[2]) >> (rol_b))
				| ((n_y_in[2] ) << (blocksize_len - rol_b))) & Bit_Align;//rol right
		n_y_in[1] = n_y_in[1] ^ r1_tmp_W; // 第1轮右侧输入掩码
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for ( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for ( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for ( i = 1; i<=M0; i++) { C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			best = sepck_ADD_mask_Last_2(search_round,
					r1_tmp_U, r1_tmp_V, r1_tmp_W,
					thrd_cor,C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if (I0 == 0)
				{
					break;
				}
				else
				{
					if (T0[I0] < 0)
					{
						if ((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if ( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if (A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if (F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHANGE_L_2;
						}
						if (L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHANGE_L_2;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHANGE_L_2;
					}
					Y0 = I0;
					if (I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if (L0 == N0)
						{
							if (I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHANGE_L_2;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHANGE_L_2;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHANGE_L_2;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if (I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHANGE_L_2;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
	CHANGE_L_2:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}

///////////////输出其它的分布模式/////////////////
				best = sepck_ADD_mask_Last_2(search_round,
						r1_tmp_U, r1_tmp_V, r1_tmp_W,
						thrd_cor,C0);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}
	return best;
}



/////////////////////
u16 sepck_ADD_mask_Last_2(u16 search_round,
		u64 r1_tmp_U, u64 r1_tmp_V, u64 r1_tmp_W,
		u16 Corr_2, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;
		//跳转到高比特分析
		//跳转到高比特分析
		best = sepck_ADD_mask_Middle_2(search_round,
				r1_tmp_U, r1_tmp_V, r1_tmp_W,
				Input_u, Input_v, Input_w,
				Corr_2, Corr_inc, posi,
				1,Fwt );

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

	////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = sepck_ADD_mask_Middle_2(search_round,
				r1_tmp_U, r1_tmp_V, r1_tmp_W,
				Input_u, Input_v, Input_w,
				Corr_2, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = sepck_ADD_mask_Middle_2(search_round,
					r1_tmp_U, r1_tmp_V, r1_tmp_W,
					Input_u, Input_v, Input_w,
					Corr_2, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}


//////
u16 sepck_ADD_mask_Middle_2(u16 search_round,
		u64 r1_tmp_U, u64 r1_tmp_V, u64 r1_tmp_W,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_2, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	//u16 j_abc = 0;
	u16 i = 0;


	if(Corr_tmp_inc >= Corr_2 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = sepck_ADD_mask_MSB_2(search_round,
				r1_tmp_U, r1_tmp_V, r1_tmp_W,
				tmp_U,tmp_V,tmp_W,
				Corr_2, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0
				//跳转到高比特分析
				if(current_index <= blocksize_len -2)
				{
					best = sepck_ADD_mask_Middle_2(search_round,
							r1_tmp_U, r1_tmp_V, r1_tmp_W,
							tmp_U, tmp_V, tmp_W,
							Corr_2, Corr_tmp_inc, posi,
							current_index +1, Fwt );
				}
				else
				{
					best = sepck_ADD_mask_MSB_2(search_round,
							r1_tmp_U, r1_tmp_V, r1_tmp_W,
							tmp_U,tmp_V,tmp_W,
							Corr_2, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1
				//跳转到高比特分析
				best = sepck_ADD_mask_Middle_2(search_round,
						r1_tmp_U, r1_tmp_V, r1_tmp_W,
						Input_u, Input_v, Input_w,
						Corr_2, Corr_tmp_inc, posi,
						current_index +1, Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = sepck_ADD_mask_Middle_2(search_round,
							r1_tmp_U, r1_tmp_V, r1_tmp_W,
							Input_u, Input_v, Input_w,
							Corr_2, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = sepck_ADD_mask_Middle_2(search_round,
							r1_tmp_U, r1_tmp_V, r1_tmp_W,
							Input_u, Input_v, Input_w,
							Corr_2, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 sepck_ADD_mask_MSB_2(u16 search_round,
		u64 r1_tmp_U, u64 r1_tmp_V, u64 r1_tmp_W,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_2, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u64 Input_tmp_right = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	//printf("OK \n");
	if(Corr_tmp_inc > Corr_2)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
	{
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			//第2轮的输入掩码左右两边
			n_x_in[2] = (((tmp_V) << rol_a)
					| ((tmp_V) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
			n_y_in[2] = r1_tmp_U ^ n_x_in[2];

			//第2轮的输出、第3轮的输入掩码
			Input_tmp_right = tmp_W ^ n_y_in[2];
			n_y_in[3] = (((Input_tmp_right) << rol_b) |
					((Input_tmp_right) >> (blocksize_len-rol_b))) & Bit_Align;//rol left
			n_x_in[3] = n_y_in[3] ^ tmp_U;

			//跳转 第3轮
			best = sepck_round_r_linear(search_round,3,n_x_in[3], n_y_in[3]);
		}
		else
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//第2轮的输入掩码左右两边
			n_x_in[2] = (((Input_v) << rol_a)
					| ((Input_v) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
			n_y_in[2] = r1_tmp_U ^ n_x_in[2];

			//第2轮的输出、第3轮的输入掩码
			Input_tmp_right = Input_w ^ n_y_in[2];
			n_y_in[3] = (((Input_tmp_right) << rol_b) |
					((Input_tmp_right) >> (blocksize_len-rol_b))) & Bit_Align;//rol left
			n_x_in[3] = n_y_in[3] ^ Input_u;

			//跳转 第3轮
			best = sepck_round_r_linear(search_round,3,n_x_in[3], n_y_in[3]);
		}
	}
	else
	if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
	{
		//Fwt = 0;//当前M向量该比特位无相关性重量
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
			//Input_u = tmp_U | (0 << current_index); //该位置置0
			//Input_v = tmp_V | (0 << current_index); //该位置置0
			//Input_w = tmp_W | (0 << current_index); //该位置置0

			if(current_index <= blocksize_len-2)
			{
			//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
			best = sepck_ADD_mask_MSB_2(search_round,
					r1_tmp_U, r1_tmp_V, r1_tmp_W,
					tmp_U,tmp_V,tmp_W,
					Corr_2, Corr_tmp_inc,posi,
					current_index + 1,Fwt);
			}
			else //直接跳转到第3轮
			{
				//第2轮的输入掩码左右两边
				n_x_in[2] = (((tmp_V) << rol_a)
						| ((tmp_V) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
				n_y_in[2] = r1_tmp_U ^ n_x_in[2];

				//第2轮的输出、第3轮的输入掩码
				Input_tmp_right = tmp_W ^ n_y_in[2];
				n_y_in[3] = (((Input_tmp_right) << rol_b) |
						((Input_tmp_right) >> (blocksize_len-rol_b))) & Bit_Align;//rol left
				n_x_in[3] = n_y_in[3] ^ tmp_U;
			//	printf("OK  what the fuck  \n");
				//跳转 第3轮
				best = sepck_round_r_linear(search_round,3,n_x_in[3], n_y_in[3]);
			}

#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	n_x_in[1] = (((r1_tmp_V) << rol_a) |
			((r1_tmp_V) >> (blocksize_len-rol_a))) & Bit_Align;//rol left

	n_y_in[1] = (((n_y_in[2]) >> (rol_b)) |
			((n_y_in[2] ) << (blocksize_len - rol_b))) & Bit_Align;//rol right
	n_y_in[1] = n_y_in[1] ^ r1_tmp_W; // 第1轮右侧输入掩码
	return 1;
}
#endif
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//if(current_index >= blocksize_len-2){printf("OK lenene 2 \n"); return 0;}
			//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
			best = sepck_ADD_mask_MSB_2(search_round,
					r1_tmp_U, r1_tmp_V, r1_tmp_W,
					Input_u, Input_v, Input_w,
					Corr_2, Corr_tmp_inc,posi,
					current_index + 1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
	}
	else //////当前M向量该比特位you相关性重量, M_i = 1;
	{
		//Fwt = 1;//当前M向量该比特位you相关性重量
		//Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_B_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_B_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_B_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				//第2轮的输入掩码左右两边
				n_x_in[2] = (((Input_v) << rol_a)
						| ((Input_v) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
				n_y_in[2] = r1_tmp_U ^ n_x_in[2];

				//第2轮的输出、第3轮的输入掩码
				Input_tmp_right = Input_w ^ n_y_in[2];
				n_y_in[3] = (((Input_tmp_right) << rol_b) |
						((Input_tmp_right) >> (blocksize_len-rol_b))) & Bit_Align;//rol left
				n_x_in[3] = n_y_in[3] ^ Input_u;

				//跳转 第3轮
				best = sepck_round_r_linear(search_round,3,n_x_in[3], n_y_in[3]);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	n_x_in[1] = (((r1_tmp_V) << rol_a) |
			((r1_tmp_V) >> (blocksize_len-rol_a))) & Bit_Align;   //rol left
	n_y_in[1] = (((n_y_in[2]) >> (rol_b)) |
			((n_y_in[2] ) << (blocksize_len - rol_b))) & Bit_Align;  //rol right
	n_y_in[1] = n_y_in[1] ^ r1_tmp_W; // 第1轮右侧输入掩码

	return 1;
}
#endif
			}
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_A_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_A_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_A_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				//第2轮的输入掩码左右两边
				n_x_in[2] = (((Input_v) << rol_a) |
						((Input_v) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
				n_y_in[2] = r1_tmp_U ^ n_x_in[2];
				//第2轮的输出、第3轮的输入掩码
				Input_tmp_right = Input_w ^ n_y_in[2];
				n_y_in[3] = (((Input_tmp_right) << rol_b) |
						((Input_tmp_right) >> (blocksize_len-rol_b))) & Bit_Align;//rol left
				n_x_in[3] = n_y_in[3] ^ Input_u;
				//跳转 第3轮
				best = sepck_round_r_linear(search_round,3,n_x_in[3], n_y_in[3]);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	n_x_in[1] = (((r1_tmp_V) << rol_a)
			| ((r1_tmp_V) >> (blocksize_len-rol_a))) & Bit_Align;//rol left

	n_y_in[1] = (((n_y_in[2]) >> (rol_b))
			| ((n_y_in[2] ) << (blocksize_len - rol_b))) & Bit_Align;//rol right
	n_y_in[1] = n_y_in[1] ^ r1_tmp_W; // 第1轮右侧输入掩码

	return 1;
}
#endif
			}
		}
	}
	return best;
}


/////
u16 sepck_round_r_linear(u16 search_round, u16 cur_round, u64 x, u64 y)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u64 Input_tmp_right = 0;  //模加输出掩码
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u64 v_block[8] = {0}; //按照8比特进行切片
	u64 w_block[8] = {0};
	u64 u_block[8] = {0};
	u64 e_Mxor[8] ={0}; //用于记录M向量的高比特的异或和
	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;
	u16 wt_cor_bound = 0;
	u64 wt_block_min[8] ={0};


	if(search_round == cur_round)
	{
		best = speck_round_N_linear(search_round, x, y);
		return best;
	}


	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = Bn_w - p_sumof_r - n_P_bestofR_w[search_round - cur_round];

	Input_v = ((x >> rol_a) |
			(x << (blocksize_len - rol_a))) & Bit_Align;//rol right
//	printf("Input_v: %x  \n", Input_v);
	/*  //相关性的概率上界需要判断 //////////////////待研究的问题//////////////////
		if ( bound > w_cmp)
		{
			return 0;
		}
	*/
/*
	//Input_v 与 wt_cor_bound 的关系？？？？
	 //相关性重量至少要大于Input_v的汉明重量，要小于Input_v的非零比特的最大位置
	wt_cor_bound = HM_weight(Input_v >> 1); //相关性重量的下界，即相关性的概率上界，用于剪枝,最低位对相关性重量无贡献
	if ( wt_cor_bound > w_cmp)  //求汉明重量会非常耗时,但是非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}
*/


	switch(sc_blocksize)
	{
		case 32:
			//m1 //从MSB向LSB的方向进行分块
			v_block[0] =  (Input_v >> 8) & 0xFF; //MSB 8 bit
			//m0
			v_block[1] =  (Input_v) & 0xFF; //LSB 8 bit

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
			for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
			{
				w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
				u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];

				//e_Mxor[1] = HM_weight(u_block[0] ^ w_block[0] ^ v_block[0]) % 2; // 0 or 1.
				e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];
				//if(e_Mxor[1] >1 ){continue;}

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
			{
				w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
				u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
				//e_Mxor[2] = (HM_weight(u_block[1] ^ w_block[1] ^ v_block[1]) + e_Mxor[1]) % 2; // 0 or 1.

				Input_w = (w_block[0] << 8) | w_block[1];  //模加输入右侧掩码
				Input_u = (u_block[0] << 8) | u_block[1];  //模加输入右侧掩码

				Input_tmp_right = y ^ Input_w;
				n_y_in[cur_round + 1] = ((Input_tmp_right << rol_b) |
						(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
				n_x_in[cur_round + 1] = n_y_in[cur_round + 1] ^ Input_u;
				P_w[cur_round] = i0 + i1;  //当前轮的线性相关性重量
				//跳转 下一轮
				best = sepck_round_r_linear(search_round,cur_round + 1,
						n_x_in[cur_round + 1],n_y_in[cur_round + 1]);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
			return 1;
		}
#endif
			}}}
			break;

		case 48:
			v_block[0] =  (Input_v >> 8*(nBytes-1)) & 0xFF; //MSB 8 bit
			wt_block_min[0] = cLAT_wtcor_min[v_block[0]][e_Mxor[0]];
			wt_cor_bound = wt_block_min[0];

			for(j=1;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
				wt_block_min[j] = cLAT_wtcor_min[v_block[j]][0];
				wt_cor_bound += wt_block_min[j];
			}
			if ( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
			{
				return 0; //可能无法过滤干净,
			}

/*
			wt_cor_bound = wt_block_min[0];
			for(j=1;j<nBytes;j++)  //nBytes
			{
				wt_block_min[j] = (cLAT_wtcor_min[v_block[j]][0] < cLAT_wtcor_min[v_block[j]][1]) ?
						cLAT_wtcor_min[v_block[j]][0] : cLAT_wtcor_min[v_block[j]][1];
				wt_cor_bound += wt_block_min[j];
			}
*/

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];
					//if(e_Mxor[1] >1 ){continue;} //

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1 ;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];
					//if(e_Mxor[2] >1 ){continue;} //

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];

					Input_w = (w_block[0] << 16) | (w_block[1] << 8) | w_block[2];  //模加输入右侧掩码
					Input_u = (u_block[0] << 16) | (u_block[1] << 8) | u_block[2];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[cur_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					n_x_in[cur_round + 1] = n_y_in[cur_round + 1] ^ Input_u;
					P_w[cur_round] = w2;  //当前轮的线性相关性重量
					//跳转 下一轮
					best = sepck_round_r_linear(search_round,cur_round + 1,
							n_x_in[cur_round + 1],n_y_in[cur_round + 1]);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			return 1;
		}
#endif

			}}}}}}
			break;
		case 64:
/*			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
			}
*/
			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] = (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
				wt_block_min[j] = cLAT_wtcor_min[v_block[j]][0]; //借位假设为ie=0时最小
				wt_cor_bound += wt_block_min[j];
			}
			if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
			{
				return 0;
			}

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];
					e_Mxor[3] = cLAT_UVW_bro[u_block[2]][v_block[2]][w_block[2]][e_Mxor[2]];

			for(i3 = cLAT_wtcor_min[v_block[3]][e_Mxor[3]]; i3 <= 8; i3++)
			{
				w3 = w2 + i3;
				if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j3=0; j3 < cLAT_WU_numb[v_block[3]][e_Mxor[3]][i3]; j3++)
				{
					w_block[3] = cLAT_W[v_block[3]][e_Mxor[3]][i3][j3];
					u_block[3] = cLAT_U[v_block[3]][e_Mxor[3]][i3][j3];

					Input_w = (w_block[0] << 24) | (w_block[1] << 16) |
							(w_block[2] << 8) | w_block[3];  //模加输入右侧掩码
					Input_u = (u_block[0] << 24) | (u_block[1] << 16) |
							(u_block[2] << 8) | u_block[3];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[cur_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					n_x_in[cur_round + 1] = n_y_in[cur_round + 1] ^ Input_u;
					P_w[cur_round] = w3;  //当前轮的线性相关性重量
					//跳转 下一轮
					best = sepck_round_r_linear(search_round,cur_round + 1,
							n_x_in[cur_round + 1],n_y_in[cur_round + 1]);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			return 1;
		}
#endif
			}}}}}}}}
			break;

		case 96:
/*			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
			}
*/
			v_block[0] =  (Input_v >> 8*(nBytes-1)) & 0xFF; //MSB 8 bit
			wt_block_min[0] = cLAT_wtcor_min[v_block[0]][e_Mxor[0]];
			wt_cor_bound = wt_block_min[0];

			for(j=1;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
				wt_block_min[j] = cLAT_wtcor_min[v_block[j]][0]; //借位假设为ie=0时最小
				wt_cor_bound += wt_block_min[j];
			}
			if ( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
			{
				return 0;
			}

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];
					e_Mxor[3] = cLAT_UVW_bro[u_block[2]][v_block[2]][w_block[2]][e_Mxor[2]];

			for(i3 = cLAT_wtcor_min[v_block[3]][e_Mxor[3]]; i3 <= 8; i3++)
			{
				w3 = w2 + i3;
				if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j3=0; j3 < cLAT_WU_numb[v_block[3]][e_Mxor[3]][i3]; j3++)
				{
					w_block[3] = cLAT_W[v_block[3]][e_Mxor[3]][i3][j3];
					u_block[3] = cLAT_U[v_block[3]][e_Mxor[3]][i3][j3];
					e_Mxor[4] = cLAT_UVW_bro[u_block[3]][v_block[3]][w_block[3]][e_Mxor[3]];

			for(i4 = cLAT_wtcor_min[v_block[4]][e_Mxor[4]]; i4 <= 8; i4++)
			{
				w4 = w3 + i4;
				if(w4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j4=0; j4 < cLAT_WU_numb[v_block[4]][e_Mxor[4]][i4]; j4++)
				{
					w_block[4] = cLAT_W[v_block[4]][e_Mxor[4]][i4][j4];
					u_block[4] = cLAT_U[v_block[4]][e_Mxor[4]][i4][j4];
					e_Mxor[5] = cLAT_UVW_bro[u_block[4]][v_block[4]][w_block[4]][e_Mxor[4]];

			for(i5 = cLAT_wtcor_min[v_block[5]][e_Mxor[5]]; i5 <= 8; i5++)
			{
				w5 = w4 + i5;
				if(w5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j5=0; j5 < cLAT_WU_numb[v_block[5]][e_Mxor[5]][i5]; j5++)
				{
					w_block[5] = cLAT_W[v_block[5]][e_Mxor[5]][i5][j5];
					u_block[5] = cLAT_U[v_block[5]][e_Mxor[5]][i5][j5];

					Input_w = (w_block[0] << 40) | (w_block[1] << 32) |
							(w_block[2] << 24) | (w_block[3] << 16) |
							(w_block[4] << 8) | w_block[5];  //模加输入右侧掩码
					Input_u = (u_block[0] << 40) | (u_block[1] << 32) |
							(u_block[2] << 24) | (u_block[3] << 16) |
							(u_block[4] << 8) | u_block[5];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[cur_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					n_x_in[cur_round + 1] = n_y_in[cur_round + 1] ^ Input_u;
					P_w[cur_round] = w5;  //当前轮的线性相关性重量
					//跳转 下一轮
					best = sepck_round_r_linear(search_round,cur_round + 1,
							n_x_in[cur_round + 1],n_y_in[cur_round + 1]);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			return 1;
		}
#endif
			}}}}}}}}}}}}
			break;

		case 128:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
			}

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];
					e_Mxor[3] = cLAT_UVW_bro[u_block[2]][v_block[2]][w_block[2]][e_Mxor[2]];

			for(i3 = cLAT_wtcor_min[v_block[3]][e_Mxor[3]]; i3 <= 8; i3++)
			{
				w3 = w2 + i3;
				if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j3=0; j3 < cLAT_WU_numb[v_block[3]][e_Mxor[3]][i3]; j3++)
				{
					w_block[3] = cLAT_W[v_block[3]][e_Mxor[3]][i3][j3];
					u_block[3] = cLAT_U[v_block[3]][e_Mxor[3]][i3][j3];
					e_Mxor[4] = cLAT_UVW_bro[u_block[3]][v_block[3]][w_block[3]][e_Mxor[3]];

			for(i4 = cLAT_wtcor_min[v_block[4]][e_Mxor[4]]; i4 <= 8; i4++)
			{
				w4 = w3 + i4;
				if(w4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j4=0; j4 < cLAT_WU_numb[v_block[4]][e_Mxor[4]][i4]; j4++)
				{
					w_block[4] = cLAT_W[v_block[4]][e_Mxor[4]][i4][j4];
					u_block[4] = cLAT_U[v_block[4]][e_Mxor[4]][i4][j4];
					e_Mxor[5] = cLAT_UVW_bro[u_block[4]][v_block[4]][w_block[4]][e_Mxor[4]];

			for(i5 = cLAT_wtcor_min[v_block[5]][e_Mxor[5]]; i5 <= 8; i5++)
			{
				w5 = w4 + i5;
				if(w5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j5=0; j5 < cLAT_WU_numb[v_block[5]][e_Mxor[5]][i5]; j5++)
				{
					w_block[5] = cLAT_W[v_block[5]][e_Mxor[5]][i5][j5];
					u_block[5] = cLAT_U[v_block[5]][e_Mxor[5]][i5][j5];
					e_Mxor[6] = cLAT_UVW_bro[u_block[5]][v_block[5]][w_block[5]][e_Mxor[5]];

			for(i6 = cLAT_wtcor_min[v_block[6]][e_Mxor[6]]; i6 <= 8; i6++)
			{
				w6 = w5 + i6;
				if(w6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j6=0; j6 < cLAT_WU_numb[v_block[6]][e_Mxor[6]][i6]; j6++)
				{
					w_block[6] = cLAT_W[v_block[6]][e_Mxor[6]][i6][j6];
					u_block[6] = cLAT_U[v_block[6]][e_Mxor[6]][i6][j6];
					e_Mxor[7] = cLAT_UVW_bro[u_block[7]][v_block[7]][w_block[7]][e_Mxor[7]];

			for(i7 = cLAT_wtcor_min[v_block[7]][e_Mxor[7]]; i7 <= 8; i7++)
			{
				w7 = w6 + i7;
				if(w7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j7=0; j7 < cLAT_WU_numb[v_block[7]][e_Mxor[7]][i7]; j7++)
				{
					w_block[7] = cLAT_W[v_block[7]][e_Mxor[7]][i7][j7];
					u_block[7] = cLAT_U[v_block[7]][e_Mxor[7]][i7][j7];

					Input_w = (w_block[0] << 56) | (w_block[1] << 48) |
							(w_block[2] << 40) | (w_block[3] << 32) |
							(w_block[4] << 24) | (w_block[5] << 16) |
							(w_block[6] << 8) | w_block[7];  //模加输入右侧掩码
					Input_u = (u_block[0] << 56) | (u_block[1] << 48) |
							(u_block[2] << 40) | (u_block[3] << 32) |
							(u_block[4] << 24) | (u_block[5] << 16) |
							(u_block[6] << 8) | u_block[7];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[cur_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					n_x_in[cur_round + 1] = n_y_in[cur_round + 1] ^ Input_u;
					P_w[cur_round] = w7;  //当前轮的线性相关性重量
					//跳转 下一轮
					best = sepck_round_r_linear(search_round,cur_round + 1,
							n_x_in[cur_round + 1],n_y_in[cur_round + 1]);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			return 1;
		}
#endif
			}}}}}}}}}}}}}}}}
			break;
		default:
			break;
	}

	return best;
}

/////
u16 speck_round_N_linear(u16 search_round, u64 x, u64 y)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u64 Input_tmp_right = 0;  //模加输出掩码
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u64 v_block[8] = {0}; //按照8比特进行切片
	u64 w_block[8] = {0};
	u64 u_block[8] = {0};
	u64 e_Mxor[8] ={0}; //用于记录M向量的高比特的异或和
	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;
	u16 wt_cor_bound = 0;
	u64 wt_block_min[8] ={0};


	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = Bn_w - p_sumof_r;
/*  //相关性的概率上界需要判断
	if ( 111 > w_cmp)
	{
		return 0;
	}
*/

	Input_v = ((x >> rol_a) |
			(x << (blocksize_len - rol_a))) & Bit_Align;//rol right
//	printf("NNN  Input_v: %x  \n", Input_v);

	switch(sc_blocksize)
	{
		case 32:
			//m1 //从MSB向LSB的方向进行分块
			v_block[0] =  (Input_v >> 8) & 0xFF; //MSB 8 bit
			//m0
			v_block[1] =  (Input_v) & 0xFF; //LSB 8 bit


			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束.
			for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
			{
				w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
				u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
				//e_Mxor[1] = HM_weight(u_block[0] ^ w_block[0] ^ v_block[0]) % 2; // 0 or 1.
				e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];
				//if(e_Mxor[1] >1 ){continue;}


			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
			{
				w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
				u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
				//e_Mxor[2] = (HM_weight(u_block[1] ^ w_block[1] ^ v_block[1]) + e_Mxor[1]) % 2; // 0 or 1.

				//组合得到输入掩码w和输出掩码U
				Input_w = (w_block[0] << 8) | w_block[1];  //模加输入右侧掩码
				Input_u = (u_block[0] << 8) | u_block[1];  //模加输入右侧掩码

				Input_tmp_right = y ^ Input_w;
				n_y_in[search_round + 1] = ((Input_tmp_right << rol_b) |
						(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
				n_x_in[search_round + 1] = n_y_in[search_round + 1] ^ Input_u;

				P_w[search_round] = i0 + i1;  //当前轮的线性相关性重量
				if(P_w[search_round] == w_cmp) //概率满足Matsui条件,找到期望相关性重量的线性路径
				{
				//	flag++;
				//	if(flag > 4 )
					{
				//		best = 1;
					}
					//找输入掩码汉明重量较低的输出
					if(HM_weight(n_x_in[search_round + 1]) +
							HM_weight(n_y_in[search_round + 1]) < 5)
					{
						best =1;
					}

#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			best  = 1;
			n_P_bestofR_w[search_round] = Bn_w;
			return best;
		}
#endif
				}
			}}}}
			break;
		case 48:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
			}

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];
					//if(e_Mxor[1] >1 ){continue;} //

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];
					//if(e_Mxor[2] >1 ){continue;} //

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];

					Input_w = (w_block[0] << 16) | (w_block[1] << 8) | w_block[2];  //模加输入右侧掩码
					Input_u = (u_block[0] << 16) | (u_block[1] << 8) | u_block[2];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[search_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					n_x_in[search_round + 1] = n_y_in[search_round + 1] ^ Input_u;

					P_w[search_round] = w2;  //当前轮的线性相关性重量
					if(P_w[search_round] == w_cmp) //概率满足Matsui条件,找到期望相关性重量的线性路径
					{
#if 1   //是否找到第一条最优路径就返回？
		//if( best == 1 )
		{
			best  = 1;
			n_P_bestofR_w[search_round] = Bn_w;
			return best;
		}
#endif
					}
			}}}}}}
			break;

		case 64:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] = (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
				wt_block_min[j] = cLAT_wtcor_min[v_block[j]][0]; //借位假设为ie=0时最小
				wt_cor_bound += wt_block_min[j];
			}
			if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
			{
				return 0;
			}

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];
					e_Mxor[3] = cLAT_UVW_bro[u_block[2]][v_block[2]][w_block[2]][e_Mxor[2]];

			for(i3 = cLAT_wtcor_min[v_block[3]][e_Mxor[3]]; i3 <= 8; i3++)
			{
				w3 = w2 + i3;
				if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j3=0; j3 < cLAT_WU_numb[v_block[3]][e_Mxor[3]][i3]; j3++)
				{
					w_block[3] = cLAT_W[v_block[3]][e_Mxor[3]][i3][j3];
					u_block[3] = cLAT_U[v_block[3]][e_Mxor[3]][i3][j3];

					Input_w = (w_block[0] << 24) | (w_block[1] << 16) |
							(w_block[2] << 8) | w_block[3];  //模加输入右侧掩码
					Input_u = (u_block[0] << 24) | (u_block[1] << 16) |
							(u_block[2] << 8) | u_block[3];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[search_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					n_x_in[search_round + 1] = n_y_in[search_round + 1] ^ Input_u;

					P_w[search_round] = w3;  //当前轮的线性相关性重量
					if(P_w[search_round] == w_cmp) //概率满足Matsui条件,找到期望相关性重量的线性路径
					{
#if 1   //是否找到第一条最优路径就返回？
		//if( best == 1 )
		{
			best  = 1;
			n_P_bestofR_w[search_round] = Bn_w;
			return best;
		}
#endif
					}
			}}}}}}}}

			break;
		case 96:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] = (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
				wt_block_min[j] = cLAT_wtcor_min[v_block[j]][0]; //借位假设为ie=0时最小
				wt_cor_bound += wt_block_min[j];
			}
			if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
			{
				return 0;
			}

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];
					e_Mxor[3] = cLAT_UVW_bro[u_block[2]][v_block[2]][w_block[2]][e_Mxor[2]];

			for(i3 = cLAT_wtcor_min[v_block[3]][e_Mxor[3]]; i3 <= 8; i3++)
			{
				w3 = w2 + i3;
				if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j3=0; j3 < cLAT_WU_numb[v_block[3]][e_Mxor[3]][i3]; j3++)
				{
					w_block[3] = cLAT_W[v_block[3]][e_Mxor[3]][i3][j3];
					u_block[3] = cLAT_U[v_block[3]][e_Mxor[3]][i3][j3];
					e_Mxor[4] = cLAT_UVW_bro[u_block[3]][v_block[3]][w_block[3]][e_Mxor[3]];

			for(i4 = cLAT_wtcor_min[v_block[4]][e_Mxor[4]]; i4 <= 8; i4++)
			{
				w4 = w3 + i4;
				if(w4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j4=0; j4 < cLAT_WU_numb[v_block[4]][e_Mxor[4]][i4]; j4++)
				{
					w_block[4] = cLAT_W[v_block[4]][e_Mxor[4]][i4][j4];
					u_block[4] = cLAT_U[v_block[4]][e_Mxor[4]][i4][j4];
					e_Mxor[5] = cLAT_UVW_bro[u_block[4]][v_block[4]][w_block[4]][e_Mxor[4]];

			for(i5 = cLAT_wtcor_min[v_block[5]][e_Mxor[5]]; i5 <= 8; i5++)
			{
				w5 = w4 + i5;
				if(w5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j5=0; j5 < cLAT_WU_numb[v_block[5]][e_Mxor[5]][i5]; j5++)
				{
					w_block[5] = cLAT_W[v_block[5]][e_Mxor[5]][i5][j5];
					u_block[5] = cLAT_U[v_block[5]][e_Mxor[5]][i5][j5];

					Input_w = (w_block[0] << 40) | (w_block[1] << 32) |
							(w_block[2] << 24) | (w_block[3] << 16) |
							(w_block[4] << 8) | w_block[5];  //模加输入右侧掩码
					Input_u = (u_block[0] << 40) | (u_block[1] << 32) |
							(u_block[2] << 24) | (u_block[3] << 16) |
							(u_block[4] << 8) | u_block[5];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[search_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					n_x_in[search_round + 1] = n_y_in[search_round + 1] ^ Input_u;

					P_w[search_round] = w5;  //当前轮的线性相关性重量
					if(P_w[search_round] == w_cmp) //概率满足Matsui条件,找到期望相关性重量的线性路径
					{
#if 1   //是否找到第一条最优路径就返回？
		//if( best == 1 )
		{
			best  = 1;
			n_P_bestofR_w[search_round] = Bn_w;
			return best;
		}
#endif
					}
			}}}}}}}}}}}}
			break;

		case 128:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] = (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
				wt_block_min[j] = cLAT_wtcor_min[v_block[j]][0]; //借位假设为ie=0时最小
				wt_cor_bound += wt_block_min[j];
			}
			if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
			{
				return 0;
			}


			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];
					e_Mxor[3] = cLAT_UVW_bro[u_block[2]][v_block[2]][w_block[2]][e_Mxor[2]];

			for(i3 = cLAT_wtcor_min[v_block[3]][e_Mxor[3]]; i3 <= 8; i3++)
			{
				w3 = w2 + i3;
				if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j3=0; j3 < cLAT_WU_numb[v_block[3]][e_Mxor[3]][i3]; j3++)
				{
					w_block[3] = cLAT_W[v_block[3]][e_Mxor[3]][i3][j3];
					u_block[3] = cLAT_U[v_block[3]][e_Mxor[3]][i3][j3];
					e_Mxor[4] = cLAT_UVW_bro[u_block[3]][v_block[3]][w_block[3]][e_Mxor[3]];

			for(i4 = cLAT_wtcor_min[v_block[4]][e_Mxor[4]]; i4 <= 8; i4++)
			{
				w4 = w3 + i4;
				if(w4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j4=0; j4 < cLAT_WU_numb[v_block[4]][e_Mxor[4]][i4]; j4++)
				{
					w_block[4] = cLAT_W[v_block[4]][e_Mxor[4]][i4][j4];
					u_block[4] = cLAT_U[v_block[4]][e_Mxor[4]][i4][j4];
					e_Mxor[5] = cLAT_UVW_bro[u_block[4]][v_block[4]][w_block[4]][e_Mxor[4]];

			for(i5 = cLAT_wtcor_min[v_block[5]][e_Mxor[5]]; i5 <= 8; i5++)
			{
				w5 = w4 + i5;
				if(w5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j5=0; j5 < cLAT_WU_numb[v_block[5]][e_Mxor[5]][i5]; j5++)
				{
					w_block[5] = cLAT_W[v_block[5]][e_Mxor[5]][i5][j5];
					u_block[5] = cLAT_U[v_block[5]][e_Mxor[5]][i5][j5];
					e_Mxor[6] = cLAT_UVW_bro[u_block[5]][v_block[5]][w_block[5]][e_Mxor[5]];

			for(i6 = cLAT_wtcor_min[v_block[6]][e_Mxor[6]]; i6 <= 8; i6++)
			{
				w6 = w5 + i6;
				if(w6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j6=0; j6 < cLAT_WU_numb[v_block[6]][e_Mxor[6]][i6]; j6++)
				{
					w_block[6] = cLAT_W[v_block[6]][e_Mxor[6]][i6][j6];
					u_block[6] = cLAT_U[v_block[6]][e_Mxor[6]][i6][j6];
					e_Mxor[7] = cLAT_UVW_bro[u_block[7]][v_block[7]][w_block[7]][e_Mxor[7]];

			for(i7 = cLAT_wtcor_min[v_block[7]][e_Mxor[7]]; i7 <= 8; i7++)
			{
				w7 = w6 + i7;
				if(w7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j7=0; j7 < cLAT_WU_numb[v_block[7]][e_Mxor[7]][i7]; j7++)
				{
					w_block[7] = cLAT_W[v_block[7]][e_Mxor[7]][i7][j7];
					u_block[7] = cLAT_U[v_block[7]][e_Mxor[7]][i7][j7];

					Input_w = (w_block[0] << 56) | (w_block[1] << 48) |
							(w_block[2] << 40) | (w_block[3] << 32) |
							(w_block[4] << 24) | (w_block[5] << 16) |
							(w_block[6] << 8) | w_block[7];  //模加输入右侧掩码
					Input_u = (u_block[0] << 56) | (u_block[1] << 48) |
							(u_block[2] << 40) | (u_block[3] << 32) |
							(u_block[4] << 24) | (u_block[5] << 16) |
							(u_block[6] << 8) | u_block[7];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[search_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					n_x_in[search_round + 1] = n_y_in[search_round + 1] ^ Input_u;

					P_w[search_round] = w7;  //当前轮的线性相关性重量
					if(P_w[search_round] == w_cmp) //概率满足Matsui条件,找到期望相关性重量的线性路径
					{
#if 1   //是否找到第一条最优路径就返回？
		//if( best == 1 )
		{
			best  = 1;
			n_P_bestofR_w[search_round] = Bn_w;
			return best;
		}
#endif
					}
			}}}}}}}}}}}}}}}}
			break;
		default:
			break;
	}

	return best;
}


u16 sepck_linear_Hull_search_entry (u16 search_round)
{
	u16 best = 0;
/*
	//ACNS2016的SPECK32的9轮线性huall
		//设定输入输出掩码
		// 9 round. speck32
		input_mask_L = 0x0010;
		input_mask_R = 0x1400;
		output_mask_L = 0x0B00;
		output_mask_R = 0x0800;
		Bn_w = 15;
		//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
		wt_max = 20;
*/

/*
	//设定输入输出掩码
	// 9 round. speck32
	input_mask_L = 0x00a0;
	input_mask_R = 0x062f;
	output_mask_L = 0x170b;
	output_mask_R = 0x130a;
	Bn_w = 14;
	//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
	wt_max = 20;
*/

/*
	//设定输入输出掩码
	// 10 round. speck32
	input_mask_L = 0x0000;
	input_mask_R = 0x3c04;
	output_mask_L = 0x2064;
	output_mask_R = 0x2070;
	Bn_w = 17;
	//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
	wt_max = 25;
*/


	//设定输入输出掩码
	// 10 round. speck32
	input_mask_L = 0x0000;
	input_mask_R = 0x0207;
	output_mask_L = 0x0b00;
	output_mask_R = 0x0800;
	Bn_w = 17;
	//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
	wt_max = 27;


/*
	//设定输入输出掩码
	// 10 round. speck48
	input_mask_L  = 0x000180;
	input_mask_R  = 0xb80001;
	output_mask_L = 0x8800a8;
	output_mask_R = 0x880109;
	Bn_w = 22;
	//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
	wt_max = 28;
*/

/*
	//设定输入输出掩码
	// 11 round. speck48
	input_mask_L  = 0x000800;
	input_mask_R  = 0x800009;
	output_mask_L = 0x300838;
	output_mask_R = 0x000809;
	Bn_w = 25;
	//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
	wt_max = 26;
*/

/*
	//设定输入输出掩码
	// 13 round. speck64
	input_mask_L  = 0x01000120;
	input_mask_R  = 0x14010021;
	output_mask_L = 0x50000404;     //
	output_mask_R = 0x80000404;     //
	Bn_w = 30;  //30
	//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
	wt_max = 32;
*/
/*
	//设定输入输出掩码
	// 14 round. speck64
	input_mask_L  = 0x01000120;		//
	input_mask_R  = 0x14010021;		//
	output_mask_L = 0x26902000;     //
	output_mask_R = 0x20802006;     //
	Bn_w = 33;  //30
	//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
	wt_max = 35;
*/


	int i=0;
	FILE* lin_corr_file;
	lin_corr_file = fopen ("../tmp/speck_linear_Bn_wt.xlsx", "a+"); //"a+"); //
	for(i=1; i <= search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
	{
		fscanf(lin_corr_file,"%d",&n_P_bestofR_w[i]);  //read.
		//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
	}

	// SPECK bit align.
	bit_align_fun();
	memset(wt_nmu,0,sizeof(wt_nmu)); //内存清零函数

	//构造部分的线性相关性近似表cLAT
	ARX_cLAT_construct();
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct ARX_cLAT: %.2f seconds.  \n", run_time);


	printf("--------------------Search SPECK Linear Hulls-------------------\n");

	//搜索Linear Hull的入口
	sepck_round_r_linear_hull(search_round, 1, input_mask_L,input_mask_R);

	printf("--------------------Record SPECK Linear Hulls-------------------\n");

	//打印SPECK的Linear Hull的相关信息
	switch(blocksize_len)
	{
	case 16:

		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)  // 超过wt_max的也统计
		{
			prob = prob + (wt_nmu[i] * pow(2,-2*i)); //注意相关性和线性平方相关的区别
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(lin_corr_file,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
/*
		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)  // 超过wt_max的也统计
		{
			prob = prob + (wt_nmu[i] * pow(2,-i)); //注意相关性和线性平方相关的区别
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(lin_corr_file,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
*/

		printf("++++++++++++++++++++++++++++++++++++\n ");
		printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
		printf("input:0x%04x %04x ======>> output:0x%04x %04x \n",input_mask_L,input_mask_R,output_mask_L,output_mask_R);
		break;
	case 24:
		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
		{
			prob = prob + (wt_nmu[i] * pow(2,-2*i));
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(lin_corr_file,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
		printf("++++++++++++++++++++++++++++++++++++\n ");
		printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
		printf("input:0x%06x %06x ======>> output:0x%06x %06x \n",input_mask_L,input_mask_R,output_mask_L,output_mask_R);
		break;
	case 32:
		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
		{
			prob = prob + (wt_nmu[i] * pow(2,-2*i));
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(lin_corr_file,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
		printf("++++++++++++++++++++++++++++++++++++\n ");
		printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
		printf("input:0x%08x %08x ======>> output:0x%08x %08x \n",input_mask_L,input_mask_R,output_mask_L,output_mask_R);
		break;
	case 48:
		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
		{
			prob = prob + (wt_nmu[i] * pow(2,-2*i));
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(lin_corr_file,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
		printf("++++++++++++++++++++++++++++++++++++\n ");
		printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
		printf("input:0x%012x %012x ======>> output:0x%012x %012x \n",input_mask_L,input_mask_R,output_mask_L,output_mask_R);
		break;
	default:  //64
		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
		{
			prob = prob + (wt_nmu[i] * pow(2,-2*i));
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(lin_corr_file,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
		printf("++++++++++++++++++++++++++++++++++++\n ");
		printf("cipher: %s %d \n ",str_cipher,sc_blocksize);
		printf("input:0x%016x %016x ======>> output:0x%016x %016x \n",input_mask_L,input_mask_R,output_mask_L,output_mask_R);
		break;
	}
	printf(" wt_min(:-%d)--->wt_max: -%d \n",n_P_bestofR_w[search_round],wt_max);
	printf(" %d Rounds Linear Hull with total %d trails.\n",search_round,count);
	printf(" Square Correlation weight is: %.2Lf \n",prob_w);
	fprintf(lin_corr_file,"trails_cnt \t %d \n prob_weight \t %.2Lf \n",count,prob_w);
	printf("++++++++++++++++++++++++++++++++++++\n ");


	time_Round = clock();
	run_time =  (time_Round - time_start) / CLOCKS_PER_SEC;
	printf("Time: %.2f seconds.  \n", run_time);

	fclose(lin_corr_file);

	time_finish = clock();
	run_time =  (double)(time_finish - time_start) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours. \n", run_time,run_time/60.0,run_time/3600.0 );
	printf("Auto-search END! \n");
	printf("|************************************************************************|\n");

	return best;
}


u16 sepck_round_r_linear_hull(u16 search_round, u16 cur_round, u64 x, u64 y)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u64 Input_tmp_right = 0;  //模加输出掩码
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u64 v_block[8] = {0}; //按照8比特进行切片
	u64 w_block[8] = {0};
	u64 u_block[8] = {0};
	u64 e_Mxor[8] ={0}; //用于记录M向量的高比特的异或和
	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;
	u16 wt_cor_bound = 0;
	u64 wt_block_min[8] ={0};

//	printf(" cur_round:  %d \n", cur_round);

	if(search_round <= cur_round)
	{
		best = speck_round_N_linear_hull(search_round, x, y);
		return best;
	}

	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r - n_P_bestofR_w[search_round - cur_round];

	Input_v = ((x >> rol_a) | (x << (blocksize_len - rol_a))) & Bit_Align;//rol right
//	printf("Input_v: %x  \n", Input_v);
	/*  //相关性的概率上界需要判断 //////////////////待研究的问题//////////////////
		if ( bound > w_cmp)
		{
			return 0;
		}
	*/
/*
	//Input_v 与 wt_cor_bound 的关系？？？？
	 //相关性重量至少要大于Input_v的汉明重量，要小于Input_v的非零比特的最大位置
	wt_cor_bound = HM_weight(Input_v >> 1); //相关性重量的下界，即相关性的概率上界，用于剪枝,最低位对相关性重量无贡献
	if ( wt_cor_bound > w_cmp)  //求汉明重量会非常耗时,但是非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}
*/


	switch(sc_blocksize)
	{
		case 32:
			//m1 //从MSB向LSB的方向进行分块
			v_block[0] =  (Input_v >> 8) & 0xFF; //MSB 8 bit
			//m0
			v_block[1] =  (Input_v) & 0xFF; //LSB 8 bit

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
			for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
			{
				w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
				u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];

				//e_Mxor[1] = HM_weight(u_block[0] ^ w_block[0] ^ v_block[0]) % 2; // 0 or 1.
				e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];
				//if(e_Mxor[1] >1 ){continue;}

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
			{
				w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
				u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
				//e_Mxor[2] = (HM_weight(u_block[1] ^ w_block[1] ^ v_block[1]) + e_Mxor[1]) % 2; // 0 or 1.

				Input_w = (w_block[0] << 8) | w_block[1];  //模加输入右侧掩码
				Input_u = (u_block[0] << 8) | u_block[1];  //模加输入右侧掩码

				Input_tmp_right = y ^ Input_w;
				n_y_in[cur_round + 1] = ((Input_tmp_right << rol_b) |
						(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
				n_x_in[cur_round + 1] = n_y_in[cur_round + 1] ^ Input_u;
				P_w[cur_round] = i0 + i1;  //当前轮的线性相关性重量

				//跳转 下一轮
				best = sepck_round_r_linear_hull(search_round,cur_round + 1,
						n_x_in[cur_round + 1],n_y_in[cur_round + 1]);
			}}}}
			break;

		case 48:
	//		v_block[0] =  (Input_v >> 8*(nBytes-1)) & 0xFF; //MSB 8 bit
//			wt_block_min[0] = cLAT_wtcor_min[v_block[0]][e_Mxor[0]];
//			wt_cor_bound = wt_block_min[0];

			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
				wt_block_min[j] = cLAT_wtcor_min[v_block[j]][0];
				wt_cor_bound += wt_block_min[j];
			}
			if ( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
			{
				return 0; //可能无法过滤干净,
			}

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];
					//if(e_Mxor[1] >1 ){continue;} //

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1 ;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];
					//if(e_Mxor[2] >1 ){continue;} //

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];

					Input_w = (w_block[0] << 16) | (w_block[1] << 8) | w_block[2];  //模加输入右侧掩码
					Input_u = (u_block[0] << 16) | (u_block[1] << 8) | u_block[2];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[cur_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					n_x_in[cur_round + 1] = n_y_in[cur_round + 1] ^ Input_u;
					P_w[cur_round] = w2;  //当前轮的线性相关性重量

					//跳转 下一轮
					best = sepck_round_r_linear_hull(search_round,cur_round + 1,
							n_x_in[cur_round + 1],n_y_in[cur_round + 1]);
			}}}}}}
			break;
		case 64:
/*			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
			}
*/
//			v_block[0] =  (Input_v >> 8*(nBytes-1)) & 0xFF; //MSB 8 bit
//			wt_block_min[0] = cLAT_wtcor_min[v_block[0]][e_Mxor[0]];
//			wt_cor_bound = wt_block_min[0];

//			printf("--------------------TEST 1-------------------\n");

			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] = (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
				//wt_block_min[j] = cLAT_wtcor_min[v_block[j]][0]; //借位假设为ie=0时最小
				//wt_cor_bound += wt_block_min[j];
				wt_cor_bound += cLAT_wtcor_min[v_block[j]][0]; //借位假设为ie=0时最小
			}
			if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
			{
				return 0;
			}

			for(i0 = cLAT_wtcor_min[v_block[0]][0]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][0][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][0][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][0][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][0];

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];
					e_Mxor[3] = cLAT_UVW_bro[u_block[2]][v_block[2]][w_block[2]][e_Mxor[2]];

			for(i3 = cLAT_wtcor_min[v_block[3]][e_Mxor[3]]; i3 <= 8; i3++)
			{
				w3 = w2 + i3;
				if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j3=0; j3 < cLAT_WU_numb[v_block[3]][e_Mxor[3]][i3]; j3++)
				{
					w_block[3] = cLAT_W[v_block[3]][e_Mxor[3]][i3][j3];
					u_block[3] = cLAT_U[v_block[3]][e_Mxor[3]][i3][j3];

					Input_w = (w_block[0] << 24) | (w_block[1] << 16) |
							(w_block[2] << 8) | w_block[3];  //模加输入右侧掩码
					Input_u = (u_block[0] << 24) | (u_block[1] << 16) |
							(u_block[2] << 8) | u_block[3];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[cur_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					n_x_in[cur_round + 1] = n_y_in[cur_round + 1] ^ Input_u;
					P_w[cur_round] = w3;  //当前轮的线性相关性重量
/*
					if(cur_round == 1 )
					//if(n_x_in[cur_round + 1] == 0x00000100 )
					{
						printf(" cur_round:  %d  ", cur_round);
						printf("--TEST 3--: 0x%08llx 0x%08llx  P[1]:%d  u:0x%08llx v:0x%08llx w:0x%08llx  ie:%d \n",
								n_x_in[cur_round + 1],n_y_in[cur_round + 1],w3,
								Input_u,Input_v,Input_w,
								cLAT_UVW_bro[u_block[3]][v_block[3]][w_block[3]][e_Mxor[3]]);
					}
//  0x00018100    0x20000101 cLAT_UVW_bro[U][V][W][ie]
*/
					//跳转 下一轮
//					printf("--------------------TEST 2-------------------\n");
					best = sepck_round_r_linear_hull(search_round,cur_round + 1,
							n_x_in[cur_round + 1],n_y_in[cur_round + 1]);
			}}}}}}}}
			break;

		case 96:
/*			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
			}
*/
			v_block[0] =  (Input_v >> 8*(nBytes-1)) & 0xFF; //MSB 8 bit
			wt_block_min[0] = cLAT_wtcor_min[v_block[0]][e_Mxor[0]];
			wt_cor_bound = wt_block_min[0];

			for(j=1;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
				wt_block_min[j] = cLAT_wtcor_min[v_block[j]][0]; //借位假设为ie=0时最小
				wt_cor_bound += wt_block_min[j];
			}
			if ( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
			{
				return 0;
			}

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];
					e_Mxor[3] = cLAT_UVW_bro[u_block[2]][v_block[2]][w_block[2]][e_Mxor[2]];

			for(i3 = cLAT_wtcor_min[v_block[3]][e_Mxor[3]]; i3 <= 8; i3++)
			{
				w3 = w2 + i3;
				if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j3=0; j3 < cLAT_WU_numb[v_block[3]][e_Mxor[3]][i3]; j3++)
				{
					w_block[3] = cLAT_W[v_block[3]][e_Mxor[3]][i3][j3];
					u_block[3] = cLAT_U[v_block[3]][e_Mxor[3]][i3][j3];
					e_Mxor[4] = cLAT_UVW_bro[u_block[3]][v_block[3]][w_block[3]][e_Mxor[3]];

			for(i4 = cLAT_wtcor_min[v_block[4]][e_Mxor[4]]; i4 <= 8; i4++)
			{
				w4 = w3 + i4;
				if(w4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j4=0; j4 < cLAT_WU_numb[v_block[4]][e_Mxor[4]][i4]; j4++)
				{
					w_block[4] = cLAT_W[v_block[4]][e_Mxor[4]][i4][j4];
					u_block[4] = cLAT_U[v_block[4]][e_Mxor[4]][i4][j4];
					e_Mxor[5] = cLAT_UVW_bro[u_block[4]][v_block[4]][w_block[4]][e_Mxor[4]];

			for(i5 = cLAT_wtcor_min[v_block[5]][e_Mxor[5]]; i5 <= 8; i5++)
			{
				w5 = w4 + i5;
				if(w5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j5=0; j5 < cLAT_WU_numb[v_block[5]][e_Mxor[5]][i5]; j5++)
				{
					w_block[5] = cLAT_W[v_block[5]][e_Mxor[5]][i5][j5];
					u_block[5] = cLAT_U[v_block[5]][e_Mxor[5]][i5][j5];

					Input_w = (w_block[0] << 40) | (w_block[1] << 32) |
							(w_block[2] << 24) | (w_block[3] << 16) |
							(w_block[4] << 8) | w_block[5];  //模加输入右侧掩码
					Input_u = (u_block[0] << 40) | (u_block[1] << 32) |
							(u_block[2] << 24) | (u_block[3] << 16) |
							(u_block[4] << 8) | u_block[5];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[cur_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					n_x_in[cur_round + 1] = n_y_in[cur_round + 1] ^ Input_u;
					P_w[cur_round] = w5;  //当前轮的线性相关性重量
					//跳转 下一轮
					best = sepck_round_r_linear_hull(search_round,cur_round + 1,
							n_x_in[cur_round + 1],n_y_in[cur_round + 1]);
			}}}}}}}}}}}}
			break;

		case 128:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
			}

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];
					e_Mxor[3] = cLAT_UVW_bro[u_block[2]][v_block[2]][w_block[2]][e_Mxor[2]];

			for(i3 = cLAT_wtcor_min[v_block[3]][e_Mxor[3]]; i3 <= 8; i3++)
			{
				w3 = w2 + i3;
				if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j3=0; j3 < cLAT_WU_numb[v_block[3]][e_Mxor[3]][i3]; j3++)
				{
					w_block[3] = cLAT_W[v_block[3]][e_Mxor[3]][i3][j3];
					u_block[3] = cLAT_U[v_block[3]][e_Mxor[3]][i3][j3];
					e_Mxor[4] = cLAT_UVW_bro[u_block[3]][v_block[3]][w_block[3]][e_Mxor[3]];

			for(i4 = cLAT_wtcor_min[v_block[4]][e_Mxor[4]]; i4 <= 8; i4++)
			{
				w4 = w3 + i4;
				if(w4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j4=0; j4 < cLAT_WU_numb[v_block[4]][e_Mxor[4]][i4]; j4++)
				{
					w_block[4] = cLAT_W[v_block[4]][e_Mxor[4]][i4][j4];
					u_block[4] = cLAT_U[v_block[4]][e_Mxor[4]][i4][j4];
					e_Mxor[5] = cLAT_UVW_bro[u_block[4]][v_block[4]][w_block[4]][e_Mxor[4]];

			for(i5 = cLAT_wtcor_min[v_block[5]][e_Mxor[5]]; i5 <= 8; i5++)
			{
				w5 = w4 + i5;
				if(w5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j5=0; j5 < cLAT_WU_numb[v_block[5]][e_Mxor[5]][i5]; j5++)
				{
					w_block[5] = cLAT_W[v_block[5]][e_Mxor[5]][i5][j5];
					u_block[5] = cLAT_U[v_block[5]][e_Mxor[5]][i5][j5];
					e_Mxor[6] = cLAT_UVW_bro[u_block[5]][v_block[5]][w_block[5]][e_Mxor[5]];

			for(i6 = cLAT_wtcor_min[v_block[6]][e_Mxor[6]]; i6 <= 8; i6++)
			{
				w6 = w5 + i6;
				if(w6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j6=0; j6 < cLAT_WU_numb[v_block[6]][e_Mxor[6]][i6]; j6++)
				{
					w_block[6] = cLAT_W[v_block[6]][e_Mxor[6]][i6][j6];
					u_block[6] = cLAT_U[v_block[6]][e_Mxor[6]][i6][j6];
					e_Mxor[7] = cLAT_UVW_bro[u_block[7]][v_block[7]][w_block[7]][e_Mxor[7]];

			for(i7 = cLAT_wtcor_min[v_block[7]][e_Mxor[7]]; i7 <= 8; i7++)
			{
				w7 = w6 + i7;
				if(w7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j7=0; j7 < cLAT_WU_numb[v_block[7]][e_Mxor[7]][i7]; j7++)
				{
					w_block[7] = cLAT_W[v_block[7]][e_Mxor[7]][i7][j7];
					u_block[7] = cLAT_U[v_block[7]][e_Mxor[7]][i7][j7];

					Input_w = (w_block[0] << 56) | (w_block[1] << 48) |
							(w_block[2] << 40) | (w_block[3] << 32) |
							(w_block[4] << 24) | (w_block[5] << 16) |
							(w_block[6] << 8) | w_block[7];  //模加输入右侧掩码
					Input_u = (u_block[0] << 56) | (u_block[1] << 48) |
							(u_block[2] << 40) | (u_block[3] << 32) |
							(u_block[4] << 24) | (u_block[5] << 16) |
							(u_block[6] << 8) | u_block[7];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[cur_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					n_x_in[cur_round + 1] = n_y_in[cur_round + 1] ^ Input_u;
					P_w[cur_round] = w7;  //当前轮的线性相关性重量
					//跳转 下一轮
					best = sepck_round_r_linear_hull(search_round,cur_round + 1,
							n_x_in[cur_round + 1],n_y_in[cur_round + 1]);

			}}}}}}}}}}}}}}}}
			break;
		default:
			break;
	}

	return best;
}


u16 speck_round_N_linear_hull(u16 search_round, u64 x, u64 y)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u64 Input_tmp_right = 0;  //模加输出掩码
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u64 v_block[8] = {0}; //按照8比特进行切片
	u64 w_block[8] = {0};
	u64 u_block[8] = {0};
	u64 e_Mxor[8] ={0}; //用于记录M向量的高比特的异或和
	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;

	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r;
/*  //相关性的概率上界需要判断
	if ( 111 > w_cmp)
	{
		return 0;
	}
*/

	Input_v = ((x >> rol_a) |
			(x << (blocksize_len - rol_a))) & Bit_Align;//rol right
//	printf("NNN  Input_v: %x  \n", Input_v);

	switch(sc_blocksize)
	{
		case 32:
			//m1 //从MSB向LSB的方向进行分块
			v_block[0] =  (Input_v >> 8) & 0xFF; //MSB 8 bit
			//m0
			v_block[1] =  (Input_v) & 0xFF; //LSB 8 bit


			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束.
			for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
			{
				w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
				u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
				//e_Mxor[1] = HM_weight(u_block[0] ^ w_block[0] ^ v_block[0]) % 2; // 0 or 1.
				e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];
				//if(e_Mxor[1] >1 ){continue;}


			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
			{
				w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
				u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
				//e_Mxor[2] = (HM_weight(u_block[1] ^ w_block[1] ^ v_block[1]) + e_Mxor[1]) % 2; // 0 or 1.

				//组合得到输入掩码w和输出掩码U
				Input_w = (w_block[0] << 8) | w_block[1];  //模加输入右侧掩码
				Input_u = (u_block[0] << 8) | u_block[1];  //模加输入右侧掩码

				Input_tmp_right = y ^ Input_w;
				n_y_in[search_round + 1] = ((Input_tmp_right << rol_b) |
						(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
				if(n_y_in[search_round + 1] !=  output_mask_R )
				{
					continue;
				}

				n_x_in[search_round + 1] = n_y_in[search_round + 1] ^ Input_u;
				if(n_x_in[search_round + 1] !=  output_mask_L )
				{
					continue;
				}

				P_w[search_round] = i0 + i1;  //当前轮的线性相关性重量
				count++;
				Bn_w = p_sumof_r + P_w[search_round] ;
				printf("count: %d    weight: %d \n",count,Bn_w);
				wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;

			}}}}
			break;
		case 48:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
			}

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];
					//if(e_Mxor[1] >1 ){continue;} //

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];
					//if(e_Mxor[2] >1 ){continue;} //

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];

					Input_w = (w_block[0] << 16) | (w_block[1] << 8) | w_block[2];  //模加输入右侧掩码
					Input_u = (u_block[0] << 16) | (u_block[1] << 8) | u_block[2];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[search_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					if(n_y_in[search_round + 1] !=  output_mask_R )
					{
						continue;
					}

					n_x_in[search_round + 1] = n_y_in[search_round + 1] ^ Input_u;
					if(n_x_in[search_round + 1] !=  output_mask_L )
					{
						continue;
					}

					P_w[search_round] = w2;  //当前轮的线性相关性重量
					count++;
					Bn_w = p_sumof_r + P_w[search_round] ;
					printf("count: %d    weight: %d \n",count,Bn_w);
					wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;

			}}}}}}
			break;

		case 64:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
			}


			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];
					e_Mxor[3] = cLAT_UVW_bro[u_block[2]][v_block[2]][w_block[2]][e_Mxor[2]];

			for(i3 = cLAT_wtcor_min[v_block[3]][e_Mxor[3]]; i3 <= 8; i3++)
			{
				w3 = w2 + i3;
				if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j3=0; j3 < cLAT_WU_numb[v_block[3]][e_Mxor[3]][i3]; j3++)
				{
					w_block[3] = cLAT_W[v_block[3]][e_Mxor[3]][i3][j3];
					u_block[3] = cLAT_U[v_block[3]][e_Mxor[3]][i3][j3];

					Input_w = (w_block[0] << 24) | (w_block[1] << 16) |
							(w_block[2] << 8) | w_block[3];  //模加输入右侧掩码
					Input_u = (u_block[0] << 24) | (u_block[1] << 16) |
							(u_block[2] << 8) | u_block[3];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[search_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					if(n_y_in[search_round + 1] !=  output_mask_R )
					{
						continue;
					}

					n_x_in[search_round + 1] = n_y_in[search_round + 1] ^ Input_u;
					if(n_x_in[search_round + 1] !=  output_mask_L )
					{
						continue;
					}

//					printf("-------TEST 3--: 0x%08llx 0x%08llx \n",n_x_in[search_round + 1],n_y_in[search_round + 1]);

					P_w[search_round] = w3;  //当前轮的线性相关性重量
					count++;
					Bn_w = p_sumof_r + P_w[search_round] ;
					printf("count: %d    weight: %d \n",count,Bn_w);
					wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;

			}}}}}}}}

			break;
		case 96:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
			}

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];
					e_Mxor[3] = cLAT_UVW_bro[u_block[2]][v_block[2]][w_block[2]][e_Mxor[2]];

			for(i3 = cLAT_wtcor_min[v_block[3]][e_Mxor[3]]; i3 <= 8; i3++)
			{
				w3 = w2 + i3;
				if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j3=0; j3 < cLAT_WU_numb[v_block[3]][e_Mxor[3]][i3]; j3++)
				{
					w_block[3] = cLAT_W[v_block[3]][e_Mxor[3]][i3][j3];
					u_block[3] = cLAT_U[v_block[3]][e_Mxor[3]][i3][j3];
					e_Mxor[4] = cLAT_UVW_bro[u_block[3]][v_block[3]][w_block[3]][e_Mxor[3]];

			for(i4 = cLAT_wtcor_min[v_block[4]][e_Mxor[4]]; i4 <= 8; i4++)
			{
				w4 = w3 + i4;
				if(w4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j4=0; j4 < cLAT_WU_numb[v_block[4]][e_Mxor[4]][i4]; j4++)
				{
					w_block[4] = cLAT_W[v_block[4]][e_Mxor[4]][i4][j4];
					u_block[4] = cLAT_U[v_block[4]][e_Mxor[4]][i4][j4];
					e_Mxor[5] = cLAT_UVW_bro[u_block[4]][v_block[4]][w_block[4]][e_Mxor[4]];

			for(i5 = cLAT_wtcor_min[v_block[5]][e_Mxor[5]]; i5 <= 8; i5++)
			{
				w5 = w4 + i5;
				if(w5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j5=0; j5 < cLAT_WU_numb[v_block[5]][e_Mxor[5]][i5]; j5++)
				{
					w_block[5] = cLAT_W[v_block[5]][e_Mxor[5]][i5][j5];
					u_block[5] = cLAT_U[v_block[5]][e_Mxor[5]][i5][j5];

					Input_w = (w_block[0] << 40) | (w_block[1] << 32) |
							(w_block[2] << 24) | (w_block[3] << 16) |
							(w_block[4] << 8) | w_block[5];  //模加输入右侧掩码
					Input_u = (u_block[0] << 40) | (u_block[1] << 32) |
							(u_block[2] << 24) | (u_block[3] << 16) |
							(u_block[4] << 8) | u_block[5];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[search_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					if(n_y_in[search_round + 1] !=  output_mask_R )
					{
						continue;
					}

					n_x_in[search_round + 1] = n_y_in[search_round + 1] ^ Input_u;
					if(n_x_in[search_round + 1] !=  output_mask_L )
					{
						continue;
					}

					P_w[search_round] = w5;  //当前轮的线性相关性重量
					count++;
					Bn_w = p_sumof_r + P_w[search_round] ;
					printf("count: %d    weight: %d \n",count,Bn_w);
					wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;

			}}}}}}}}}}}}
			break;

		case 128:
			for(j=0;j<nBytes;j++)  //nBytes
			{
				//从MSB向LSB的方向进行分块
				v_block[j] =  (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
			}

			for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
			{
				if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
				for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
				{
					w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
					u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
					e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];

			for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
			{
				w1 = i0 + i1;
				if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
				{
					w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
					u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
					e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];

			for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				w2 = w1 + i2;
				if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
				{
					w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
					u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];
					e_Mxor[3] = cLAT_UVW_bro[u_block[2]][v_block[2]][w_block[2]][e_Mxor[2]];

			for(i3 = cLAT_wtcor_min[v_block[3]][e_Mxor[3]]; i3 <= 8; i3++)
			{
				w3 = w2 + i3;
				if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j3=0; j3 < cLAT_WU_numb[v_block[3]][e_Mxor[3]][i3]; j3++)
				{
					w_block[3] = cLAT_W[v_block[3]][e_Mxor[3]][i3][j3];
					u_block[3] = cLAT_U[v_block[3]][e_Mxor[3]][i3][j3];
					e_Mxor[4] = cLAT_UVW_bro[u_block[3]][v_block[3]][w_block[3]][e_Mxor[3]];

			for(i4 = cLAT_wtcor_min[v_block[4]][e_Mxor[4]]; i4 <= 8; i4++)
			{
				w4 = w3 + i4;
				if(w4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j4=0; j4 < cLAT_WU_numb[v_block[4]][e_Mxor[4]][i4]; j4++)
				{
					w_block[4] = cLAT_W[v_block[4]][e_Mxor[4]][i4][j4];
					u_block[4] = cLAT_U[v_block[4]][e_Mxor[4]][i4][j4];
					e_Mxor[5] = cLAT_UVW_bro[u_block[4]][v_block[4]][w_block[4]][e_Mxor[4]];

			for(i5 = cLAT_wtcor_min[v_block[5]][e_Mxor[5]]; i5 <= 8; i5++)
			{
				w5 = w4 + i5;
				if(w5 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j5=0; j5 < cLAT_WU_numb[v_block[5]][e_Mxor[5]][i5]; j5++)
				{
					w_block[5] = cLAT_W[v_block[5]][e_Mxor[5]][i5][j5];
					u_block[5] = cLAT_U[v_block[5]][e_Mxor[5]][i5][j5];
					e_Mxor[6] = cLAT_UVW_bro[u_block[5]][v_block[5]][w_block[5]][e_Mxor[5]];

			for(i6 = cLAT_wtcor_min[v_block[6]][e_Mxor[6]]; i6 <= 8; i6++)
			{
				w6 = w5 + i6;
				if(w6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j6=0; j6 < cLAT_WU_numb[v_block[6]][e_Mxor[6]][i6]; j6++)
				{
					w_block[6] = cLAT_W[v_block[6]][e_Mxor[6]][i6][j6];
					u_block[6] = cLAT_U[v_block[6]][e_Mxor[6]][i6][j6];
					e_Mxor[7] = cLAT_UVW_bro[u_block[7]][v_block[7]][w_block[7]][e_Mxor[7]];

			for(i7 = cLAT_wtcor_min[v_block[7]][e_Mxor[7]]; i7 <= 8; i7++)
			{
				w7 = w6 + i7;
				if(w7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				for(j7=0; j7 < cLAT_WU_numb[v_block[7]][e_Mxor[7]][i7]; j7++)
				{
					w_block[7] = cLAT_W[v_block[7]][e_Mxor[7]][i7][j7];
					u_block[7] = cLAT_U[v_block[7]][e_Mxor[7]][i7][j7];

					Input_w = (w_block[0] << 56) | (w_block[1] << 48) |
							(w_block[2] << 40) | (w_block[3] << 32) |
							(w_block[4] << 24) | (w_block[5] << 16) |
							(w_block[6] << 8) | w_block[7];  //模加输入右侧掩码
					Input_u = (u_block[0] << 56) | (u_block[1] << 48) |
							(u_block[2] << 40) | (u_block[3] << 32) |
							(u_block[4] << 24) | (u_block[5] << 16) |
							(u_block[6] << 8) | u_block[7];  //模加输入右侧掩码

					Input_tmp_right = y ^ Input_w;
					n_y_in[search_round + 1] = ((Input_tmp_right << rol_b) |
							(Input_tmp_right >> (blocksize_len-rol_b))) & Bit_Align; //rol left
					if(n_y_in[search_round + 1] !=  output_mask_R )
					{
						continue;
					}

					n_x_in[search_round + 1] = n_y_in[search_round + 1] ^ Input_u;
					if(n_x_in[search_round + 1] !=  output_mask_L )
					{
						continue;
					}

					P_w[search_round] = w2;  //当前轮的线性相关性重量
					count++;
					Bn_w = p_sumof_r + P_w[search_round] ;
					printf("count: %d    weight: %d \n",count,Bn_w);
					wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;

			}}}}}}}}}}}}}}}}
			break;
		default:
			break;
	}

	return best;
}




u8 HIGHT_round_1(u16 search_round)
{
	u16 best = 0;
	u8 block_x[8]= {0}; // x--input
	u8 block_y[8] = {0}; //y--output
	u8 block_tmp1 = 0;
	u8 block_tmp5 = 0;
	u32 num_0 = 0,num_1 = 0,num_2 = 0,num_3 = 0;
	u8 wt_0 = 0,wt_1 = 0,wt_2 = 0,wt_3 = 0;
	u8 first_wt = 0;
	u64 wt_mod = 0;


	if( search_round == 1)
	{
		best = round_1_j(1);
		return best;
	}

	for(first_wt = 0; first_wt <= 28; first_wt++)  //28
	{
		//printf("first_wt: %d \n",first_wt);
		if ((first_wt + n_P_bestofR_w[search_round - 1]) > Bn_w) //
		{
			return 0;  //Return the upper procedure::
		}
		P_w[1] = first_wt;


		for(wt_mod=0; wt_mod < wt_n_max[first_wt]; wt_mod++)
		{
			wt_3 = wt_3_n[first_wt][wt_mod];
			wt_2 = wt_2_n[first_wt][wt_mod];
			wt_1 = wt_1_n[first_wt][wt_mod];
			wt_0 = wt_0_n[first_wt][wt_mod];
			//printf("wt_0: %d wt_1: %d wt_2: %d wt_3: %d \n",wt_0,wt_1,wt_2,wt_3);

			for(num_3=0; num_3 < fixed_alpha_wt_cnt[0][wt_3];num_3++ )
			{
				block_x[6] = Var_F_0_Table[fixed_alpha_wt_beta[0][wt_3][num_3]];  //x6
				block_y[7] = block_x[6];  //y7
			for(num_2=0; num_2 < Input_Comb_cnt[wt_2]; num_2++)
			{
				block_x[5] = Input_Comb_alpha[wt_2][num_2];  //x5
				block_y[6] = Input_Comb_gamma[wt_2][num_2];  //y6
				block_tmp5 = Input_Comb_beta[wt_2][num_2];
				block_y[5] = Var_F_1_Table[block_tmp5];  //y5,x4
			for(num_1=0;num_1 < fixed_alpha_wt_cnt[0][wt_1]; num_1++)
			{
				block_x[2] = Var_F_0_Table[fixed_alpha_wt_beta[0][wt_1][num_1]];  //x2
				block_y[3] = block_x[2];   //y3
			for(num_0=0; num_0 < Input_Comb_cnt[wt_0]; num_0++)
			{
				block_x[1] = Input_Comb_alpha[wt_0][num_0];
				block_y[2] = Input_Comb_gamma[wt_0][num_0];
				block_tmp1 = Input_Comb_beta[wt_0][num_0];
				block_y[1] = Var_F_1_Table[block_tmp1];


////////////////调用第2轮，不要遍历2^16次方///////////////
  				block_y[0] = fixed_alpha_wt_gamma[0][wt_3][num_3];
				block_y[4] = fixed_alpha_wt_gamma[0][wt_1][num_1];

		  		best = HIGHT_round_2(search_round,
						block_y[7],block_y[6],block_y[5],
						block_y[4],block_y[3],block_y[2],
						block_y[1],block_y[0]);
		  		{{
#if 1   //是否找到第一条最优路径就返回？
		if(best ==1)
		{
			P0_wt_HIGHT[1] = wt_0;  //block 0
			P1_wt_HIGHT[1] = wt_1;  //block 1
			P2_wt_HIGHT[1] = wt_2;  //block 2
			P3_wt_HIGHT[1] = wt_3;  //block 3

			// Input of first round.
			x_block[1][0] = block_y[1];
			x_block[1][1] = block_x[1];
			x_block[1][2] = block_x[2];
			//x_block[1][3] = ?; //未确定//基于第2轮，不要遍历2^16次方
			//x_block[1][3] = x3;  // 基于第1轮，遍历2^16次方的x7和x3

			x_block[1][4] = block_y[5];
			x_block[1][5] = block_x[5];
			x_block[1][6] = block_x[6];
			//x_block[1][7] = ?; //未确定 //基于第2轮，不要遍历2^16次方
			//x_block[1][7] = x7;   // 基于第1轮，遍历2^16次方的x7和x3


			return 1;
		}
#endif
////////////////基于第2轮，不要遍历2^16次方///////////////


/*
 ///////////// 基于第1轮，遍历2^16次方的x7和x3///////////////
				for(x7=0; x7 <= 0xFF;x7++) //x7
				{
				block_y[0] = fixed_alpha_wt_gamma[0][wt_3][num_3] ^ (u8)x7;
				for(x3=0; x3 <= 0xFF;x3++)   //x3
				{
				block_y[4] = fixed_alpha_wt_gamma[0][wt_1][num_1] ^ (u8)x3;  // y4

				best = HIGHT_round_r(search_round, 2,
							block_y[7],block_y[6],block_y[5],
							block_y[4],block_y[3],block_y[2],
							block_y[1],block_y[0]);

#if 1   //是否找到第一条最优路径就返回？
		if(best ==1)
		{
			P0_wt_HIGHT[1] = wt_0;  //block 0
			P1_wt_HIGHT[1] = wt_1;  //block 1
			P2_wt_HIGHT[1] = wt_2;  //block 2
			P3_wt_HIGHT[1] = wt_3;  //block 3

			// Input of first round.
			x_block[1][0] = block_y[1];
			x_block[1][1] = block_x[1];
			x_block[1][2] = block_x[2];
			//x_block[1][3] = ?; //未确定//基于第2轮，不要遍历2^16次方
			x_block[1][3] = x3;  // 基于第1轮，遍历2^16次方的x7和x3

			x_block[1][4] = block_y[5];
			x_block[1][5] = block_x[5];
			x_block[1][6] = block_x[6];
			//x_block[1][7] = ?; //未确定 //基于第2轮，不要遍历2^16次方
			x_block[1][7] = x7;   // 基于第1轮，遍历2^16次方的x7和x3


			return 1;
		}
#endif
///////////// 基于第1轮，遍历2^16次方的x7和x3///////////////
*/
		}}}}}}}
	}
	return best;
}

u8 HIGHT_round_1_diff(u16 search_round)
{
	u8 best = 0;
	u8 X0_tmp=0,X2_tmp=0,X4_tmp=0,X6_tmp=0;
	u16 AB_0 = 0,AB_1 = 0,AB_2 = 0,AB_3 = 0;
	u16 AB_0_H = 0, AB_0_L = 0;
	u16 AB_1_H = 0, AB_1_L = 0;
	u16 AB_2_H = 0, AB_2_L = 0;
	u16 AB_3_H = 0, AB_3_L = 0;
	u8 wt_0 = 0, wt_1 = 0, wt_2 = 0, wt_3 = 0;
	u16 num_0 = 0, num_1 = 0, num_2 = 0, num_3 = 0;
	u8 block_y[8] = {0};  // y--gamma


	if( search_round == 1)
	{
		return 1;
	}

	block_y[7] = HIGHT_x[6];
	block_y[5] = HIGHT_x[4];
	block_y[3] = HIGHT_x[2];
	block_y[1] = HIGHT_x[0];

	X0_tmp = F_1_Table[HIGHT_x[0]];
	X2_tmp = F_0_Table[HIGHT_x[2]];
	X4_tmp = F_1_Table[HIGHT_x[4]];
	X6_tmp = F_0_Table[HIGHT_x[6]];

	AB_3_H = 0;  AB_3_L = X6_tmp;
	AB_3 = AB_3_L;
	AB_2_H = HIGHT_x[5];  AB_2_L = X4_tmp;
	AB_2 = AB_2_H << 8 | AB_2_L;
	AB_1_H = 0;  AB_1_L = X2_tmp;
	AB_1 = AB_1_L;
	AB_0_H = HIGHT_x[1];  AB_0_L = X0_tmp;
	AB_0 = AB_0_H << 8 | AB_0_L;


/////////////////////////////////
	for(wt_3 = HIGHT_cDDT_wt_min[AB_3]; wt_3 < HIGHT_cDDT_wt_max[AB_3]; wt_3++)
	{
		if(wt_3 + n_P_bestofR_w[search_round - 1] > wt_max) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::
		}
	for(wt_2 = HIGHT_cDDT_wt_min[AB_2]; wt_2 < HIGHT_cDDT_wt_max[AB_2]; wt_2++) //x5_wt
	{
		if(wt_3 + wt_2 + n_P_bestofR_w[search_round - 1] > wt_max) // Pmax_compute(xi) is the ri round min weight.
		{
			break;
		}
	for(wt_1 = HIGHT_cDDT_wt_min[AB_1]; wt_1 <HIGHT_cDDT_wt_max[AB_1]; wt_1++) //x5_wt
	{
		if(wt_3 + wt_2 + wt_1 + n_P_bestofR_w[search_round - 1] > wt_max) // Pmax_compute(xi) is the ri round min weight.
		{
			break;
		}
	for(wt_0 = HIGHT_cDDT_wt_min[AB_0]; wt_0 < HIGHT_cDDT_wt_max[AB_0]; wt_0++) //x5_wt
	{
		if(wt_3 + wt_2 + wt_1 + wt_0 + n_P_bestofR_w[search_round - 1] > wt_max) // Pmax_compute(xi) is the ri round min weight.
		{
			break;
		}
		P_w[1] = wt_3 + wt_2 + wt_1 + wt_0;


		for(num_3=0; num_3 < HIGHT_cDDT_n[AB_3][wt_3]; num_3++)
		{
			block_y[0] = HIGHT_x[7] ^ HIGHT_cDDT_v[AB_3][wt_3][num_3];
		for(num_2=0; num_2 < HIGHT_cDDT_n[AB_2][wt_2]; num_2++)
		{
			block_y[6] = HIGHT_cDDT_v[AB_2][wt_2][num_2];
		for(num_1=0; num_1 < HIGHT_cDDT_n[AB_1][wt_1]; num_1++)
		{
			block_y[4] = HIGHT_x[3] ^ HIGHT_cDDT_v[AB_1][wt_1][num_1];
		for(num_0=0; num_0 < HIGHT_cDDT_n[AB_0][wt_0]; num_0++)
		{
			block_y[2] = HIGHT_cDDT_v[AB_0][wt_0][num_0];

			best = HIGHT_round_r_diff(search_round,2,
						block_y[7],block_y[6],block_y[5],
						block_y[4],block_y[3],block_y[2],
						block_y[1],block_y[0]);

		}
		}
	}}}}}}

	return best;
}

u8 HIGHT_round_2(u16 search_round,u8 x7,u8 x6,u8 x5, u8 x4, u8 x3, u8 x2,u8 x1,u8 x0)
{
	u8 best = 0;
	//u8 input_x[8]= {0}; // x--input
	//u8 block_tmp[8] = {0}; //tmp--beta
	u8 block_y[8] = {0};  // y--output
	u8 wt_0 = 0, wt_1 = 0, wt_2 = 0, wt_3 = 0;
	u32 num_0 = 0, num_1 = 0, num_2 = 0, num_3 = 0;
	u8 wt_tmp = 0;
	u16 AB_0 = 0,AB_1 = 0,AB_2 = 0,AB_3 = 0;
//	u16 AB_0_H = 0, AB_0_L = 0;
//	u16 AB_1_H = 0, AB_1_L = 0;
//	u16 AB_2_H = 0, AB_2_L = 0;
//	u16 AB_3_H = 0, AB_3_L = 0;
	u8 wt_0_min = 0, wt_1_min = 0, wt_2_min = 0, wt_3_min = 0;

	block_y[7] = x6;
	//block_y[5] = x4;
	block_y[3] = x2;
	//block_y[1] = x0;

	//AB_0_H = x1; AB_0_L = F_1_Table[x0];
	//AB_0 = AB_0_H << 8 | AB_0_L;
//	AB_0 = F_1_Table[x0];
	//AB_1_H = 0; AB_1_L = F_0_Table[x2];
	//AB_1 = AB_1_L;
	AB_1 = F_0_Table[x2];
	//AB_2_H = x5; AB_2_L = F_1_Table[x4];
	//AB_2 = AB_2_H << 8 | AB_2_L;
//	AB_2 = F_1_Table[x4];
	//AB_3_H = 0; AB_3_L = F_0_Table[x6];
	//AB_3 = AB_3_L;
	AB_3 = F_0_Table[x6];


	wt_3_min = HIGHT_cDDT_wt_min[AB_3];
	wt_1_min = HIGHT_cDDT_wt_min[AB_1];
	wt_0_min = fixed_alpha_wt_min[x1];
	wt_2_min = fixed_alpha_wt_min[x5];


	wt_tmp = P_w[1] + n_P_bestofR_w[search_round - 2];

	if ((wt_tmp + wt_3_min + wt_2_min + wt_1_min + wt_0_min) > Bn_w) // + x5_wt + x1_wt
	{
		return 0;  //Return the upper procedure:
	}

	//4个分块的概率和逐渐递增，这里会造成很多的分支，复杂度产生的地方之一
	for(wt_3 = wt_3_min; wt_3 <= HIGHT_cDDT_wt_max[AB_3]; wt_3++)
	{
		if(wt_3 + wt_2_min + wt_1_min + wt_0_min + wt_tmp > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::
		}

	for(wt_2 = wt_2_min; wt_2 <= fixed_alpha_wt_max[x5]; wt_2++) //x5_wt
	{
		if(wt_3 + wt_2 + wt_1_min + wt_0_min + wt_tmp > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		//if(wt_3 + wt_2 + wt_1 + wt_tmp > Bn_w)
		{
			break;
		}

	for(wt_1 = wt_1_min; wt_1 <= HIGHT_cDDT_wt_max[AB_1]; wt_1++) //x5_wt
	{
		if(wt_3 + wt_2 + wt_1 + wt_0_min + wt_tmp > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			break;
		}

	for(wt_0 = wt_0_min; wt_0 <= fixed_alpha_wt_max[x1]; wt_0++) //x1_wt
	{
		if(wt_3 + wt_2 + wt_1 + wt_0 + wt_tmp > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			break;
		}
		P_w[2] = wt_3 + wt_2 + wt_1 + wt_0;

		for(num_3=0; num_3 < HIGHT_cDDT_n[AB_3][wt_3]; num_3++)
		{
			block_y[0] = x7 ^ HIGHT_cDDT_v[AB_3][wt_3][num_3];
		for(num_2=0; num_2 < fixed_alpha_wt_cnt[x5][wt_2]; num_2++)
		{
			block_y[6] = fixed_alpha_wt_gamma[x5][wt_2][num_2];
			block_y[5] = Var_F_1_Table[fixed_alpha_wt_beta[x5][wt_2][num_2]];
		for(num_1=0; num_1 < HIGHT_cDDT_n[AB_1][wt_1]; num_1++)
		{
			block_y[4] = x3 ^ HIGHT_cDDT_v[AB_1][wt_1][num_1];
		for(num_0=0; num_0 < fixed_alpha_wt_cnt[x1][wt_0]; num_0++)
		{
			block_y[2] = fixed_alpha_wt_gamma[x1][wt_0][num_0];
			block_y[1] = Var_F_1_Table[fixed_alpha_wt_beta[x1][wt_0][num_0]];

			best = HIGHT_round_r(search_round,3,
						block_y[7],block_y[6],block_y[5],
						block_y[4],block_y[3],block_y[2],
						block_y[1],block_y[0]);

#if 1   //是否找到第一条最优路径就返回？
		if(best ==1)  // 构造第1轮的输入
		{
			P0_wt_HIGHT[2] = wt_0; //block 0
			P1_wt_HIGHT[2] = wt_1;  //block 1
			P2_wt_HIGHT[2] = wt_2; //block 2
			P3_wt_HIGHT[2] = wt_3;  //block 3

			// Input of first round.
			x_block[1][3] = x4 ^ block_y[5];
			x_block[1][7] = x0 ^ block_y[1];

			// Input of Second round.
			x_block[2][0] = block_y[1];
			x_block[2][1] = x1;
			x_block[2][2] = x2;
			x_block[2][3] = x3;
			x_block[2][4] = block_y[5];
			x_block[2][5] = x5;
			x_block[2][6] = x6;
			x_block[2][7] = x7;

			return 1;
		}
#endif
		}}}}
	}}}}

	return best;
}


u8 HIGHT_round_r(u16 search_round,u16 cur_round,u8 x7, u8 x6, u8 x5, u8 x4,u8 x3,u8 x2,u8 x1,u8 x0)
{
	u8 best = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16 AB_0 = 0,AB_1 = 0,AB_2 = 0,AB_3 = 0;
	u16 AB_0_H = 0, AB_0_L = 0;
	u16 AB_1_H = 0, AB_1_L = 0;
	u16 AB_2_H = 0, AB_2_L = 0;
	u16 AB_3_H = 0, AB_3_L = 0;
	u8 wt_cmp = 0;
	u8 block_y[8] = {0};  // y--gamma
	u8 wt_0 = 0, wt_1 = 0, wt_2 = 0, wt_3 = 0;
	u8 wt_0_min = 0, wt_1_min = 0, wt_2_min = 0, wt_3_min = 0;
	u32 num_0 = 0, num_1 = 0, num_2 = 0, num_3 = 0;
	u8 w1=0,w2=0,w3=0;


	if(search_round == cur_round)
	{
		best = HIGHT_round_N(search_round,x7,x6,x5,x4,x3,x2,x1,x0);
		return best;
	}

	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	wt_cmp = p_sumof_r + n_P_bestofR_w[search_round - cur_round];

//	wt_3 = wt_F_0_Table[x6];
//	wt_1 = wt_F_0_Table[x2];
//	x1_wt = wt_x_F1[x1][x0];   //(u8)_mm_popcnt_u64((x1 ^ F_1_Table[x0]) & 0x7F);  //
//	x5_wt = wt_x_F1[x5][x4];  //(u8)_mm_popcnt_u64((x5 ^ F_1_Table[x4]) & 0x7F);  //

	AB_0_H = x1; AB_0_L = F_1_Table[x0];
	AB_0 = (AB_0_H << 8) | AB_0_L;
	//AB_1_H = 0; AB_1_L = F_0_Table[x2];
	//AB_1 = AB_1_L;
	AB_1 = F_0_Table[x2];
	AB_2_H = x5; AB_2_L = F_1_Table[x4];
	AB_2 = (AB_2_H << 8) | AB_2_L;
	//AB_3_H = 0; AB_3_L = F_0_Table[x6];
	//AB_3 = AB_3_L;
	AB_3 = F_0_Table[x6];

	wt_3_min = HIGHT_cDDT_wt_min[AB_3];
	wt_1_min = HIGHT_cDDT_wt_min[AB_1];
	wt_0_min = HIGHT_cDDT_wt_min[AB_0];  //	x1_wt
	wt_2_min = HIGHT_cDDT_wt_min[AB_2];  //x5_wt


	if(wt_3_min + wt_2_min + wt_1_min + wt_0_min + wt_cmp > Bn_w) // Pmax_compute(xi) is the ri round min weight.
	{
		return 0;  //Return the upper procedure::
	}

	block_y[7] = x6;
	block_y[5] = x4;
	block_y[3] = x2;
	block_y[1] = x0;



	for(wt_3 = wt_3_min; wt_3 <= HIGHT_cDDT_wt_max[AB_3]; wt_3++)
	{
		if(wt_3 + wt_2_min + wt_1_min + wt_0_min + wt_cmp > Bn_w) //
		{
			return 0;  //Return the upper procedure::
		}

	for(wt_2 = wt_2_min; wt_2 <= HIGHT_cDDT_wt_max[AB_2]; wt_2++) // HIGHT_cDDT_wt_min[AB_2]  //
	{
		w1 = wt_3 + wt_2;
		if(w1 + wt_1_min + wt_0_min + wt_cmp > Bn_w) //
		{
			break;
		}

	for(wt_1 = wt_1_min; wt_1 <= HIGHT_cDDT_wt_max[AB_1]; wt_1++) //x5_wt
	{
		w2 = w1 + wt_1;
		if(w2 + wt_0_min + wt_cmp > Bn_w) //
		{
			break;
		}

	for(wt_0 = wt_0_min; wt_0 <= HIGHT_cDDT_wt_max[AB_0]; wt_0++) // HIGHT_cDDT_wt_min[AB_0]  //
	{
		w3 = w2 + wt_0;
		if(w3 + wt_cmp > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			break;
		}
		P_w[cur_round] = w3;

		for(num_3=0; num_3 < HIGHT_cDDT_n[AB_3][wt_3]; num_3++)
		{
			block_y[0] = x7 ^ HIGHT_cDDT_v[AB_3][wt_3][num_3];
		for(num_2=0; num_2 < HIGHT_cDDT_n[AB_2][wt_2]; num_2++)
		{
			block_y[6] = HIGHT_cDDT_v[AB_2][wt_2][num_2];
		for(num_1=0; num_1 < HIGHT_cDDT_n[AB_1][wt_1]; num_1++)
		{
			block_y[4] = x3 ^ HIGHT_cDDT_v[AB_1][wt_1][num_1];
		for(num_0=0; num_0 < HIGHT_cDDT_n[AB_0][wt_0]; num_0++)
		{
			block_y[2] = HIGHT_cDDT_v[AB_0][wt_0][num_0];

			best = HIGHT_round_r(search_round,cur_round +1,
						block_y[7],block_y[6],block_y[5],
						block_y[4],block_y[3],block_y[2],
						block_y[1],block_y[0]);

#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			P0_wt_HIGHT[cur_round] = wt_0;  //block 0
			P1_wt_HIGHT[cur_round] = wt_1;  //block 1
			P2_wt_HIGHT[cur_round] = wt_2;  //block 2
			P3_wt_HIGHT[cur_round] = wt_3;  //block 3
			// Input of cur_round round.
			x_block[cur_round][0] = x0;
			x_block[cur_round][1] = x1;
			x_block[cur_round][2] = x2;
			x_block[cur_round][3] = x3;
			x_block[cur_round][4] = x4;
			x_block[cur_round][5] = x5;
			x_block[cur_round][6] = x6;
			x_block[cur_round][7] = x7;

			return 1;
		}
#endif
		}
		}
	}}}}}}

	return best;
}

u8 HIGHT_round_r_diff(u16 search_round,u16 cur_round,u8 x7, u8 x6, u8 x5, u8 x4,u8 x3,u8 x2,u8 x1,u8 x0)
{
	u8 best = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u8 wt_cmp = 0;
	u8 X0_tmp=0,X2_tmp=0,X4_tmp=0,X6_tmp=0;
	u16 AB_0 = 0,AB_1 = 0,AB_2 = 0,AB_3 = 0;
	u16 AB_0_H = 0, AB_0_L = 0;
	u16 AB_1_H = 0, AB_1_L = 0;
	u16 AB_2_H = 0, AB_2_L = 0;
	u16 AB_3_H = 0, AB_3_L = 0;
	u8 wt_0 = 0, wt_1 = 0, wt_2 = 0, wt_3 = 0;
	u16 num_0 = 0, num_1 = 0, num_2 = 0, num_3 = 0;
	u8 block_y[8] = {0};  // y--gamma


	if(search_round == cur_round)
	{
		best = HIGHT_round_N_diff(search_round,x7,x6,x5,x4,x3,x2,x1,x0);
		return best;
	}

	block_y[7] = x6;
	block_y[5] = x4;
	block_y[3] = x2;
	block_y[1] = x0;

	X0_tmp = F_1_Table[x0];
	X2_tmp = F_0_Table[x2];
	X4_tmp = F_1_Table[x4];
	X6_tmp = F_0_Table[x6];

	AB_3_H = 0;  AB_3_L = X6_tmp;
	AB_3 = AB_3_L;
	AB_2_H = HIGHT_x[5];  AB_2_L = X4_tmp;
	AB_2 = AB_2_H << 8 | AB_2_L;
	AB_1_H = 0;  AB_1_L = X2_tmp;
	AB_1 = AB_1_L;
	AB_0_H = HIGHT_x[1];  AB_0_L = X0_tmp;
	AB_0 = AB_0_H << 8 | AB_0_L;


	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	wt_cmp = p_sumof_r + n_P_bestofR_w[search_round - cur_round];


/////////////////////////////////
	for(wt_3 = HIGHT_cDDT_wt_min[AB_3]; wt_3 < HIGHT_cDDT_wt_max[AB_3]; wt_3++)
	{
		if(wt_3 + wt_cmp > wt_max) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::
		}
	for(wt_2 = HIGHT_cDDT_wt_min[AB_2]; wt_2 < HIGHT_cDDT_wt_max[AB_2]; wt_2++) //x5_wt
	{
		if(wt_3 + wt_2 + wt_cmp > wt_max) // Pmax_compute(xi) is the ri round min weight.
		{
			break;
		}
	for(wt_1 = HIGHT_cDDT_wt_min[AB_1]; wt_1 <HIGHT_cDDT_wt_max[AB_1]; wt_1++) //x5_wt
	{
		if(wt_3 + wt_2 + wt_1 + wt_cmp > wt_max) // Pmax_compute(xi) is the ri round min weight.
		{
			break;
		}
	for(wt_0 = HIGHT_cDDT_wt_min[AB_0]; wt_0 < HIGHT_cDDT_wt_max[AB_0]; wt_0++) //x5_wt
	{
		if(wt_3 + wt_2 + wt_1 + wt_0 + wt_cmp > wt_max) // Pmax_compute(xi) is the ri round min weight.
		{
			break;
		}
		P_w[cur_round] = wt_3 + wt_2 + wt_1 + wt_0;


		for(num_3=0; num_3 < HIGHT_cDDT_n[AB_3][wt_3]; num_3++)
		{
			block_y[0] = x7 ^ HIGHT_cDDT_v[AB_3][wt_3][num_3];
		for(num_2=0; num_2 < HIGHT_cDDT_n[AB_2][wt_2]; num_2++)
		{
			block_y[6] = HIGHT_cDDT_v[AB_2][wt_2][num_2];
		for(num_1=0; num_1 < HIGHT_cDDT_n[AB_1][wt_1]; num_1++)
		{
			block_y[4] = x3 ^ HIGHT_cDDT_v[AB_1][wt_1][num_1];
		for(num_0=0; num_0 < HIGHT_cDDT_n[AB_0][wt_0]; num_0++)
		{
			block_y[2] = HIGHT_cDDT_v[AB_0][wt_0][num_0];

			best = HIGHT_round_r_diff(search_round,cur_round+1,
						block_y[7],block_y[6],block_y[5],
						block_y[4],block_y[3],block_y[2],
						block_y[1],block_y[0]);

		}
		}
	}}}}}}

	return best;
}

u8 HIGHT_round_N(u16 search_round,u8 x7, u8 x6, u8 x5, u8 x4,u8 x3,u8 x2,u8 x1,u8 x0)
{
	u8 best = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16 AB_0 = 0,AB_1 = 0,AB_2 = 0,AB_3 = 0;
	u16 AB_0_H = 0, AB_0_L = 0;
	u16 AB_1_H = 0, AB_1_L = 0;
	u16 AB_2_H = 0, AB_2_L = 0;
	u16 AB_3_H = 0, AB_3_L = 0;
	u8 wt_cmp = 0;
	u8 block_y[8] = {0};  // y--gamma
	u32 num_0 = 0, num_1 = 0, num_2 = 0, num_3 = 0;
//	u16 x1_wt = 0;
//	u16 x5_wt = 0;
	u8 wt_0 = 0, wt_1 = 0, wt_2 = 0, wt_3 = 0;
	u8 wt_0_min = 0, wt_1_min = 0, wt_2_min = 0, wt_3_min = 0;
	u8 w1=0,w2=0,w3=0;




	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}

	//wt_cmp = Bn_w - p_sumof_r;
//	wt_3 = wt_F_0_Table[x6];
//	wt_1 = wt_F_0_Table[x2];
//	x1_wt = wt_x_F1[x1][x0];   //(u8)_mm_popcnt_u64((x1 ^ F_1_Table[x0]) & 0x7F);  //
//	x5_wt = wt_x_F1[x5][x4];  //(u8)_mm_popcnt_u64((x5 ^ F_1_Table[x4]) & 0x7F);  //

	AB_0_H = x1; AB_0_L = F_1_Table[x0];
	AB_0 = (AB_0_H << 8) | AB_0_L;
	//AB_1_H = 0; AB_1_L = F_0_Table[x2];
	//AB_1 = AB_1_L;
	AB_1 = F_0_Table[x2];
	AB_2_H = x5; AB_2_L = F_1_Table[x4];
	AB_2 = (AB_2_H << 8) | AB_2_L;
	//AB_3_H = 0; AB_3_L = F_0_Table[x6];
	//AB_3 = AB_3_L;
	AB_3 = F_0_Table[x6];

	wt_3_min = HIGHT_cDDT_wt_min[AB_3];
	wt_1_min = HIGHT_cDDT_wt_min[AB_1];
	wt_0_min = HIGHT_cDDT_wt_min[AB_0];
	wt_2_min = HIGHT_cDDT_wt_min[AB_2];

	if(wt_3_min + wt_2_min + wt_1_min + wt_0_min + p_sumof_r > Bn_w)
	{
		return 0;  //Return the upper procedure::
	}
	if(p_sumof_r == 0)
	{
		return 0;  //all 0 input.
	}



	for(wt_3 = HIGHT_cDDT_wt_min[AB_3]; wt_3 <= HIGHT_cDDT_wt_max[AB_3]; wt_3++)
	{
		if(wt_3 + wt_2_min + wt_1_min + wt_0_min + p_sumof_r > Bn_w) //
		{
			return 0;  //Return the upper procedure::
		}

	for(wt_2 = HIGHT_cDDT_wt_min[AB_2]; wt_2 <= HIGHT_cDDT_wt_max[AB_2]; wt_2++) //x5_wt
	{
		w1 = wt_3 + wt_2;
		if(w1 + wt_1_min + wt_0_min + p_sumof_r > Bn_w)
		{
			break;
		}

	for(wt_1 = HIGHT_cDDT_wt_min[AB_1]; wt_1 <= HIGHT_cDDT_wt_max[AB_1]; wt_1++) //x5_wt
	{
		w2 = w1 + wt_1;
		if(w2 + wt_0_min + p_sumof_r > Bn_w)
		{
			break;
		}

	for(wt_0 = HIGHT_cDDT_wt_min[AB_0]; wt_0 <= HIGHT_cDDT_wt_max[AB_0]; wt_0++) //x1_wt
	{
		w3 = w2 + wt_0;
		//找到最优差分路径
		if(w3 + p_sumof_r <= Bn_w)
		{
			P_w[search_round] = w3;
			n_P_bestofR_w[search_round] = Bn_w;

		for(num_3=0; num_3 < HIGHT_cDDT_n[AB_3][wt_3]; num_3++)
		{
			block_y[0] = x7 ^ HIGHT_cDDT_v[AB_3][wt_3][num_3];
		for(num_2=0; num_2 < HIGHT_cDDT_n[AB_2][wt_2]; num_2++)
		{
			block_y[6] = HIGHT_cDDT_v[AB_2][wt_2][num_2];
		for(num_1=0; num_1 < HIGHT_cDDT_n[AB_1][wt_1]; num_1++)
		{
			block_y[4] = x3 ^ HIGHT_cDDT_v[AB_1][wt_1][num_1];
		for(num_0=0; num_0 < HIGHT_cDDT_n[AB_0][wt_0]; num_0++)
		{
			block_y[2] = HIGHT_cDDT_v[AB_0][wt_0][num_0];

			block_y[7] = x6;
			block_y[5] = x4;
			block_y[3] = x2;
			block_y[1] = x0;

			P0_wt_HIGHT[search_round] = wt_0;  //block 0
			P1_wt_HIGHT[search_round] = wt_1;  //block 1
			P2_wt_HIGHT[search_round] = wt_2;  //block 2
			P3_wt_HIGHT[search_round] = wt_3;  //block 3
			// Input of search_round round.
			x_block[search_round][0] = x0;
			x_block[search_round][1] = x1;
			x_block[search_round][2] = x2;
			x_block[search_round][3] = x3;
			x_block[search_round][4] = x4;
			x_block[search_round][5] = x5;
			x_block[search_round][6] = x6;
			x_block[search_round][7] = x7;
			// Output of search_round round.
			x_block[search_round+1][0] = block_y[0];
			x_block[search_round+1][1] = block_y[1];
			x_block[search_round+1][2] = block_y[2];
			x_block[search_round+1][3] = block_y[3];
			x_block[search_round+1][4] = block_y[4];
			x_block[search_round+1][5] = block_y[5];
			x_block[search_round+1][6] = block_y[6];
			x_block[search_round+1][7] = block_y[7];

			best  = 1;
			return best;
		}}
		}
	}
		}}}}}

	return best;
}

u8 HIGHT_round_N_diff(u16 search_round,u8 x7, u8 x6, u8 x5, u8 x4,u8 x3,u8 x2,u8 x1,u8 x0)
{
	u8 best = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	//u8 wt_cmp = 0;
	u8 X0_tmp=0,X2_tmp=0,X4_tmp=0,X6_tmp=0;
	u16 AB_0 = 0,AB_1 = 0,AB_2 = 0,AB_3 = 0;
	u16 AB_0_H = 0, AB_0_L = 0;
	u16 AB_1_H = 0, AB_1_L = 0;
	u16 AB_2_H = 0, AB_2_L = 0;
	u16 AB_3_H = 0, AB_3_L = 0;
	u8 wt_0 = 0, wt_1 = 0, wt_2 = 0, wt_3 = 0;
	u16 num_0 = 0, num_1 = 0, num_2 = 0, num_3 = 0;
	u8 block_y[8] = {0};  // y--gamma


	block_y[7] = x6;
	block_y[5] = x4;
	block_y[3] = x2;
	block_y[1] = x0;

	if(block_y[7] != HIGHT_y[7])
	{
		return 0;
	}
	if(block_y[5] != HIGHT_y[5])
	{
		return 0;
	}
	if(block_y[3] != HIGHT_y[3])
	{
		return 0;
	}
	if(block_y[1] != HIGHT_y[1])
	{
		return 0;
	}

	X0_tmp = F_1_Table[x0];
	X2_tmp = F_0_Table[x2];
	X4_tmp = F_1_Table[x4];
	X6_tmp = F_0_Table[x6];

	AB_3_H = 0;  AB_3_L = X6_tmp;
	AB_3 = AB_3_L;
	AB_2_H = HIGHT_x[5];  AB_2_L = X4_tmp;
	AB_2 = AB_2_H << 8 | AB_2_L;
	AB_1_H = 0;  AB_1_L = X2_tmp;
	AB_1 = AB_1_L;
	AB_0_H = HIGHT_x[1];  AB_0_L = X0_tmp;
	AB_0 = AB_0_H << 8 | AB_0_L;


	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	//wt_cmp = p_sumof_r;

	/////////////////////////////////
	for(wt_3 = HIGHT_cDDT_wt_min[AB_3]; wt_3 < HIGHT_cDDT_wt_max[AB_3]; wt_3++)
	{
		for(num_3=0; num_3 < HIGHT_cDDT_n[AB_3][wt_3]; num_3++)
		{
			block_y[0] = x7 ^ HIGHT_cDDT_v[AB_3][wt_3][num_3];
			if(block_y[0] != HIGHT_y[0])
			{
				continue;
			}
	for(wt_2 = HIGHT_cDDT_wt_min[AB_2]; wt_2 < HIGHT_cDDT_wt_max[AB_2]; wt_2++) //x5_wt
	{
		for(num_2=0; num_2 < HIGHT_cDDT_n[AB_2][wt_2]; num_2++)
		{
			block_y[6] = HIGHT_cDDT_v[AB_2][wt_2][num_2];
			if(block_y[6] != HIGHT_y[6])
			{
				continue;
			}
	for(wt_1 = HIGHT_cDDT_wt_min[AB_1]; wt_1 <HIGHT_cDDT_wt_max[AB_1]; wt_1++) //x5_wt
	{
		for(num_1=0; num_1 < HIGHT_cDDT_n[AB_1][wt_1]; num_1++)
		{
			block_y[4] = x3 ^ HIGHT_cDDT_v[AB_1][wt_1][num_1];
			if(block_y[4] != HIGHT_y[4])
			{
				continue;
			}
	for(wt_0 = HIGHT_cDDT_wt_min[AB_0]; wt_0 < HIGHT_cDDT_wt_max[AB_0]; wt_0++) //x5_wt
	{
		for(num_0=0; num_0 < HIGHT_cDDT_n[AB_0][wt_0]; num_0++)
		{
			block_y[2] = HIGHT_cDDT_v[AB_0][wt_0][num_0];
			if(block_y[2] != HIGHT_y[2])
			{
				continue;
			}

	count++;
	P_w[search_round] = wt_3 + wt_2 + wt_1 + wt_0;
	Bn_w = p_sumof_r + P_w[search_round] ;
	printf("count: %d    weight: %d \n",count,Bn_w);
	wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;


		}
	}}}}}}}

	return best;
}

u16 HIGHT_differential_trail_search_entry (u16 search_round)
{
	u16 i = 0;

	hight_best_Bn = fopen ("../tmp/hight_best_Bn_wt.xlsx", "a+"); //  "w+"); //

	result_print = fopen ("../tmp/result_print.txt", "a+"); //

	fprintf(result_print,"\n|************************************************************************|\n");  // write.
	fprintf(result_print,"Auto-search Begin...  \n");  // write.
	fprintf(result_print,"Enter the parameters : #ciper #blocksize #rounds  #mode \n");  // write.
	fprintf(result_print,"ciper:hight \n");  // write.
	fprintf(result_print,"blocksize: 64 \n");  // write.
	fprintf(result_print,"rounds: %d \n", search_round);  // write.
	fprintf(result_print,"mode: 0 \n");  // write.
	fprintf(result_print,"---------------------------HIGHT Optima differentail trails-------------------------------  \n");  // write.



	printf("Constructing HIGHT Tables... \n");
	fprintf(result_print,"Constructing HIGHT Tables... \n");  // write.

	//memset(F_0_Table,0,sizeof(F_0_Table)); //内存清零函数
	Construct_HIGHT_Tables();
	//ARX_carry_DDTm_construct();
	time_ARX_DDT = clock();
	run_time =  (time_ARX_DDT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct HIGHT tables: %.2f seconds.  \n", run_time);
	fprintf(result_print,"Time of Construct HIGHT tables: %.2f seconds.\n", run_time);


	/*
//	printf("Var_F_1_Table: %x   \n", Var_F_1_Table[0x80]);
// 	printf("Var_F_0_Table[0x80] %x   \n", Var_F_0_Table[0x80]);
	printf("fixed_alpha_wt_cnt[0][0]: %d   \n", fixed_alpha_wt_cnt[0][0]);
	u8 k =0;
	for(k=0; k<fixed_alpha_wt_cnt[0][0];k++)
	{
		printf("fixed_alpha_wt_beta[0][0][%d]: %x  fixed_alpha_wt_gamma[0][0][k]: %x  \n", k,fixed_alpha_wt_beta[0][0][k],fixed_alpha_wt_gamma[0][0][k]);
	}

	printf("Input_Comb_cnt[0]: %d   \n", Input_Comb_cnt[0]);
	for(k=0; k<Input_Comb_cnt[0];k++)
	{
		printf("[%d]: %x  %x  %x \n", k,Input_Comb_alpha[0][k],Input_Comb_beta[0][k],Input_Comb_gamma[0][k] );
	}
*/


	Bn_w = 0;
	if(search_round > 2)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(hight_best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		Bn_w = n_P_bestofR_w[search_round-1] - 1;
	}  /*
	else
	{
		if(search_round == 3 )
		{
			Bn_w = 0;
		}
		else
		{
			Bn_w = -1;
		}
	}
*/
	if(search_round == 3 )
	{
		Bn_w = 0;
	}

	Bn_w = 60;  //直接设定开始的概率重量,快速达到期望的概率重量
	do
	{
		Bn_w = Bn_w + 1;
		printf("Searching Bn_w: %d \n", Bn_w);
		fprintf(result_print,"Searching Bn_w: %d \n", Bn_w);
		// Search Entry.
		HIGHT_round_1(search_round);


		time_Round = clock();
		run_time =  (time_Round - time_ARX_DDT) / CLOCKS_PER_SEC;
		printf("Time: %.2f seconds.  \n", run_time);
		fprintf(result_print,"Time: %.2f seconds.  \n", run_time);
	}while(Bn_w !=  n_P_bestofR_w[search_round]);   //end conditions.
	fprintf(hight_best_Bn,"%d \n",n_P_bestofR_w[search_round]);  // write.

	print_HIGHT_resoult(search_round);


	time_finish = clock();
	run_time =  (double)(time_finish - time_ARX_DDT) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours. \n", run_time,run_time/60.0,run_time/3600.0 );
	printf("Auto-search END! \n");
	printf("|************************************************************************|\n");
	fclose(hight_best_Bn);

	fprintf(result_print,"Time cost: %.2f seconds ==  %.2f minutes == %.2f hours. \n", run_time,run_time/60.0,run_time/3600.0 );
	fprintf(result_print,"Auto-search END! \n");
	fprintf(result_print,"|************************************************************************|\n");
	fclose(result_print);

	return 1;
}

u16 HIGHT_diff_search_entry(u16 search_round)  // 默认只搜索Hight64的差分
{
	int i=0;
	u64 input_hight = 0;
	u64 output_hight = 0;


	/* Get the input difference of r rounds.*/
	printf(" Input: 0x");  scanf("%x",&input_hight);
	printf("Output: 0x");  scanf("%x",&output_hight);

	for(i=0;i<8;i++)  // 差分的输入输出按8bit分成8个块
	{
		HIGHT_x[i] = (u8)((input_hight >> (8*i)) & 0xFF) ; //8 bit
		HIGHT_y[i] = (u8)((output_hight >> (8*i)) & 0xFF) ; //8 bit
	}

	//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
	printf("wt_min(:*)--->wt_max:");
	scanf("%d",&wt_max);

	for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
	{
		fscanf(speck_best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
	}


	printf("-----------------------Search HIGHT-64 Differntials---------------------------\n");
	HIGHT_round_1_diff((u16)sc_rounds);

////////////////////////////////////////////////////////////////
	for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
	{
		prob = prob + (wt_nmu[i] * pow(2,-i));
		prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
		printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
	}
	printf("++++++++++++++++++\n ");
	printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
	//printf("input:0x%012x %012x ======>> output:0x%012x %012x \n",input_diff_L,input_diff_R,output_diff_L,output_diff_R);
	printf("0x%02x %02x %02x %02x %02x %02x %02x %02x======>> 0x%02x %02x %02x %02x %02x %02x %02x %02x \n",
			HIGHT_x[7],HIGHT_x[6],HIGHT_x[5],HIGHT_x[4],HIGHT_x[3],HIGHT_x[2],HIGHT_x[1],HIGHT_x[0],
			HIGHT_y[7],HIGHT_y[6],HIGHT_y[5],HIGHT_y[4],HIGHT_y[3],HIGHT_y[2],HIGHT_y[1],HIGHT_y[0]);

	printf(" wt_min(:*)--->wt_max: -%d \n",wt_max);
	printf(" %d Rounds Differential with total %d trails.\n",search_round,count);
	printf(" Probability weight is: %.2Lf \n",prob_w);
	printf("++++++++++++++++++\n ");


	time_finish = clock();
	run_time =  (double)(time_finish - time_start) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours. \n", run_time,run_time/60.0,run_time/3600.0 );
	printf("Auto-search END! \n");
	printf("|************************************************************************|\n");

	return 1;
}

u16 SPARX64_round_1_Left(u16 search_round)
{
	u16 best = 0;
	u16 thr_d = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;

	u16 wt_round_1_left = 0;
	u16 wt_round_1_right = 0;


	u64 M0 = 0;
	u64 N0 = 15;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;
	u16 j_abc = 0;


///////////////////round 1 entry/////////////////////
	if( search_round == 1)
	{
		best = round_1_j(1);
		return best;
	}
	else
	{
		for(thr_d = 0; thr_d < 15;thr_d++)  //0::n-1  //左右两边各最多15比特的概率重量 31
		{
			// thr_d : the bits number of alpha/beta/gamma that the position not equal at the same time.
			if ((thr_d + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
			{
				return 0;  //Return the upper procedure::
			}
			P_w[1] = thr_d;
			p_sumof_r_P_w[1] = P_w[1];
		for(wt_round_1_left=0; wt_round_1_left <= thr_d; wt_round_1_left++)
		{
			wt_round_1_right = thr_d - wt_round_1_left;
			M0 = wt_round_1_left;  //三个alpha,beta和gamma同时考虑

			if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
			{
				for(j_abc = 0; j_abc < 4;j_abc++)
				{
					if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
					{
						Input_alpha = V_MSB;
					}
					else
					{
						Input_alpha = 0;  // & Bit_Align;
					}

					if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
					{
						Input_beta = V_MSB;
					}
					else
					{
						Input_beta = 0; // & Bit_Align;
					}

					if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
					{
						Input_gamma = V_MSB;
					}
					else
					{
						Input_gamma = 0;  // & Bit_Align;
					}

					//P_w[1] = M0;  //pro; //Speck_XDP_compute(Input_Alpha,Input_Beta,Input_Gamma );
					//best = SPARX64_round_2toR(search_round,2,0,0, Input_gamma,Input_beta );
					//best = SPARX64_round_2to6(search_round, 2,Input_gamma,Input_beta);
					best = SPARX64_round_1_Right(search_round,Input_gamma,Input_beta,
							wt_round_1_left,wt_round_1_right);

#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			wt_l[1] = M0;
			//wt_r[1] = 0;

			//X_r[0][1] = 0;
			//X_r[1][1] = 0;
			//X_r[2][1] = (ROTATE_LEFT(Input_alpha, 7, blocksize_len)) & Bit_Align;
			//X_r[3][1] = Input_beta  & Bit_Align;
			X_r[0][1] = (ROTATE_LEFT(Input_alpha, 7, blocksize_len)) & Bit_Align;
			X_r[1][1] = Input_beta  & Bit_Align;


			return 1;
		}
#endif
					}
				}
				else  //M0 > 0.
				{
					for ( i=0; i<=(N0-M0); i++) A0[i] = 0;
					for ( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
					for ( i = 1; i<=M0; i++) { C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
					T0[N0-M0] = -1;
					T0[1] = 0;
					F0[N0] = N0 - M0 + 1;
					I0 = N0 - M0; L0 = N0;

					best = SPARX64_input_MSB_Left(search_round,Input_alpha, Input_beta, Input_gamma,
							wt_round_1_left,C0,wt_round_1_right);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		return 1;
	}
#endif

////////////////////
				do
				{
					if (I0 == 0)
					{
						break;
					}
					else
					{
						if (T0[I0] < 0)
						{
							if ((-T0[I0]) != (I0-1))
							{
								T0[I0-1] = T0[I0];
							}
							T0[I0] = I0-1;
						}
						if ( A0[I0]==0 )
						{
							X0 = I0;
							Y0 = F0[L0];
							if (A0[I0-1] == 1)
							{
								F0[I0] = F0[I0 - 1];
							}
							else
							{
								F0[I0] = I0;
							}
							if (F0[L0] == L0)
							{
								L0 = I0; I0 = T0[I0];
								goto CHANGE10;
							}
							if (L0 == N0)
							{
								T0[F0[N0]] = -I0 - 1;
								T0[I0 + 1] = T0[I0];
								I0 = F0[N0];
								F0[N0] = F0[N0] + 1;
								goto CHANGE10;
							}
							T0				[L0] = -I0-1;
							T0[I0+1] = T0[I0];
							F0[L0] = F0[L0] + 1;
							I0 = L0;
							goto CHANGE10;
						}
						Y0 = I0;
						if (I0 != L0)
						{
							F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
							if (L0 == N0)
							{
								if (I0 == (F0[N0] - 1))
								{
									I0 = T0[I0];
									goto CHANGE10;
								}
								T0[F0[N0]-1] = -I0-1;
								T0[I0+1] = T0[I0];
								I0 = F0[N0] - 1;
								goto CHANGE10;
							}
							T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0; goto CHANGE10;
						}
						X0 = N0;
						F0[L0 - 1] = F0[L0];
						F0[N0] = N0;
						L0 = N0;
						if (I0 == N0 - 1)
						{
							I0 = T0[N0 - 1];
							goto CHANGE10;
						}
						T0[N0 - 1] = -I0 - 1;
						T0[I0 + 1] = T0[I0];
						I0 = N0 - 1;
			CHANGE10:
					A0[X0] = 1;
					A0[Y0] = 0;
					H0[X0] = Z0 = H0[Y0];
					C0[Z0] = X0;
					}

			best = SPARX64_input_MSB_Left(search_round,Input_alpha, Input_beta, Input_gamma,
					wt_round_1_left,C0,wt_round_1_right);

#if 1   //是否找到第一条最优路径就返回？
			if(best == 1 )
			{
				return 1;
			}
#endif
///////////////////////////////////////
					} while(1);
				}
		}}
	}
	return best;
}



u16 SPARX64_input_MSB_Left
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi,u16 P_1_r)
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 j_abc = 0;

	//2018年11月05日16:57:39
	for(j_abc = 0; j_abc < 8;j_abc++)   // MSB
	{
		//if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
		if((j_abc & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = V_MSB;
		}
		else
		{
			Input_alpha = 0;  // & Bit_Align;
		}

		//if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
		if((j_abc & 0x2) != 0) // alpha bit j.
		{
			Input_beta = V_MSB;
		}
		else
		{
			Input_beta = 0; // & Bit_Align;
		}

		//if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
		if((j_abc & 0x1) != 0) // alpha bit j.
		{
			Input_gamma = V_MSB;
		}
		else
		{
			Input_gamma = 0;  // & Bit_Align;
		}


		if((j_abc==1) || (j_abc==2) || (j_abc==4) || (j_abc==7) )
		{
			Input_alpha |= 0x7FFF;
			Input_beta  |= 0x7FFF;
			Input_gamma |= 0x7FFF;
		}



/* 2018年11月05日16:57:23
	for(j_abc = 0; j_abc < 4;j_abc++)   // MSB
	{
		if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = V_MSB;
		}
		else
		{
			Input_alpha = 0;  // & Bit_Align;
		}

		if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
		{
			Input_beta = V_MSB;
		}
		else
		{
			Input_beta = 0; // & Bit_Align;
		}

		if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
		{
			Input_gamma = V_MSB;
		}
		else
		{
			Input_gamma = 0;  // & Bit_Align;
		}
*/ //2018年11月05日16:57:04




	// MSB of of alpha/beta/gamma
	//for(j_abc = 0; j_abc < 8;j_abc++)   // MSB
/*	for(j_abc = 0; j_abc < 4;j_abc++)   // MSB
	{

		//set A of MSB.
		//if((j_abc==0) || (j_abc==3) || (j_abc==5) || (j_abc==6) )
		{
			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = V_MSB;
			}
			else
			{
				Input_alpha = 0;  // & Bit_Align;
			}

			if((j_abc & 0x2) != 0) // beta bit j.
			{
				Input_beta = V_MSB;
			}
			else
			{
				Input_beta = 0; // & Bit_Align;
			}

			if((j_abc & 0x1) != 0) // gamma bit j.
			{
				Input_gamma = V_MSB;
			}
			else
			{
				Input_gamma = 0;  // & Bit_Align;
			}
		}    */       /*  //对于speck96和speck128,不考虑导致后续比特全确定情况
		else //set B of MSB //if((j_abc==1) || (j_abc==2) || (j_abc==4) || (j_abc==7) )
		{
		if((j_abc & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = Bit_Align;
		}
		else
		{
			Input_alpha = ValueMax_Align;  // & Bit_Align;
		}

		if((j_abc & 0x2) != 0) // beta bit j.
		{
			Input_beta = Bit_Align;
		}
		else
		{
			Input_beta = ValueMax_Align; // & Bit_Align;
		}

		if((j_abc & 0x1) != 0) // gamma bit j.
		{
			Input_gamma = ValueMax_Align;
		}
		else
		{
			Input_gamma = Bit_Align;  // & Bit_Align;
		}
	}
*/

		state = SPAXR64_input_Middle_Left(search_round,Input_alpha,Input_beta, Input_gamma,
				P_1,posi,P_1,P_1_r);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
}
	return state;
}

//由高位到低位逐步判断
u16 SPAXR64_input_Middle_Left
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi, u16 cur_posi,u16 P_1_r)
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u64 indx_tmp = 0;
	u16 i = 0;
	u64 bit_i = 1;

	//indx_tmp = 1 << (posi[cur_posi] - 1);
	indx_tmp = posi[cur_posi] - 1;

	// Middle bit positionsof of alpha/beta/gamma
	if( cur_posi > 1)  // Middle bit positionsof of alpha/beta/gamma
	{

		for(j_abc = 1; j_abc < 7; j_abc++)   // MSB //for speck32/48/64
		//for(i = 0; i < 3; i++)   // MSB //for speck96/128
		{
			//j_abc = set_A_3[i];  //for speck96/128

			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = alpha | (bit_i << indx_tmp);
			}
			else
			{
				//Input_alpha = alpha; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_alpha = (alpha & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x2) != 0) // alpha bit j.
			{
				Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_beta = beta; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_beta = (beta & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x1) != 0) // alpha bit j.
			{
				Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}


			//set A_3 of Middle
			if( (j_abc==3) || (j_abc==5) || (j_abc==6) )
			{
				// setA对应到下一个不全同比特位置,全设置为0才满足差分有效性条件.
				for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
				{
					Input_alpha &= ~(bit_i << j_last);
					Input_beta  &= ~(bit_i << j_last);
					Input_gamma &= ~(bit_i << j_last);
				}
			}     //对于speck96和speck128,不考虑导致后续比特全wei 1情况
			else //set B_3 of Middle //if((j_abc==1) || (j_abc==2) || (j_abc==4) )
			{
				// setB_3对应到下一个不全同比特位置,全设置为 1 才满足差分有效性条件.
				for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
				{
					Input_alpha ^= (bit_i << j_last);
					Input_beta  ^= (bit_i << j_last);
					Input_gamma ^= (bit_i << j_last);
				}
			}

			state = SPAXR64_input_Middle_Left(search_round,
					Input_alpha,Input_beta, Input_gamma,
					P_1,posi,cur_posi-1,P_1_r);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
		}
	}
	else 	//call last position.
	{
		state = SPARX64_input_Last_Left(search_round,
				alpha,beta,	gamma,P_1,posi,P_1_r);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
	}
	return state;
}

u16 SPARX64_input_Last_Left
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi,u16 P_1_r)
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u64 indx_tmp = 0;

	u64 bit_i = 1;


	//indx_tmp = 1 << (posi[1] - 1);
	indx_tmp = posi[1] - 1;

	// Last bit position of alpha/beta/gamma // set_A_3
	for(j_abc = 0; j_abc < 3;j_abc++)// Last bit position.
	{
		if((set_A_3[j_abc] & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = alpha | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_alpha = alpha; // & ( ~(1 << indx_tmp))) & Bit_Align;
			Input_alpha = (alpha & ( ~(bit_i << indx_tmp))) & Bit_Align;
		}

		if((set_A_3[j_abc] & 0x2) != 0) // alpha bit j.
		{
			Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_beta = beta; // & ( ~(1 << indx_tmp))) & Bit_Align;
			Input_beta = (beta & ( ~(bit_i << indx_tmp))) & Bit_Align;
		}

		if((set_A_3[j_abc] & 0x1) != 0) // alpha bit j.
		{
			Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ) & Bit_Align;
			Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ) & Bit_Align;
		}


 	 	 // 若考虑set_B的情况,则需要在此将最低非全0比特位后面的比特全部清零
		if(posi[1] > 1)  //若产生概率重量的最后一个位置为LSB，则不用清0
			for(j_last=0; j_last< indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
			{
				Input_alpha &= ~(bit_i << j_last);
				Input_beta  &= ~(bit_i << j_last);
				Input_gamma &= ~(bit_i << j_last);
			}



//		if( (Speck_XDP_validcheck(Input_alpha,Input_beta,Input_gamma ) ) == 0) //如有效则进行下一轮.
		{
		/////call next round.
//		P_w[1] = P_1;  //pro; //Speck_XDP_compute(Input_Alpha,Input_Beta,Input_Gamma );

		// 只搜索右边的32bit
		//state = SPARX64_round_2to6(search_round, 2,(Input_gamma & Bit_Align),(Input_beta & Bit_Align));
		// 左右两边的32bit都搜索
		state = SPARX64_round_1_Right(search_round,
				Input_gamma,Input_beta,
				P_1,P_1_r);


#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		//wt_l[1] = 0;
		wt_l[1] = P_1;

		//X_r[0][1] = 0;
		//X_r[1][1] = 0;
		X_r[0][1] = (ROTATE_LEFT(Input_alpha, 7, blocksize_len)) & Bit_Align;
		X_r[1][1] = Input_beta  & Bit_Align;

		return 1;
	}
#endif
		}
	}
	return state;
}


u16 SPARX64_round_1_Right(u16 search_round, u16 x0, u16 x1, u16 P_1_l, u16 P_1_r)
{
	u16 best = 0;
//	u16 thr_d = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;


	u64 M0 = 0;
	u64 N0 = 15;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;
	u16 j_abc = 0;


///////////////////round 1 entry/////////////////////
	if( search_round == 1)
	{
		//best = round_1_j(1);
		return 0;
	}
	else
	{
		//for(thr_d = 0; thr_d < 16;thr_d++)  //0::n-1   //16
		{
			// thr_d : the bits number of alpha/beta/gamma that the position not equal at the same time.
//			if (P_1_l + P_1_r + n_P_bestofR_w[search_round - 1] > Bn_w)
			{
//				return 0;  //Return the upper procedure::
			}

			M0 = P_1_r;  //三个alpha,beta和gamma同时考虑
			if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
			{
				for(j_abc = 0; j_abc < 4;j_abc++)
				{
					if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
					{
						Input_alpha = V_MSB;
					}
					else
					{
						Input_alpha = 0;  // & Bit_Align;
					}

					if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
					{
						Input_beta = V_MSB;
					}
					else
					{
						Input_beta = 0; // & Bit_Align;
					}

					if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
					{
						Input_gamma = V_MSB;
					}
					else
					{
						Input_gamma = 0;  // & Bit_Align;
					}

					//P_w[1] = P_1_l + P_1_r;
					best = SPARX64_round_2toR(search_round,2, x0,x1, Input_gamma,Input_beta);
					//best = SPARX64_round_2to6(search_round, 2,Input_gamma,Input_beta);
					//best = SPARX64_round_7toR(search_round,2,Input_gamma,Input_beta,x2,x3);

#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			wt_r[1] = M0;

			X_r[2][1] = (ROTATE_LEFT(Input_alpha, 7, blocksize_len)) & Bit_Align;;
			X_r[3][1] = Input_beta  & Bit_Align;

			return 1;
		}
#endif
					}
				}
				else  //M0 > 0.
				{
					for ( i=0; i<=(N0-M0); i++) A0[i] = 0;
					for ( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
					for ( i = 1; i<=M0; i++) { C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
					T0[N0-M0] = -1;
					T0[1] = 0;
					F0[N0] = N0 - M0 + 1;
					I0 = N0 - M0; L0 = N0;

					best = SPARX64_input_MSB_Right(search_round,
							Input_alpha, Input_beta, Input_gamma,
							P_1_r,C0,
							x0,x1,P_1_l);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		return 1;
	}
#endif

////////////////////
				do
				{
					if (I0 == 0)
					{
						break;
					}
					else
					{
						if (T0[I0] < 0)
						{
							if ((-T0[I0]) != (I0-1))
							{
								T0[I0-1] = T0[I0];
							}
							T0[I0] = I0-1;
						}
						if ( A0[I0]==0 )
						{
							X0 = I0;
							Y0 = F0[L0];
							if (A0[I0-1] == 1)
							{
								F0[I0] = F0[I0 - 1];
							}
							else
							{
								F0[I0] = I0;
							}
							if (F0[L0] == L0)
							{
								L0 = I0; I0 = T0[I0];
								goto CHANGE10;
							}
							if (L0 == N0)
							{
								T0[F0[N0]] = -I0 - 1;
								T0[I0 + 1] = T0[I0];
								I0 = F0[N0];
								F0[N0] = F0[N0] + 1;
								goto CHANGE10;
							}
							T0				[L0] = -I0-1;
							T0[I0+1] = T0[I0];
							F0[L0] = F0[L0] + 1;
							I0 = L0;
							goto CHANGE10;
						}
						Y0 = I0;
						if (I0 != L0)
						{
							F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
							if (L0 == N0)
							{
								if (I0 == (F0[N0] - 1))
								{
									I0 = T0[I0];
									goto CHANGE10;
								}
								T0[F0[N0]-1] = -I0-1;
								T0[I0+1] = T0[I0];
								I0 = F0[N0] - 1;
								goto CHANGE10;
							}
							T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0; goto CHANGE10;
						}
						X0 = N0;
						F0[L0 - 1] = F0[L0];
						F0[N0] = N0;
						L0 = N0;
						if (I0 == N0 - 1)
						{
							I0 = T0[N0 - 1];
							goto CHANGE10;
						}
						T0[N0 - 1] = -I0 - 1;
						T0[I0 + 1] = T0[I0];
						I0 = N0 - 1;
			CHANGE10:
					A0[X0] = 1;
					A0[Y0] = 0;
					H0[X0] = Z0 = H0[Y0];
					C0[Z0] = X0;
					}

			best = SPARX64_input_MSB_Right(search_round,
					Input_alpha, Input_beta, Input_gamma,
					P_1_r,C0,
					x0,x1,P_1_l);

#if 1   //是否找到第一条最优路径就返回？
			if(best == 1 )
			{
				return 1;
			}
#endif
///////////////////////////////////////
					} while(1);
				}
		}
	}
	return best;
}


u16 SPARX64_input_MSB_Right
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi,u16 x0,u16 x1,u16 P_1_l)
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 j_abc = 0;


	for(j_abc = 0; j_abc < 8;j_abc++)   // MSB
	{
		//if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
		if((j_abc & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = V_MSB;
		}
		else
		{
			Input_alpha = 0;  // & Bit_Align;
		}

		//if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
		if((j_abc & 0x2) != 0) // alpha bit j
		{
			Input_beta = V_MSB;
		}
		else
		{
			Input_beta = 0; // & Bit_Align;
		}

		//if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
		if((j_abc & 0x1) != 0) // alpha bit j.
		{
			Input_gamma = V_MSB;
		}
		else
		{
			Input_gamma = 0;  // & Bit_Align;
		}


		if((j_abc==1) || (j_abc==2) || (j_abc==4) || (j_abc==7) )
		{
			Input_alpha |= 0x7FFF;
			Input_beta  |= 0x7FFF;
			Input_gamma |= 0x7FFF;
		}

/*  //2018年11月05日17:14:11
	for(j_abc = 0; j_abc < 4;j_abc++)   // MSB
	{
		if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = V_MSB;
		}
		else
		{
			Input_alpha = 0;  // & Bit_Align;
		}

		if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
		{
			Input_beta = V_MSB;
		}
		else
		{
			Input_beta = 0; // & Bit_Align;
		}

		if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
		{
			Input_gamma = V_MSB;
		}
		else
		{
			Input_gamma = 0;  // & Bit_Align;
		}
*/  //2018年11月05日17:13:58


	// MSB of of alpha/beta/gamma
	//for(j_abc = 0; j_abc < 8;j_abc++)   // MSB
/*	for(j_abc = 0; j_abc < 4;j_abc++)   // MSB
	{

		//set A of MSB.
		//if((j_abc==0) || (j_abc==3) || (j_abc==5) || (j_abc==6) )
		{
			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = V_MSB;
			}
			else
			{
				Input_alpha = 0;  // & Bit_Align;
			}

			if((j_abc & 0x2) != 0) // beta bit j.
			{
				Input_beta = V_MSB;
			}
			else
			{
				Input_beta = 0; // & Bit_Align;
			}

			if((j_abc & 0x1) != 0) // gamma bit j.
			{
				Input_gamma = V_MSB;
			}
			else
			{
				Input_gamma = 0;  // & Bit_Align;
			}
		}    */       /*  //对于speck96和speck128,不考虑导致后续比特全确定情况
		else //set B of MSB //if((j_abc==1) || (j_abc==2) || (j_abc==4) || (j_abc==7) )
		{
		if((j_abc & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = Bit_Align;
		}
		else
		{
			Input_alpha = ValueMax_Align;  // & Bit_Align;
		}

		if((j_abc & 0x2) != 0) // beta bit j.
		{
			Input_beta = Bit_Align;
		}
		else
		{
			Input_beta = ValueMax_Align; // & Bit_Align;
		}

		if((j_abc & 0x1) != 0) // gamma bit j.
		{
			Input_gamma = ValueMax_Align;
		}
		else
		{
			Input_gamma = Bit_Align;  // & Bit_Align;
		}
	}
*/
		state = SPAXR64_input_Middle_Right(search_round,
				Input_alpha,Input_beta, Input_gamma,
				P_1,posi,P_1,
				x0,x1,P_1_l);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
}
	return state;
}

//由高位到低位逐步判断
u16 SPAXR64_input_Middle_Right
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi, u16 cur_posi,u16 x0,u16 x1,u16 P_1_l)
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u64 indx_tmp = 0;
	u16 i = 0;
	u64 bit_i = 1;

	//indx_tmp = 1 << (posi[cur_posi] - 1);
	indx_tmp = posi[cur_posi] - 1;

	// Middle bit positionsof of alpha/beta/gamma
	if( cur_posi > 1)  // Middle bit positionsof of alpha/beta/gamma
	{

		for(j_abc = 1; j_abc < 7; j_abc++)   // MSB //for speck32/48/64
		//for(i = 0; i < 3; i++)   // MSB //for speck96/128
		{
			//j_abc = set_A_3[i];  //for speck96/128

			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = alpha | (bit_i << indx_tmp);
			}
			else
			{
				//Input_alpha = alpha; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_alpha = (alpha & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x2) != 0) // alpha bit j.
			{
				Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_beta = beta; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_beta = (beta & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x1) != 0) // alpha bit j.
			{
				Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}


			//set A_3 of Middle
			if( (j_abc==3) || (j_abc==5) || (j_abc==6) )
			{
				// setA对应到下一个不全同比特位置,全设置为0才满足差分有效性条件.
				for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
				{
					Input_alpha &= ~(bit_i << j_last);
					Input_beta  &= ~(bit_i << j_last);
					Input_gamma &= ~(bit_i << j_last);
				}
			}     //对于speck96和speck128,不考虑导致后续比特全wei 1情况
			else //set B_3 of Middle //if((j_abc==1) || (j_abc==2) || (j_abc==4) )
			{
				// setB_3对应到下一个不全同比特位置,全设置为 1 才满足差分有效性条件.
				for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
				{
					Input_alpha ^= (bit_i << j_last);
					Input_beta  ^= (bit_i << j_last);
					Input_gamma ^= (bit_i << j_last);
				}
			}


			state = SPAXR64_input_Middle_Right(search_round,
					Input_alpha,Input_beta, Input_gamma,
					P_1,posi,cur_posi-1,
					x0,x1,P_1_l);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
		}
	}
	else 	//call last position.
	{
		state = SPARX64_input_Last_Right(search_round,
				alpha,beta,	gamma,P_1,posi,x0,x1,P_1_l);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
	}
	return state;
}

u16 SPARX64_input_Last_Right
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi,u16 x0,u16 x1,u16 P_1_l)
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u64 indx_tmp = 0;

	u64 bit_i = 1;


	//indx_tmp = 1 << (posi[1] - 1);
	indx_tmp = posi[1] - 1;

	// Last bit position of alpha/beta/gamma // set_A_3
	for(j_abc = 0; j_abc < 3;j_abc++)// Last bit position.
	{
		if((set_A_3[j_abc] & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = alpha | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_alpha = alpha; // & ( ~(1 << indx_tmp))) & Bit_Align;
			Input_alpha = (alpha & ( ~(bit_i << indx_tmp))) & Bit_Align;
		}

		if((set_A_3[j_abc] & 0x2) != 0) // alpha bit j.
		{
			Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_beta = beta; // & ( ~(1 << indx_tmp))) & Bit_Align;
			Input_beta = (beta & ( ~(bit_i << indx_tmp))) & Bit_Align;
		}

		if((set_A_3[j_abc] & 0x1) != 0) // alpha bit j.
		{
			Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ) & Bit_Align;
			Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ) & Bit_Align;
		}


 	 	 // 若考虑set_B的情况,则需要在此将最低非全0比特位后面的比特全部清零
		if(posi[1] > 1)
			for(j_last=0; j_last< indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
			{
				Input_alpha &= ~(bit_i << j_last);
				Input_beta  &= ~(bit_i << j_last);
				Input_gamma &= ~(bit_i << j_last);
			}


//		if( (Speck_XDP_validcheck(Input_alpha,Input_beta,Input_gamma ) ) == 0) //如有效则进行下一轮.
		{
		/////call next round.
//??		P_w[1] = P_1 + P_1_l;  //pro; //Speck_XDP_compute(Input_Alpha,Input_Beta,Input_Gamma );

		// 只搜索右边的32bit
		//state = SPARX64_round_2to6(search_round, 2,(Input_gamma & Bit_Align),(Input_beta & Bit_Align));
		// 左右两边的32bit都搜索
		//state = SPARX64_round_7toR(search_round,2,Input_gamma,Input_beta,x2,x3);
		state = SPARX64_round_2toR(search_round,2,x0,x1 , (u16)Input_gamma,(u16)Input_beta);

#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		wt_r[1] = P_1;
		//wt_r[1] = P_1;

		X_r[2][1] = (ROTATE_LEFT(Input_alpha, 7, blocksize_len)) & Bit_Align;
		X_r[3][1] = Input_beta  & Bit_Align;
		//X_r[2][1] = 0;
		//X_r[3][1] = 0;

		return 1;
	}
#endif
		}
	}
	return state;
}

u16 SPARX64_round_1_diff(u16 search_round)
{
	u16 best = 0;
	u16 X0_tmp=0,X1_tmp=0,X2_tmp=0,X3_tmp=0;
	u16 w_cmp = 0;
	u16 w_xor_l = 0;
	u16 w_xor_r = 0;
	u64 carry_l[8] ={0};
	u64 carry_r[8] ={0};
	u64 alpha_bloc_l[8] = {0};
	u64 alpha_bloc_r[8] = {0};
	u64 beta_bloc_l[8] = {0};
	u64 beta_bloc_r[8] = {0};
	u64 gamma_bloc_l[8] = {0};
	u64 gamma_bloc_r[8] = {0};
	u64 gamma_temp_l = 0;
	u64 gamma_temp_r = 0;
	u64 AB_block_l[8] = {0};
	u64 AB_block_r[8] = {0};
	u64 i0_l=0,i1_l=0,i0_r=0,i1_r=0;
	u64 j0_l=0,j1_l=0,j0_r=0,j1_r=0;


	if( search_round == 1)
	{
		return 1;
	}

	X0_tmp = (ROTATE_RIGHT(X_in_0,7,blocksize_len)) & Bit_Align;
	X1_tmp = X_in_1;
	X2_tmp = (ROTATE_RIGHT(X_in_2,7,blocksize_len)) & Bit_Align;
	X3_tmp = X_in_3;

	w_cmp = wt_max - n_P_bestofR_w[search_round - 1];

	//m0
	alpha_bloc_l[0] = X0_tmp & 0xFF; //8 bit
	beta_bloc_l[0]  = X1_tmp & 0xFF; //8 bit
	AB_block_l[0] = (alpha_bloc_l[0] << 8) | beta_bloc_l[0];
	carry_l[0] = 0;
	//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
	//m1
	alpha_bloc_l[1]= (X0_tmp >> 8) & 0xFF; //8 bit
	beta_bloc_l[1] = ( X1_tmp >> 8) & 0xFF; //8 bit
	AB_block_l[1] = (alpha_bloc_l[1] << 8) | beta_bloc_l[1];

	//m0
	alpha_bloc_r[0] = X2_tmp & 0xFF; //8 bit
	beta_bloc_r[0]  = X3_tmp & 0xFF; //8 bit
	AB_block_r[0] = (alpha_bloc_r[0] << 8) | beta_bloc_r[0];
	carry_r[0] = 0;
	//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
	//m1
	alpha_bloc_r[1]= (X2_tmp >> 8) & 0xFF; //8 bit
	beta_bloc_r[1] = (X3_tmp >> 8) & 0xFF; //8 bit
	AB_block_r[1] = (alpha_bloc_r[1] << 8) | beta_bloc_r[1];

	//printf("SPARX64 1 round ... \n");
	for(i0_l = cDDT_wt_min[carry_l[0]][AB_block_l[0]]; i0_l <= cDDT_wt_max[carry_l[0]][AB_block_l[0]]; i0_l++)
		{
			//if(i0_l > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0_l=0; j0_l < cDDT_n[carry_l[0]][AB_block_l[0]][i0_l]; j0_l++)
		{
			gamma_bloc_l[0] = cDDT_v[carry_l[0]][AB_block_l[0]][i0_l][j0_l];
			carry_l[1] = ((alpha_bloc_l[0] >> 7) << 2) //alpha MSB
					+ ((beta_bloc_l[0] >> 7) << 1)   //beta MSB
					+ (gamma_bloc_l[0] >> 7); // gamma MSB
		for(i1_l = MSB_cDDT_wt_min[carry_l[1]][AB_block_l[1]]; i1_l <= MSB_cDDT_wt_max[carry_l[1]][AB_block_l[1]]; i1_l++)
		{
			//if(i0_l + i1_l > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1_l=0; j1_l < MSB_cDDT_n[carry_l[1]][AB_block_l[1]][i1_l]; j1_l++)
		{
			gamma_bloc_l[1] = MSB_cDDT_v[carry_l[1]][AB_block_l[1]][i1_l][j1_l];
			gamma_temp_l = (gamma_bloc_l[1] <<8) | gamma_bloc_l[0];


		for(i0_r = cDDT_wt_min[carry_r[0]][AB_block_r[0]]; i0_r <= cDDT_wt_max[carry_r[0]][AB_block_r[0]]; i0_r++)
		{
			//if(i0_l + i1_l + i0_r > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0_r=0; j0_r < cDDT_n[carry_r[0]][AB_block_r[0]][i0_r]; j0_r++)
		{
			gamma_bloc_r[0] = cDDT_v[carry_r[0]][AB_block_r[0]][i0_r][j0_r];
			carry_r[1] = ((alpha_bloc_r[0] >> 7) << 2) //alpha MSB
					+ ((beta_bloc_r[0] >> 7) << 1)   //beta MSB
					+ (gamma_bloc_r[0] >> 7); // gamma MSB
		for(i1_r = MSB_cDDT_wt_min[carry_r[1]][AB_block_r[1]]; i1_r <= MSB_cDDT_wt_max[carry_r[1]][AB_block_r[1]]; i1_r++)
		{
			if(i0_l + i1_l + i0_r + i1_r > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1_r=0; j1_r < MSB_cDDT_n[carry_r[1]][AB_block_r[1]][i1_r]; j1_r++)
		{
			gamma_bloc_r[1] = MSB_cDDT_v[carry_r[1]][AB_block_r[1]][i1_r][j1_r];
			gamma_temp_r = (gamma_bloc_r[1] <<8) | gamma_bloc_r[0];

			P_w[1] = i0_l + i1_l + i0_r + i1_r;  //

			best = SPARX64_round_2toR_diff(search_round,2,
								gamma_temp_l,X1_tmp,
								gamma_temp_r,X3_tmp);

#if 0   //是否找到第一条最优路径就返回？
	if( best == 1 )
	{
/*
		wt_l[cur_round] = i0_l + i1_l;
		wt_r[cur_round] = i0_r + i1_r;
		X_r[0][cur_round] = x0;
		X_r[1][cur_round] = X1_tmp;
		X_r[2][cur_round] = x2;
		X_r[3][cur_round] = X3_tmp;
*/
		return 1;
	}
#endif
		}}
		}}
		}}
		}}

	return best;
}


u16 SPARX64_round_2toR(u16 search_round,u16 cur_round,u16 x0,u16 x1,u16 x2,u16 x3)
{
	u16 best = 0;
	u16 w_cmp = 0;
	u16 i = 0;
//	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 carry_l[8] ={0};
	u64 carry_r[8] ={0};
	u64 alpha_bloc_l[8] = {0};
	u64 alpha_bloc_r[8] = {0};
	u64 beta_bloc_l[8] = {0};
	u64 beta_bloc_r[8] = {0};
	u64 gamma_bloc_l[8] = {0};
	u64 gamma_bloc_r[8] = {0};
	u64 gamma_temp_l = 0;
	u64 gamma_temp_r = 0;
	u64 AB_block_l[8] = {0};
	u64 AB_block_r[8] = {0};
	u64 i0_l=0,i1_l=0,i0_r=0,i1_r=0;
	u64 j0_l=0,j1_l=0,j0_r=0,j1_r=0;
	//u16 *X0=0,*X1=0,*X2=0,*X3=0;
	u16 X0_tmp=0,X1_tmp=0,X2_tmp=0,X3_tmp=0;
	u16 xr0 =0,xr2=0;

	u16 w1=0,w2=0,w3=0;
	u16 xor_l = 0;
	u16 xor_r = 0;
	u16 w_xor_l = 0;
	u16 w_xor_l_H = 0;
	u16 w_xor_r_H = 0;
	u16 w_xor_r = 0;

	u64 carry_tmp_l = 0;
	u64 carry_tmp_r = 0;


	if(search_round == cur_round)
	{
		best = SPARX64_round_N(search_round, x0, x1,x2,x3);
		return best;
	}

	if(((cur_round -1) % 3) == 0) //4,7,10,13,16,...
	//if((cur_round ==7) || (cur_round ==10) || (cur_round ==13) || (cur_round ==16)) //(cur_round ==4)
	{
		X0_tmp = x0 & Bit_Align; //alpha l
		X1_tmp = (x0 ^ ROTATE_LEFT(x1,2,blocksize_len)) & Bit_Align; //beta l
		X2_tmp = x2 & Bit_Align; //alpha r
		X3_tmp = (x2 ^ ROTATE_LEFT(x3,2,blocksize_len)) & Bit_Align;  //beta r
		//L前后的需要输出
		IN_L_X[cur_round/3][0] = X0_tmp;  //记录的是L变换前的值
		IN_L_X[cur_round/3][1] = X1_tmp;
		IN_L_X[cur_round/3][2] = X2_tmp;
		IN_L_X[cur_round/3][3] = X3_tmp;

// L
		L2_Switch_per3Round(&X0_tmp, &X1_tmp, &X2_tmp, &X3_tmp);  // switch function.
//
		xr0 = X0_tmp;
		xr2 = X2_tmp;
		X0_tmp = (ROTATE_RIGHT(xr0,7,blocksize_len)) & Bit_Align;
		X2_tmp = (ROTATE_RIGHT(xr2,7,blocksize_len)) & Bit_Align;

		//printf("x0: %x x1: %x x2: %x x3: %x \n",*X0 ,*X1,*X2,*X3);
	}
	else
	{
		X0_tmp = (ROTATE_RIGHT(x0,7,blocksize_len)) & Bit_Align;
		X1_tmp = (x0 ^ ROTATE_LEFT(x1,2,blocksize_len)) & Bit_Align;
		X2_tmp = (ROTATE_RIGHT(x2,7,blocksize_len)) & Bit_Align;
		X3_tmp = (x2 ^ ROTATE_LEFT(x3,2,blocksize_len)) & Bit_Align;
	}

	xor_l = (X0_tmp ^ X1_tmp) & ValueMax_Align;
	xor_r = (X2_tmp ^ X3_tmp) & ValueMax_Align;
	//w_xor_l[0] = HM_weight(xor_l << 8);
	//w_xor_r[0] = HM_weight(xor_r << 8);
	//w_xor_r[1] = HM_weight(xor_r >> 8);
	w_xor_l = HM_weight(xor_l);
	w_xor_r = HM_weight(xor_r);
//	w_xor_l_H = HM_weight(xor_l >> 8);
//	w_xor_r_H = HM_weight(xor_r >> 8);
	if ( w_xor_l + w_xor_r > w_cmp)
	{
		return 0;
	}

	w_cmp = Bn_w - p_sumof_r_P_w[cur_round -1] - n_P_bestofR_w[search_round - cur_round];


	//m0
	alpha_bloc_l[0] = X0_tmp & 0xFF; //8 bit
	beta_bloc_l[0]  = X1_tmp & 0xFF; //8 bit
	AB_block_l[0] = (alpha_bloc_l[0] << 8) | beta_bloc_l[0];
	carry_l[0] = 0;
	//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
	//m1
	alpha_bloc_l[1]= X0_tmp & 0xFF00; //8 bit
	beta_bloc_l[1] = ( X1_tmp >> 8) & 0xFF; //8 bit
	AB_block_l[1] = alpha_bloc_l[1] | beta_bloc_l[1];
	w_xor_l_H = cDDT_AB_wt_min[AB_block_l[1]];

	//m0
	alpha_bloc_r[0] = X2_tmp & 0xFF; //8 bit
	beta_bloc_r[0]  = X3_tmp & 0xFF; //8 bit
	AB_block_r[0] = (alpha_bloc_r[0] << 8) | beta_bloc_r[0];
	carry_r[0] = 0;
	//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
	//m1
	alpha_bloc_r[1]= X2_tmp & 0xFF00; //8 bit
	beta_bloc_r[1] = (X3_tmp >> 8) & 0xFF; //8 bit
	AB_block_r[1] = alpha_bloc_r[1] | beta_bloc_r[1];
	w_xor_r_H = cDDT_AB_wt_min[AB_block_r[1]];

	carry_tmp_l = ((alpha_bloc_l[0] >> 7) << 2) + ((beta_bloc_l[0] >> 7) << 1);   //beta MSB
	carry_tmp_r = ((alpha_bloc_r[0] >> 7) << 2)	+ ((beta_bloc_r[0] >> 7) << 1);   //beta MSB

/// 每个block的wt的范围，wt_min 和 wt_max/限定 之间
	for(i0_l = cDDT_wt_min[carry_l[0]][AB_block_l[0]];
			i0_l <= cDDT_wt_min[carry_l[0]][AB_block_l[0]]; i0_l++)  //cDDT_wt_max[carry_l[0]][AB_block_l[0]]
	{
		if(w_xor_l_H + i0_l + w_xor_r > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j0_l=0; j0_l < cDDT_n[carry_l[0]][AB_block_l[0]][i0_l]; j0_l++)
	{
		gamma_bloc_l[0] = cDDT_v[carry_l[0]][AB_block_l[0]][i0_l][j0_l];
		carry_l[1] = carry_tmp_l + (gamma_bloc_l[0] >> 7); // gamma MSB
	for(i1_l = MSB_cDDT_wt_min[carry_l[1]][AB_block_l[1]];
			i1_l <= MSB_cDDT_wt_min[carry_l[1]][AB_block_l[1]]; i1_l++) //MSB_cDDT_wt_max[carry_l[1]][AB_block_l[1]]
	{
		w1 = i0_l + i1_l;
		if(w1 + w_xor_r > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1_l=0; j1_l < MSB_cDDT_n[carry_l[1]][AB_block_l[1]][i1_l]; j1_l++)
	{
		gamma_bloc_l[1] = MSB_cDDT_v[carry_l[1]][AB_block_l[1]][i1_l][j1_l];
		gamma_temp_l = ((gamma_bloc_l[1] <<8) | gamma_bloc_l[0]) & 0xFFFF;

//////

	for(i0_r = cDDT_wt_min[carry_r[0]][AB_block_r[0]];
			i0_r <= cDDT_wt_min[carry_r[0]][AB_block_r[0]]; i0_r++)  //cDDT_wt_max[carry_r[0]][AB_block_r[0]]
	{
		w2 = w1 + i0_r;
		if(w2 + w_xor_r_H > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j0_r=0; j0_r < cDDT_n[carry_r[0]][AB_block_r[0]][i0_r]; j0_r++)
	{
		gamma_bloc_r[0] = cDDT_v[carry_r[0]][AB_block_r[0]][i0_r][j0_r];
		carry_r[1] = carry_tmp_r + (gamma_bloc_r[0] >> 7); // gamma MSB
	for(i1_r = MSB_cDDT_wt_min[carry_r[1]][AB_block_r[1]];
			i1_r <= MSB_cDDT_wt_min[carry_r[1]][AB_block_r[1]]; i1_r++)  //MSB_cDDT_wt_max[carry_r[1]][AB_block_r[1]]
	{
		w3 = w2 + i1_r;
		if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		P_w[cur_round] = w3;  //
		p_sumof_r_P_w[cur_round] = p_sumof_r_P_w[cur_round-1] + P_w[cur_round];
	for(j1_r=0; j1_r < MSB_cDDT_n[carry_r[1]][AB_block_r[1]][i1_r]; j1_r++)
	{
		gamma_bloc_r[1] = MSB_cDDT_v[carry_r[1]][AB_block_r[1]][i1_r][j1_r];
		gamma_temp_r = ((gamma_bloc_r[1] <<8) | gamma_bloc_r[0]) & 0xFFFF;


		best = SPARX64_round_2toR(search_round,cur_round +1,
							gamma_temp_l,X1_tmp,
							gamma_temp_r,X3_tmp);

#if 1   //是否找到第一条最优路径就返回？
	if( best == 1 )
	{
		wt_l[cur_round] = i0_l + i1_l;
		wt_r[cur_round] = i0_r + i1_r;

		//if((cur_round ==7) || (cur_round ==10) || (cur_round ==13) || (cur_round ==16))
		if(((cur_round -1) % 3) == 0) //4,7,10,13,16,...
		{
			X_r[0][cur_round] = xr0;
			X_r[1][cur_round] = X1_tmp;
			X_r[2][cur_round] = xr2;
			X_r[3][cur_round] = X3_tmp;
		}
		else
		{
			X_r[0][cur_round] = x0;
			X_r[1][cur_round] = X1_tmp;
			X_r[2][cur_round] = x2;
			X_r[3][cur_round] = X3_tmp;
		}

		return 1;
	}
#endif
	}}
	}}
	}}
	}}

	return best;
}

u16 SPARX64_round_2toR_diff(u16 search_round,u16 cur_round,u16 x0,u16 x1,u16 x2,u16 x3)
{
	u16 best = 0;
	u16 w_cmp = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 carry_l[8] ={0};
	u64 carry_r[8] ={0};
	u64 alpha_bloc_l[8] = {0};
	u64 alpha_bloc_r[8] = {0};
	u64 beta_bloc_l[8] = {0};
	u64 beta_bloc_r[8] = {0};
	u64 gamma_bloc_l[8] = {0};
	u64 gamma_bloc_r[8] = {0};
	u64 gamma_temp_l = 0;
	u64 gamma_temp_r = 0;
	u64 AB_block_l[8] = {0};
	u64 AB_block_r[8] = {0};
	u64 i0_l=0,i1_l=0,i0_r=0,i1_r=0;
	u64 j0_l=0,j1_l=0,j0_r=0,j1_r=0;
	//u16 *X0=0,*X1=0,*X2=0,*X3=0;
	u16 X0_tmp=0,X1_tmp=0,X2_tmp=0,X3_tmp=0;
	u16 xr0 =0,xr2=0;

	u16 w1=0,w2=0,w3=0;
	u16 xor_l = 0;
	u16 xor_r = 0;
	u16 w_xor_l = 0;
	u16 w_xor_l_H = 0;
	u16 w_xor_r_H = 0;
	u16 w_xor_r = 0;

	u64 carry_tmp_l = 0;
	u64 carry_tmp_r = 0;

	if(search_round == cur_round)
	{
		best = SPARX64_round_N_diff(search_round, x0,x1,x2,x3);
		return best;
	}

	if(((cur_round -1) % 3) == 0) //4，7,10,13,16,...
	//if((cur_round ==7) || (cur_round ==10) || (cur_round ==13) || (cur_round ==16)) //(cur_round ==4)
	{
		X0_tmp = x0 & Bit_Align; //alpha l
		X1_tmp = (x0 ^ ROTATE_LEFT(x1,2,blocksize_len)) & Bit_Align; //beta l
		X2_tmp = x2 & Bit_Align; //alpha l
		X3_tmp = (x2 ^ ROTATE_LEFT(x3,2,blocksize_len)) & Bit_Align;  //beta r

		L2_Switch_per3Round(&X0_tmp, &X1_tmp, &X2_tmp, &X3_tmp);  // switch function.

		xr0 = X0_tmp;
		xr2 = X2_tmp;
		X0_tmp = (ROTATE_RIGHT(xr0,7,blocksize_len)) & Bit_Align;
		X2_tmp = (ROTATE_RIGHT(xr2,7,blocksize_len)) & Bit_Align;
		//printf("x0: %x x1: %x x2: %x x3: %x \n",*X0 ,*X1,*X2,*X3);
	}
	else
	{
		X0_tmp = (ROTATE_RIGHT(x0,7,blocksize_len)) & Bit_Align;
		X1_tmp = (x0 ^ ROTATE_LEFT(x1,2,blocksize_len)) & Bit_Align;
		X2_tmp = (ROTATE_RIGHT(x2,7,blocksize_len)) & Bit_Align;
		X3_tmp = (x2 ^ ROTATE_LEFT(x3,2,blocksize_len)) & Bit_Align;
	}

	xor_l = (X0_tmp ^ X1_tmp) & ValueMax_Align;
	xor_r = (X2_tmp ^ X3_tmp) & ValueMax_Align;
	w_xor_l = HM_weight(xor_l);
	w_xor_r = HM_weight(xor_r);

	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r - n_P_bestofR_w[search_round - cur_round];
	if ( w_xor_l + w_xor_r > w_cmp)
	{
		return 0;
	}

	//m0
	alpha_bloc_l[0] = X0_tmp & 0xFF; //8 bit
	beta_bloc_l[0]  = X1_tmp & 0xFF; //8 bit
	AB_block_l[0] = (alpha_bloc_l[0] << 8) | beta_bloc_l[0];
	carry_l[0] = 0;
	//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
	//m1
	alpha_bloc_l[1]= X0_tmp & 0xFF00; //8 bit
	beta_bloc_l[1] = ( X1_tmp >> 8) & 0xFF; //8 bit
	AB_block_l[1] = alpha_bloc_l[1] | beta_bloc_l[1];
	w_xor_l_H = cDDT_AB_wt_min[AB_block_l[1]];

	//m0
	alpha_bloc_r[0] = X2_tmp & 0xFF; //8 bit
	beta_bloc_r[0]  = X3_tmp & 0xFF; //8 bit
	AB_block_r[0] = (alpha_bloc_r[0] << 8) | beta_bloc_r[0];
	carry_r[0] = 0;
	//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
	//m1
	alpha_bloc_r[1]= X2_tmp & 0xFF00; //8 bit
	beta_bloc_r[1] = (X3_tmp >> 8) & 0xFF; //8 bit
	AB_block_r[1] = alpha_bloc_r[1] | beta_bloc_r[1];
	w_xor_r_H = cDDT_AB_wt_min[AB_block_r[1]];

	carry_tmp_l = ((alpha_bloc_l[0] >> 7) << 2) + ((beta_bloc_l[0] >> 7) << 1);   //beta MSB
	carry_tmp_r = ((alpha_bloc_r[0] >> 7) << 2)	+ ((beta_bloc_r[0] >> 7) << 1);   //beta MSB

	for(i0_l = cDDT_wt_min[carry_l[0]][AB_block_l[0]]; i0_l <= cDDT_wt_max[carry_l[0]][AB_block_l[0]]; i0_l++)
	{
		if(w_xor_l_H + i0_l + w_xor_r > w_cmp ){break;} //break 要比 continue 高效,直接结束.
	for(j0_l=0; j0_l < cDDT_n[carry_l[0]][AB_block_l[0]][i0_l]; j0_l++)
	{
		gamma_bloc_l[0] = cDDT_v[carry_l[0]][AB_block_l[0]][i0_l][j0_l];
		carry_l[1] = carry_tmp_l + (gamma_bloc_l[0] >> 7); // gamma MSB
	for(i1_l = MSB_cDDT_wt_min[carry_l[1]][AB_block_l[1]]; i1_l <= MSB_cDDT_wt_max[carry_l[1]][AB_block_l[1]]; i1_l++)
	{
		w1 = i0_l + i1_l;
		if(w1 + w_xor_r > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1_l=0; j1_l < MSB_cDDT_n[carry_l[1]][AB_block_l[1]][i1_l]; j1_l++)
	{
		gamma_bloc_l[1] = MSB_cDDT_v[carry_l[1]][AB_block_l[1]][i1_l][j1_l];
		gamma_temp_l = (gamma_bloc_l[1] <<8) | gamma_bloc_l[0];

/////
	for(i0_r = cDDT_wt_min[carry_r[0]][AB_block_r[0]]; i0_r <= cDDT_wt_max[carry_r[0]][AB_block_r[0]]; i0_r++)
	{
		w2 = w1 + i0_r;
		if(w2 + w_xor_r_H > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j0_r=0; j0_r < cDDT_n[carry_r[0]][AB_block_r[0]][i0_r]; j0_r++)
	{
		gamma_bloc_r[0] = cDDT_v[carry_r[0]][AB_block_r[0]][i0_r][j0_r];
		carry_r[1] = carry_tmp_r + (gamma_bloc_r[0] >> 7); // gamma MSB
	for(i1_r = MSB_cDDT_wt_min[carry_r[1]][AB_block_r[1]]; i1_r <= MSB_cDDT_wt_max[carry_r[1]][AB_block_r[1]]; i1_r++)
	{
		w3 = w2 + i1_r;
		if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		P_w[cur_round] = w3;     //break 要比 continue 高效,直接结束.
	for(j1_r=0; j1_r < MSB_cDDT_n[carry_r[1]][AB_block_r[1]][i1_r]; j1_r++)
	{
		gamma_bloc_r[1] = MSB_cDDT_v[carry_r[1]][AB_block_r[1]][i1_r][j1_r];
		gamma_temp_r = (gamma_bloc_r[1] <<8) | gamma_bloc_r[0];

		//P_w[cur_round] = i0_l + i1_l + i0_r + i1_r;  //

		best = SPARX64_round_2toR_diff(search_round,cur_round +1,
							gamma_temp_l,X1_tmp,
							gamma_temp_r,X3_tmp);

#if 0   //是否找到第一条最优路径就返回？
	if( best == 1 )
	{
		wt_l[cur_round] = i0_l + i1_l;
		wt_r[cur_round] = i0_r + i1_r;

		if((cur_round ==7) || (cur_round ==10) || (cur_round ==13) || (cur_round ==16))
		{
			X_r[0][cur_round] = xr0;
			X_r[1][cur_round] = X1_tmp;
			X_r[2][cur_round] = xr2;
			X_r[3][cur_round] = X3_tmp;
		}
		else
		{
			X_r[0][cur_round] = x0;
			X_r[1][cur_round] = X1_tmp;
			X_r[2][cur_round] = x2;
			X_r[3][cur_round] = X3_tmp;
		}

		return 1;
	}
#endif
	}}
	}}
	}}
	}}

	return best;
}

u16 SPARX64_round_7toR(u16 search_round,u16 cur_round,u16 x0,u16 x1,u16 x2,u16 x3)
{
	u16 best = 0;
	u16 w_cmp = 0;
	u16 w_xor_l = 0;
	u16 w_xor_r = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 carry_l[8] ={0};
	u64 carry_r[8] ={0};
	u64 alpha_bloc_l[8] = {0};
	u64 alpha_bloc_r[8] = {0};
	u64 beta_bloc_l[8] = {0};
	u64 beta_bloc_r[8] = {0};
	u64 gamma_bloc_l[8] = {0};
	u64 gamma_bloc_r[8] = {0};
	u64 gamma_temp_l = 0;
	u64 gamma_temp_r = 0;
	u64 AB_block_l[8] = {0};
	u64 AB_block_r[8] = {0};
	u64 i0_l=0,i1_l=0,i0_r=0,i1_r=0;
	u64 j0_l=0,j1_l=0,j0_r=0,j1_r=0;
	//u16 *X0=0,*X1=0,*X2=0,*X3=0;
	u16 X0_tmp=0,X1_tmp=0,X2_tmp=0,X3_tmp=0;
	u16 xr0 =0,xr2=0;

	if(search_round == cur_round)
	{
		best = SPARX64_round_N(search_round, x0, x1,x2,x3);
		return best;
	}

	if(((cur_round -1) % 3) == 0) //7,10,13,16,...
	//if((cur_round ==7) || (cur_round ==10) || (cur_round ==13) || (cur_round ==16)) //(cur_round ==4)
	{
		X0_tmp = x0 & Bit_Align; //alpha l
		X2_tmp = x2 & Bit_Align; //alpha l
		X1_tmp = (x0 ^ ROTATE_LEFT(x1,2,blocksize_len)) & Bit_Align; //beta l
		X3_tmp = (x2 ^ ROTATE_LEFT(x3,2,blocksize_len)) & Bit_Align;  //beta r

		L2_Switch_per3Round(&X0_tmp, &X1_tmp, &X2_tmp, &X3_tmp);  // switch function.

		xr0 = X0_tmp;
		xr2 = X2_tmp;
		X0_tmp = (ROTATE_RIGHT(xr0,7,blocksize_len)) & Bit_Align;
		X2_tmp = (ROTATE_RIGHT(xr2,7,blocksize_len)) & Bit_Align;
		//printf("x0: %x x1: %x x2: %x x3: %x \n",*X0 ,*X1,*X2,*X3);
	}
	else
	{
		X0_tmp = (ROTATE_RIGHT(x0,7,blocksize_len)) & Bit_Align;
		X1_tmp = (x0 ^ ROTATE_LEFT(x1,2,blocksize_len)) & Bit_Align;
		X2_tmp = (ROTATE_RIGHT(x2,7,blocksize_len)) & Bit_Align;
		X3_tmp = (x2 ^ ROTATE_LEFT(x3,2,blocksize_len)) & Bit_Align;
	}

	//w_xor_l = HM_weight((*X0 ^ *X1) & ValueMax_Align);
	//w_xor_r = HM_weight((*X2 ^ *X3) & ValueMax_Align);
	w_xor_l = HM_weight((X0_tmp ^ X1_tmp) & ValueMax_Align);
	w_xor_r = HM_weight((X2_tmp ^ X3_tmp) & ValueMax_Align);

	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = Bn_w - p_sumof_r - n_P_bestofR_w[search_round - cur_round];
	if ( w_xor_l + w_xor_r > w_cmp)
	{
		return 0;
	}

	//m0
	alpha_bloc_l[0] = X0_tmp & 0xFF; //8 bit
	beta_bloc_l[0]  = X1_tmp & 0xFF; //8 bit
	AB_block_l[0] = (alpha_bloc_l[0] << 8) | beta_bloc_l[0];
	carry_l[0] = 0;
	//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
	//m1
	alpha_bloc_l[1]= (X0_tmp >> 8) & 0xFF; //8 bit
	beta_bloc_l[1] = ( X1_tmp >> 8) & 0xFF; //8 bit
	AB_block_l[1] = (alpha_bloc_l[1] << 8) | beta_bloc_l[1];

	//m0
	alpha_bloc_r[0] = X2_tmp & 0xFF; //8 bit
	beta_bloc_r[0]  = X3_tmp & 0xFF; //8 bit
	AB_block_r[0] = (alpha_bloc_r[0] << 8) | beta_bloc_r[0];
	carry_r[0] = 0;
	//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
	//m1
	alpha_bloc_r[1]= (X2_tmp >> 8) & 0xFF; //8 bit
	beta_bloc_r[1] = (X3_tmp >> 8) & 0xFF; //8 bit
	AB_block_r[1] = (alpha_bloc_r[1] << 8) | beta_bloc_r[1];


	for(i0_l = 0; i0_l <= cDDT_wt_max[carry_l[0]][AB_block_l[0]]; i0_l++)
	{
		if(i0_l > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j0_l=0; j0_l < cDDT_n[carry_l[0]][AB_block_l[0]][i0_l]; j0_l++)
	{
		gamma_bloc_l[0] = cDDT_v[carry_l[0]][AB_block_l[0]][i0_l][j0_l];
		carry_l[1] = ((alpha_bloc_l[0] >> 7) << 2) //alpha MSB
				+ ((beta_bloc_l[0] >> 7) << 1)   //beta MSB
				+ (gamma_bloc_l[0] >> 7); // gamma MSB
	for(i1_l = 0; i1_l <= MSB_cDDT_wt_max[carry_l[1]][AB_block_l[1]]; i1_l++)
	{
		if(i0_l + i1_l > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1_l=0; j1_l < MSB_cDDT_n[carry_l[1]][AB_block_l[1]][i1_l]; j1_l++)
	{
		gamma_bloc_l[1] = MSB_cDDT_v[carry_l[1]][AB_block_l[1]][i1_l][j1_l];
		gamma_temp_l = (gamma_bloc_l[1] <<8) | gamma_bloc_l[0];


	for(i0_r = 0; i0_r <= cDDT_wt_max[carry_r[0]][AB_block_r[0]]; i0_r++)
	{
		if(i0_l + i1_l + i0_r > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j0_r=0; j0_r < cDDT_n[carry_r[0]][AB_block_r[0]][i0_r]; j0_r++)
	{
		gamma_bloc_r[0] = cDDT_v[carry_r[0]][AB_block_r[0]][i0_r][j0_r];
		carry_r[1] = ((alpha_bloc_r[0] >> 7) << 2) //alpha MSB
				+ ((beta_bloc_r[0] >> 7) << 1)   //beta MSB
				+ (gamma_bloc_r[0] >> 7); // gamma MSB
	for(i1_r = 0; i1_r <= MSB_cDDT_wt_max[carry_r[1]][AB_block_r[1]]; i1_r++)
	{
		if(i0_l + i1_l + i0_r + i1_r > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1_r=0; j1_r < MSB_cDDT_n[carry_r[1]][AB_block_r[1]][i1_r]; j1_r++)
	{
		gamma_bloc_r[1] = MSB_cDDT_v[carry_r[1]][AB_block_r[1]][i1_r][j1_r];
		gamma_temp_r = (gamma_bloc_r[1] <<8) | gamma_bloc_r[0];

		P_w[cur_round] = i0_l + i1_l + i0_r + i1_r;  //

		best = SPARX64_round_7toR(search_round,cur_round +1,
							gamma_temp_l,X1_tmp,
							gamma_temp_r,X3_tmp);

#if 1   //是否找到第一条最优路径就返回？
	if( best == 1 )
	{
		wt_l[cur_round] = i0_l + i1_l;
		wt_r[cur_round] = i0_r + i1_r;

		if((cur_round ==7) || (cur_round ==10) || (cur_round ==13) || (cur_round ==16))
		{
			X_r[0][cur_round] = xr0;
			X_r[1][cur_round] = X1_tmp;
			X_r[2][cur_round] = xr2;
			X_r[3][cur_round] = X3_tmp;
		}
		else
		{
			X_r[0][cur_round] = x0;
			X_r[1][cur_round] = X1_tmp;
			X_r[2][cur_round] = x2;
			X_r[3][cur_round] = X3_tmp;
		}

		return 1;
	}
#endif
	}}
	}}
	}}
	}}

	return best;
}


u16 SPARX64_round_N(u16 search_round,u16 x0,u16 x1,u16 x2,u16 x3)
{
	u16 best = 0;
	u16 w_cmp = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 carry_l[8] ={0};
	u64 carry_r[8] ={0};
	u64 alpha_bloc_l[8] = {0};
	u64 alpha_bloc_r[8] = {0};
	u64 beta_bloc_l[8] = {0};
	u64 beta_bloc_r[8] = {0};
	u64 gamma_bloc_l[8] = {0};
	u64 gamma_bloc_r[8] = {0};
	u64 gamma_temp_l = 0;
	u64 gamma_temp_r = 0;
	u64 AB_block_l[8] = {0};
	u64 AB_block_r[8] = {0};
	u64 i0_l=0,i1_l=0,i0_r=0,i1_r=0;
	u64 j0_l=0,j1_l=0,j0_r=0,j1_r=0;
	//u16 *X0=0,*X1=0,*X2=0,*X3=0;
	u16 X0_tmp=0,X1_tmp=0,X2_tmp=0,X3_tmp=0;
	u16 X0_tmp_last=0,X1_tmp_last=0,X2_tmp_last=0,X3_tmp_last=0;
	u16 xr0 =0,xr2=0;

	u16 w1=0,w2=0,w3=0;
	u16 xor_l = 0;
	u16 xor_r = 0;
	u16 w_xor_l = 0;
	u16 w_xor_l_H = 0;
	u16 w_xor_r_H = 0;
	u16 w_xor_r = 0;

	u64 carry_tmp_l = 0;
	u64 carry_tmp_r = 0;


	if(((search_round -1) % 3) == 0) //7,10,13,16,...
	//if((search_round ==7) || (search_round ==10) || (search_round ==13) || (search_round ==16))
	{
		X0_tmp = x0 & Bit_Align; //alpha l
		X2_tmp = x2 & Bit_Align; //alpha l
		X1_tmp = (x0 ^ ROTATE_LEFT(x1,2,blocksize_len)) & Bit_Align; //beta l
		X3_tmp = (x2 ^ ROTATE_LEFT(x3,2,blocksize_len)) & Bit_Align;  //beta r

		IN_L_X[search_round/3][0] = X0_tmp;
		IN_L_X[search_round/3][1] = X1_tmp;
		IN_L_X[search_round/3][2] = X2_tmp;
		IN_L_X[search_round/3][3] = X3_tmp;

//		printf("x1:%x  X0_tmp: %x X1_tmp: %x X2_tmp: %x X3_tmp: %x \n",x1,X0_tmp ,X1_tmp,X2_tmp,X3_tmp);
		L2_Switch_per3Round(&X0_tmp, &X1_tmp, &X2_tmp, &X3_tmp);  // switch function.
//		printf("x1:%x   x0: %x x1: %x x2: %x x3: %x \n",x1,X0_tmp ,X1_tmp,X2_tmp,X3_tmp);

		xr0 = X0_tmp;
		xr2 = X2_tmp;
		X0_tmp = (ROTATE_RIGHT(xr0,7,blocksize_len)) & Bit_Align;
		X2_tmp = (ROTATE_RIGHT(xr2,7,blocksize_len)) & Bit_Align;
	}
	else
	{
		X0_tmp = (ROTATE_RIGHT(x0,7,blocksize_len)) & Bit_Align;
		X1_tmp = (x0 ^ ROTATE_LEFT(x1,2,blocksize_len)) & Bit_Align;
		X2_tmp = (ROTATE_RIGHT(x2,7,blocksize_len)) & Bit_Align;
		X3_tmp = (x2 ^ ROTATE_LEFT(x3,2,blocksize_len)) & Bit_Align;
	}

	w_xor_l = HM_weight((X0_tmp ^ X1_tmp) & ValueMax_Align);
	w_xor_r = HM_weight((X2_tmp ^ X3_tmp) & ValueMax_Align);
	if (w_xor_l + w_xor_r > w_cmp)
	{
		return 0;
	}

	w_cmp = Bn_w - p_sumof_r_P_w[search_round -1];
	if (p_sumof_r == 0)
	{
		return 0;
	}


	//m0
	alpha_bloc_l[0] = X0_tmp & 0xFF; //8 bit
	beta_bloc_l[0]  = X1_tmp & 0xFF; //8 bit
	AB_block_l[0] = (alpha_bloc_l[0] << 8) | beta_bloc_l[0];
	carry_l[0] = 0;
	//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
	//m1
	alpha_bloc_l[1]= X0_tmp & 0xFF00; //8 bit
	beta_bloc_l[1] = ( X1_tmp >> 8) & 0xFF; //8 bit
	AB_block_l[1] = alpha_bloc_l[1] | beta_bloc_l[1];
	w_xor_l_H = cDDT_AB_wt_min[AB_block_l[1]];

	//m0
	alpha_bloc_r[0] = X2_tmp & 0xFF; //8 bit
	beta_bloc_r[0]  = X3_tmp & 0xFF; //8 bit
	AB_block_r[0] = (alpha_bloc_r[0] << 8) | beta_bloc_r[0];
	carry_r[0] = 0;
	//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
	//m1
	alpha_bloc_r[1]= X2_tmp & 0xFF00; //8 bit
	beta_bloc_r[1] = (X3_tmp >> 8) & 0xFF; //8 bit
	AB_block_r[1] = alpha_bloc_r[1] | beta_bloc_r[1];
	w_xor_r_H = cDDT_AB_wt_min[AB_block_r[1]];


	carry_tmp_l = ((alpha_bloc_l[0] >> 7) << 2) + ((beta_bloc_l[0] >> 7) << 1);   //beta MSB
	carry_tmp_r = ((alpha_bloc_r[0] >> 7) << 2)	+ ((beta_bloc_r[0] >> 7) << 1);   //beta MSB


	//最后一轮，只用考虑每个block的最小的概率重量即可
	//printf("test--------------9----------------> \n");
	for(i0_l = cDDT_wt_min[carry_l[0]][AB_block_l[0]];
			i0_l <= cDDT_wt_min[carry_l[0]][AB_block_l[0]]; i0_l++) //cDDT_wt_max[carry_l[0]][AB_block_l[0]]
	{
		if(w_xor_l_H + i0_l + w_xor_r > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j0_l=0; j0_l < cDDT_n[carry_l[0]][AB_block_l[0]][i0_l]; j0_l++)
	{
		gamma_bloc_l[0] = cDDT_v[carry_l[0]][AB_block_l[0]][i0_l][j0_l];
		carry_l[1] = ((alpha_bloc_l[0] >> 7) << 2) //alpha MSB
				+ ((beta_bloc_l[0] >> 7) << 1)   //beta MSB
				+ (gamma_bloc_l[0] >> 7); // gamma MSB
	for(i1_l = MSB_cDDT_wt_min[carry_l[1]][AB_block_l[1]];
			i1_l <= MSB_cDDT_wt_min[carry_l[1]][AB_block_l[1]]; i1_l++)  //MSB_cDDT_wt_max[carry_l[1]][AB_block_l[1]]
	{
		w1 = i0_l + i1_l;
		if(w1 + w_xor_r > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1_l=0; j1_l < MSB_cDDT_n[carry_l[1]][AB_block_l[1]][i1_l]; j1_l++)
	{
		gamma_bloc_l[1] = MSB_cDDT_v[carry_l[1]][AB_block_l[1]][i1_l][j1_l];
		gamma_temp_l = (gamma_bloc_l[1] <<8) | gamma_bloc_l[0];

/////
	for(i0_r = cDDT_wt_min[carry_r[0]][AB_block_r[0]];
			i0_r <= cDDT_wt_min[carry_r[0]][AB_block_r[0]]; i0_r++)  //cDDT_wt_max[carry_r[0]][AB_block_r[0]]
	{
		w2 = w1 + i0_r;
		if(w2 + w_xor_r_H > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j0_r=0; j0_r < cDDT_n[carry_r[0]][AB_block_r[0]][i0_r]; j0_r++)
	{
		gamma_bloc_r[0] = cDDT_v[carry_r[0]][AB_block_r[0]][i0_r][j0_r];
		carry_r[1] = ((alpha_bloc_r[0] >> 7) << 2) //alpha MSB
				+ ((beta_bloc_r[0] >> 7) << 1)   //beta MSB
				+ (gamma_bloc_r[0] >> 7); // gamma MSB

	for(i1_r = MSB_cDDT_wt_min[carry_r[1]][AB_block_r[1]];
			i1_r <= MSB_cDDT_wt_min[carry_r[1]][AB_block_r[1]]; i1_r++)  //MSB_cDDT_wt_max[carry_r[1]][AB_block_r[1]]
	{
		w3 = w2 + i1_r;
//		if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		if(w3 == w_cmp )//直接结束.
		{
#if 0  //若找到的与Ankle等文献的一致，则重新找一条。
			if(FIRST < 2)
			{
				FIRST++;
			}
#endif

	for(j1_r=0; j1_r < MSB_cDDT_n[carry_r[1]][AB_block_r[1]][i1_r]; j1_r++)
	{
		gamma_bloc_r[1] = MSB_cDDT_v[carry_r[1]][AB_block_r[1]][i1_r][j1_r];
		gamma_temp_r = (gamma_bloc_r[1] <<8) | gamma_bloc_r[0];

		P_w[search_round] = w3;  //i0_l + i1_l + i0_r + i1_r;  //
		wt_l[search_round] = i0_l + i1_l;
		wt_r[search_round] = i0_r + i1_r;

		best  = 1;
		n_P_bestofR_w[search_round] = Bn_w;

		if(((search_round -1) % 3) == 0) //4,7,10,13,16,...
		//if((search_round ==7) || (search_round ==10) || (search_round ==13) || (search_round ==16))
		{
			X_r[0][search_round] = xr0;
			X_r[1][search_round] = X1_tmp;
			X_r[2][search_round] = xr2;
			X_r[3][search_round] = X3_tmp;
		}
		else
		{
			X_r[0][search_round] = x0;
			X_r[1][search_round] = X1_tmp;
			X_r[2][search_round] = x2;
			X_r[3][search_round] = X3_tmp;
		}

		if((search_round % 3) == 0) //3,6,9,12,15....
		{
			X0_tmp_last = gamma_temp_l;
			X1_tmp_last = gamma_temp_l ^ (ROTATE_LEFT(X1_tmp, 2,blocksize_len) & Bit_Align);
			X2_tmp_last = gamma_temp_r;
			X3_tmp_last = gamma_temp_r ^ (ROTATE_LEFT(X3_tmp, 2,blocksize_len) & Bit_Align);

			IN_L_X[search_round/3][0] = X0_tmp_last;
			IN_L_X[search_round/3][1] = X1_tmp_last;
			IN_L_X[search_round/3][2] = X2_tmp_last;
			IN_L_X[search_round/3][3] = X3_tmp_last;

			L2_Switch_per3Round(&X0_tmp_last, &X1_tmp_last, &X2_tmp_last, &X3_tmp_last);  // switch function.

			X_r[0][search_round +1] = X0_tmp_last;
			X_r[1][search_round +1] = X1_tmp_last;
			X_r[2][search_round +1] = X2_tmp_last;
			X_r[3][search_round +1] = X3_tmp_last;

		}
		else
		{
			X_r[0][search_round +1] = gamma_temp_l;
			X_r[1][search_round +1] = gamma_temp_l ^ (ROTATE_LEFT(X1_tmp, 2,blocksize_len) & Bit_Align);
			X_r[2][search_round +1] = gamma_temp_r;
			X_r[3][search_round +1] = gamma_temp_r ^ (ROTATE_LEFT(X3_tmp, 2,blocksize_len) & Bit_Align);
		}

#if 0
		if(FIRST < 2)
		{
			FIRST++;
		}
		else

		if(FIRST >= 2)
		{
			return 1;   //返回一条最优差分路径
		}
#endif

		return 1;   //返回一条最优差分路径
	}
	}}}}}}}}

	return best;
}
u16 SPARX64_round_N_diff(u16 search_round,u16 x0,u16 x1,u16 x2,u16 x3)
{
	u16 best = 0;
	u16 w_cmp = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 carry_l[8] ={0};
	u64 carry_r[8] ={0};
	u64 alpha_bloc_l[8] = {0};
	u64 alpha_bloc_r[8] = {0};
	u64 beta_bloc_l[8] = {0};
	u64 beta_bloc_r[8] = {0};
	u64 gamma_bloc_l[8] = {0};
	u64 gamma_bloc_r[8] = {0};
	u64 gamma_temp_l = 0;
	u64 gamma_temp_r = 0;
	u64 AB_block_l[8] = {0};
	u64 AB_block_r[8] = {0};
	u64 i0_l=0,i1_l=0,i0_r=0,i1_r=0;
	u64 j0_l=0,j1_l=0,j0_r=0,j1_r=0;
	//u16 *X0=0,*X1=0,*X2=0,*X3=0;
	u16 X0_tmp=0,X1_tmp=0,X2_tmp=0,X3_tmp=0;
	u16 xr0=0,xr2=0;
	u16 yr1=0,yr3=0;

	u16 w1=0,w2=0,w3=0;
	u16 xor_l = 0;
	u16 xor_r = 0;
	u16 w_xor_l = 0;
	u16 w_xor_l_H = 0;
	u16 w_xor_r_H = 0;
	u16 w_xor_r = 0;


	if(((search_round -1) % 3) == 0) //7,10,13,16,...
	//if((search_round ==7) || (search_round ==10) || (search_round ==13) || (search_round ==16))
	{
		X0_tmp = x0 & Bit_Align; //alpha l
		X2_tmp = x2 & Bit_Align; //alpha l
		X1_tmp = (x0 ^ ROTATE_LEFT(x1,2,blocksize_len)) & Bit_Align; //beta l
		X3_tmp = (x2 ^ ROTATE_LEFT(x3,2,blocksize_len)) & Bit_Align;  //beta r

		L2_Switch_per3Round(&X0_tmp, &X1_tmp, &X2_tmp, &X3_tmp);  // switch function.

		xr0 = X0_tmp;
		xr2 = X2_tmp;
		X0_tmp = (ROTATE_RIGHT(xr0,7,blocksize_len)) & Bit_Align;
		X2_tmp = (ROTATE_RIGHT(xr2,7,blocksize_len)) & Bit_Align;
	}
	else
	{
		X0_tmp = (ROTATE_RIGHT(x0,7,blocksize_len)) & Bit_Align;
		X1_tmp = (x0 ^ ROTATE_LEFT(x1,2,blocksize_len)) & Bit_Align;
		X2_tmp = (ROTATE_RIGHT(x2,7,blocksize_len)) & Bit_Align;
		X3_tmp = (x2 ^ ROTATE_LEFT(x3,2,blocksize_len)) & Bit_Align;
	}

	xor_l = (X0_tmp ^ X1_tmp) & ValueMax_Align;
	xor_r = (X2_tmp ^ X3_tmp) & ValueMax_Align;
	w_xor_l = HM_weight(xor_l);
	w_xor_r = HM_weight(xor_r);

	for(i=1; i < search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r;
	if (w_xor_l + w_xor_r > w_cmp)
	{
		return 0;
	}


	//m0
	alpha_bloc_l[0] = X0_tmp & 0xFF; //8 bit
	beta_bloc_l[0]  = X1_tmp & 0xFF; //8 bit
	AB_block_l[0] = (alpha_bloc_l[0] << 8) | beta_bloc_l[0];
	carry_l[0] = 0;
	//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
	//m1
	alpha_bloc_l[1]= X0_tmp & 0xFF00; //8 bit
	beta_bloc_l[1] = ( X1_tmp >> 8) & 0xFF; //8 bit
	AB_block_l[1] = alpha_bloc_l[1] | beta_bloc_l[1];
	w_xor_l_H = cDDT_AB_wt_min[AB_block_l[1]];

	//m0
	alpha_bloc_r[0] = X2_tmp & 0xFF; //8 bit
	beta_bloc_r[0]  = X3_tmp & 0xFF; //8 bit
	AB_block_r[0] = (alpha_bloc_r[0] << 8) | beta_bloc_r[0];
	carry_r[0] = 0;
	//gamma_num[0] = cDDT[carry[0]][AB_block[0]][256];
	//m1
	alpha_bloc_r[1]= X2_tmp & 0xFF00; //8 bit
	beta_bloc_r[1] = (X3_tmp >> 8) & 0xFF; //8 bit
	AB_block_r[1] = alpha_bloc_r[1] | beta_bloc_r[1];
	w_xor_r_H = cDDT_AB_wt_min[AB_block_r[1]];


		//printf("test--------------9----------------> \n");
		for(i0_l = cDDT_wt_min[carry_l[0]][AB_block_l[0]]; i0_l <= cDDT_wt_max[carry_l[0]][AB_block_l[0]]; i0_l++)
		{
			//if(w_xor_l_H + i0_l + w_xor_r > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0_l=0; j0_l < cDDT_n[carry_l[0]][AB_block_l[0]][i0_l]; j0_l++)
		{
			gamma_bloc_l[0] = cDDT_v[carry_l[0]][AB_block_l[0]][i0_l][j0_l];
			carry_l[1] = ((alpha_bloc_l[0] >> 7) << 2) //alpha MSB
					+ ((beta_bloc_l[0] >> 7) << 1)   //beta MSB
					+ (gamma_bloc_l[0] >> 7); // gamma MSB
		for(i1_l = MSB_cDDT_wt_min[carry_l[1]][AB_block_l[1]]; i1_l <= MSB_cDDT_wt_max[carry_l[1]][AB_block_l[1]]; i1_l++)
		{
			w1 = i0_l + i1_l;
			//if(w1 + w_xor_r > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1_l=0;j1_l < MSB_cDDT_n[carry_l[1]][AB_block_l[1]][i1_l]; j1_l++)
		{
			gamma_bloc_l[1] = MSB_cDDT_v[carry_l[1]][AB_block_l[1]][i1_l][j1_l];
			gamma_temp_l = (gamma_bloc_l[1] <<8) | gamma_bloc_l[0];
			if((search_round % 3) != 0) //7,10,13,16,...
			{
				if((Y_out_0 != gamma_temp_l) ) // 判断y0输出是否相等
				{
					continue;
				}
				yr1 = (gamma_temp_l ^ (ROTATE_LEFT(X1_tmp, 2,blocksize_len))) & Bit_Align;
				if(Y_out_1 != yr1) // 判断y0输出是否相等
				{
					continue;
				}
			}
			else //最后一轮需要经过L变换
			{
				if((Y_out_2!= gamma_temp_l) ) // 判断y0输出是否相等
				{
					continue;
				}
				yr1 = (gamma_temp_l ^ (ROTATE_LEFT(X1_tmp, 2,blocksize_len))) & Bit_Align;
				if(Y_out_3 != yr1) // 判断y0输出是否相等
				{
					continue;
				}
			}


		for(i0_r = cDDT_wt_min[carry_r[0]][AB_block_r[0]]; i0_r <= cDDT_wt_max[carry_r[0]][AB_block_r[0]]; i0_r++)
		{
			w2 = w1 + i0_r;
			//if(w2 + w_xor_r_H > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0_r=0; j0_r < cDDT_n[carry_r[0]][AB_block_r[0]][i0_r]; j0_r++)
		{
			gamma_bloc_r[0] = cDDT_v[carry_r[0]][AB_block_r[0]][i0_r][j0_r];
			carry_r[1] = ((alpha_bloc_r[0] >> 7) << 2) //alpha MSB
					+ ((beta_bloc_r[0] >> 7) << 1)   //beta MSB
					+ (gamma_bloc_r[0] >> 7); // gamma MSB
		for(i1_r = MSB_cDDT_wt_min[carry_r[1]][AB_block_r[1]]; i1_r <= MSB_cDDT_wt_max[carry_r[1]][AB_block_r[1]]; i1_r++)
		{
			w3 = w2 + i1_r;
			//if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			P_w[search_round] = w3;
		for(j1_r=0; j1_r < MSB_cDDT_n[carry_r[1]][AB_block_r[1]][i1_r]; j1_r++)
		{
			gamma_bloc_r[1] = MSB_cDDT_v[carry_r[1]][AB_block_r[1]][i1_r][j1_r];
			gamma_temp_r = (gamma_bloc_r[1] <<8) | gamma_bloc_r[0];

			if((search_round % 3) == 0) //判断y1输出是否相等
			{
				X_r[0][search_round +1] = gamma_temp_l;
				X_r[1][search_round +1] = gamma_temp_l ^ (ROTATE_LEFT(X1_tmp, 2,blocksize_len) & Bit_Align);
				X_r[2][search_round +1] = gamma_temp_r;
				X_r[3][search_round +1] = gamma_temp_r ^ (ROTATE_LEFT(X3_tmp, 2,blocksize_len) & Bit_Align);

				L2_Switch_per3Round(&X_r[0][search_round +1], &X_r[1][search_round +1], &X_r[2][search_round +1], &X_r[3][search_round +1]);  // switch function.

				if((Y_out_0 != X_r[0][search_round +1]) ) // 判断y0输出是否相等
				{
					continue;
				}
				if(Y_out_1 != X_r[1][search_round +1] ) // 判断y1输出是否相等
				{
					continue;
				}
				if((Y_out_2 != X_r[2][search_round +1] ) ) // 判断y2输出是否相等
				{
					continue;
				}
				if(Y_out_3 != X_r[3][search_round +1] ) // 判断y3输出是否相等
				{
					continue;
				}

				count++;
				//P_w[search_round] = w2 + i1_r;
				//P_w[search_round] = i0_l + i1_l + i0_r + i1_r;  //
				Bn_w = p_sumof_r + P_w[search_round] ;
				printf("count: %d    weight: %d \n",count,Bn_w);
				wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
			}
			else
			{
				if((Y_out_2 != gamma_temp_r) ) // 判断y2输出是否相等
				{
					continue;
				}
				yr3 = gamma_temp_r ^ (ROTATE_LEFT(X3_tmp, 2,blocksize_len) & Bit_Align);
				if(Y_out_3 != yr3) // 判断y0输出是否相等
				{
					continue;
				}

				//记录并输出
				count++;
				//P_w[search_round] = w2 + i1_r;
				//P_w[search_round] = i0_l + i1_l + i0_r + i1_r;  //
				Bn_w = p_sumof_r + P_w[search_round] ;
				printf("count: %d    weight: %d \n",count,Bn_w);
				wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
			}

		}}}}}}}}

	return best;
}


u16 SPARX64_differential_trail_search_entry(u16 search_round)  //
{

	u16 i = 0;
	sparx_best_Bn = fopen ("../tmp/sparx64_best_Bn_wt.xlsx", "a+"); //  "w+"); //

	result_print = fopen ("../tmp/result_print.txt", "a+"); //

	fprintf(result_print,"\n|************************************************************************|\n");  // write.
	fprintf(result_print,"Auto-search Begin...  \n");  // write.
	fprintf(result_print,"Enter the parameters : #ciper #blocksize #rounds  #mode \n");  // write.
	fprintf(result_print,"ciper:sparx \n");  // write.
	fprintf(result_print,"blocksize: 64 \n");  // write.
	fprintf(result_print,"rounds: %d \n", search_round);  // write.
	fprintf(result_print,"mode: 0 \n");  // write.
	fprintf(result_print,"---------------------------SPARX64 Optima differentail trails-------------------------------  \n");  // write.



	if((sc_blocksize != 64) && (sc_blocksize != 128))
	{
		printf("The block size of SPARX should be 64 or 128 bits. \n");
		return 0;
	}


	// For SPARX64 and SPARX128 both the S-BOX is 16bits.
	blocksize_len = 16;
	Bit_Align = 0xFFFF;
	ValueMax_Align = 0x7FFF;
	V_MSB = 0x8000;

	printf("Constructing SPARX64 Tables... \n");
	fprintf(result_print,"Constructing SPARX64 Tables... \n");

	ARX_carry_DDTm_construct();
	time_ARX_DDT = clock();
	run_time =  (time_ARX_DDT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct SPARX tables: %.2f seconds.  \n", run_time);
	fprintf(result_print,"Time of Construct SPARX tables: %.2f seconds.  \n", run_time);

	Bn_w = 0;
	if(search_round > 2)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(sparx_best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		Bn_w = n_P_bestofR_w[search_round-1] - 1;
	}

//	Bn_w = 25;  //直接设定开始的概率重量,快速达到期望的概率重量
	do
	{
		Bn_w = Bn_w + 1;
		printf("Searching Bn_w: %d \n", Bn_w);
		fprintf(result_print,"Searching Bn_w: %d \n", Bn_w);


/*
		P_w[1] = 4;
		wt_l[1]=2;	wt_r[1]=2;
		X_r[0][1] = 0x2800; X_r[1][1] =0x10;
		X_r[2][1] = 0x2800; X_r[3][1] =0x10;
		SPARX64_round_2toR(search_round,2,0x40,0x10,0x40,0x10);
*/


/*		// 8 轮的最优路径固定输入
		P_w[1] = 3;
		wt_l[1]=0;	wt_r[1]=3;
		X_r[0][1] = 0; X_r[1][1] = 0;
		X_r[2][1] = 0x0010; X_r[3][1] =0x8402;

		SPARX64_round_2toR(search_round,2,0,0,0x2402,0x8402);
//		0x0000    0x0000        0x8402  0x2402
*/

		// Search Entry.
		SPARX64_round_1_Left(search_round);



		time_Round = clock();
		run_time =  (time_Round - time_ARX_DDT) / CLOCKS_PER_SEC;
		printf("Time: %.2f seconds.  \n", run_time);
		fprintf(result_print,"Time: %.2f seconds.  \n", run_time);
	}while(Bn_w !=  n_P_bestofR_w[search_round]);   //end conditions.
	fprintf(sparx_best_Bn,"%d \n",n_P_bestofR_w[search_round]);  // write.

	print_SPARX64_resoult(search_round);


	time_finish = clock();
	run_time =  (double)(time_finish - time_ARX_DDT) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours == %.2f days. \n", run_time,run_time/60.0,run_time/3600.0,run_time/86400.0 );
	printf("Auto-search END! \n");
	printf("|************************************************************************|\n");
	fclose(sparx_best_Bn);


	fprintf(result_print,"Time cost: %.2f seconds ==  %.2f minutes == %.2f hours. \n", run_time,run_time/60.0,run_time/3600.0 );
	fprintf(result_print,"Auto-search END! \n");
	fprintf(result_print,"|************************************************************************|\n");
	fclose(result_print);

	return 1;
}

u16 SPARX64_diff_search_entry(u16 search_round)  // 默认只搜索大于7轮的差分路径
{
	int i=0;

	sparx_best_Bn = fopen ("../tmp/sparx64_best_Bn_wt.xlsx", "a+"); //  "w+"); //

	/* Get the input difference of r rounds.
	printf("Xr0: 0x");  scanf("%x",&X_in_0);
	printf("Xr1: 0x"); 	scanf("%x",&X_in_1);
	printf("Xr2: 0x"); 	scanf("%x",&X_in_2);
	printf("Xr3: 0x");  scanf("%x",&X_in_3);

	printf("Yr0: 0x");  scanf("%x",&Y_out_0);
	printf("Yr1: 0x"); 	scanf("%x",&Y_out_1);
	printf("Yr2: 0x"); 	scanf("%x",&Y_out_2);
	printf("Yr3: 0x");  scanf("%x",&Y_out_3);
*/

	/*
	X_in_0 = 0x0000;
	X_in_1 = 0x0000;
	X_in_2 = 0x1488;
	X_in_3 = 0x1008;

	Y_out_0 = 0x8000;
	Y_out_1 = 0x8c0a;
	Y_out_2 = 0x8000;
	Y_out_3 = 0x840a;

	wt_max = 26;
*/

	//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
	printf("wt_min(:*)--->wt_max: %d", wt_max);
//	scanf("%d",&wt_max);



	// For SPARX64 and SPARX128 both the S-BOX is 16bits.
	blocksize_len = 16;
	Bit_Align = 0xFFFF;
	ValueMax_Align = 0x7FFF;
	V_MSB = 0x8000;

	printf("\n");
	printf("Constructing SPARX64 Tables... \n");
	ARX_carry_DDTm_construct();
	time_ARX_DDT = clock();
	run_time =  (time_ARX_DDT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct SPARX64 tables: %.2f seconds.  \n", run_time);

	for(i=1; i <= search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
	{
		fscanf(sparx_best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
	}

	printf("-----------------------Search SPARX64 Differntials---------------------------\n");
	SPARX64_round_1_diff(search_round);

	printf("-----------------------Record SPARX64 Differntial trails---------------------\n");
	for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
	{
		prob = prob + (wt_nmu[i] * pow(2,-i));
		prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
		printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
	}
	printf("++++++++++++++++++\n ");
	printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
	//printf("input:0x%012x %012x ======>> output:0x%012x %012x \n",input_diff_L,input_diff_R,output_diff_L,output_diff_R);
	printf("0x%04x %04x %04x %04x ======>> 0x%04x %04x %04x %04x \n",
			X_in_0,X_in_1,X_in_2,X_in_3,Y_out_0,Y_out_1,Y_out_2,Y_out_3);

	printf(" wt_min: -%d ===>> wt_max: -%d \n",n_P_bestofR_w[search_round],wt_max);
	printf(" %d Rounds Differential with total %d trails.\n",search_round,count);
	printf(" Probability weight is: %.2Lf \n",prob_w);
	printf("++++++++++++++++++\n ");


	time_finish = clock();
	run_time =  (double)(time_finish - time_start) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours. \n", run_time,run_time/60.0,run_time/3600.0 );
	printf("Auto-search END! \n");
	printf("|************************************************************************|\n");



	return 0;
}


u16 SPARX_128_differential_trail_search_entry(u16 search_round)  //
{
	u16 i = 0;
	sparx_128_best_Bn = fopen ("../tmp/sparx128_best_Bn_wt.xlsx", "a+"); //  "w+"); //

	if((sc_blocksize != 64) && (sc_blocksize != 128))
	{
		printf("The block size of SPARX should be 64 or 128 bits. \n");
		return 0;
	}
	/*
	X_128_r[0][1] = 0x0000; X_128_r[1][1] = 0x0000;
	X_128_r[2][1] = 0x850A; X_128_r[3][1] = 0x9520;
	X_128_r[4][1] = 0x0000; X_128_r[5][1] = 0x0000;
	X_128_r[6][1] = 0x0000; X_128_r[7][1] = 0x0000;  //8轮SPECK32的输出
	// L // switch function.
	L4_Switch_per4Round(&X_128_r[0][1],&X_128_r[1][1],&X_128_r[2][1],&X_128_r[3][1],
			            &X_128_r[4][1],&X_128_r[5][1],&X_128_r[6][1],&X_128_r[7][1]);

	printf("%04x  %04x  %04x  %04x  %04x  %04x  %04x  %04x \n",
			X_128_r[0][1],X_128_r[1][1],X_128_r[2][1],X_128_r[3][1],
			X_128_r[4][1],X_128_r[5][1],X_128_r[6][1],X_128_r[7][1] );
	*/


	// For SPARX64 and SPARX128 both the S-BOX is 16bits.
	blocksize_len = 16;
	Bit_Align = 0xFFFF;
	ValueMax_Align = 0x7FFF;
	V_MSB = 0x8000;

	printf("Constructing SPARX-128 Tables... \n");
	ARX_carry_DDTm_construct();
	time_ARX_DDT = clock();
	run_time =  (time_ARX_DDT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct SPARX-128 tables: %.2f seconds.  \n", run_time);

	Bn_w = 0;
	if(search_round > 2)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(sparx_128_best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		Bn_w = n_P_bestofR_w[search_round-1] - 1;
	}

	/////////////////////////////////////////////////////////
//		Bn_w = 52;  //直接设定开始的概率重量,快速达到期望的概率重量
		do
		{
			Bn_w = Bn_w + 1;
			printf("Searching Bn_w: %d \n", Bn_w);

/*
	      //直接从第2轮开始，指定第1轮的输入输出差分
			P_w[1] = 1;
			wt_block[0][1] = 0; wt_block[1][1] = 0;
			wt_block[2][1] = 0; wt_block[3][1] = 1;
			X_128_r[0][1] = 0x0000; X_128_r[1][1] = 0x0000;
			X_128_r[2][1] = 0x0000; X_128_r[3][1] = 0x0000;
			X_128_r[3][1] = 0x0000; X_128_r[5][1] = 0x0000;
			X_128_r[6][1] = 0x2040; X_128_r[7][1] = 0x0040;  //9轮的输入
			SPARX_128_round_r(search_round, 2,
						0x0000,0x0000,0x0000,0x0000,
						0x0000,0x0000,0x2040,0x0040);
*/
/*
			//直接从第2轮开始，指定第1轮的输入输出差分
			P_w[1] = 1;
			wt_block[0][1] = 0; wt_block[1][1] = 0;
			wt_block[2][1] = 0; wt_block[3][1] = 1;
			X_128_r[0][1] = 0x0000; X_128_r[1][1] = 0x0000;
			X_128_r[2][1] = 0x0000; X_128_r[3][1] = 0x0000;
			X_128_r[3][1] = 0x0000; X_128_r[5][1] = 0x0000;
			X_128_r[6][1] = 0x0050; X_128_r[7][1] = 0xa000;  //10轮的输入

			SPARX_128_round_r(search_round, 2,
							0x0000,0x0000,0x0000,0x0000,
							0x0000,0x0000,0x0050,0xa000);
*/


			// Search Entry.
			SPARX_128_round_1(search_round);



			time_Round = clock();
			run_time =  (time_Round - time_ARX_DDT) / CLOCKS_PER_SEC;
			printf("Time: %.2f seconds.  \n", run_time);
		}while(Bn_w !=  n_P_bestofR_w[search_round]);   //end conditions.
		fprintf(sparx_128_best_Bn,"%d \n",n_P_bestofR_w[search_round]);  // write.
		print_SPARX_128_resoult(search_round);


		time_finish = clock();
		run_time =  (double)(time_finish - time_ARX_DDT) / CLOCKS_PER_SEC;
		printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours == %.2f days. \n", run_time,run_time/60.0,run_time/3600.0,run_time/86400.0 );
		printf("Auto-search END! \n");
		printf("|************************************************************************|\n");
		fclose(sparx_128_best_Bn);


	return 1;
}

u16 SPARX_128_diff_search_entry(u16 search_round)  //
{
	u16 i = 0;
	sparx_128_best_Bn = fopen ("../tmp/sparx128_best_Bn_wt.xlsx", "a+"); //  "w+"); //

	//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
	printf("wt_min(:*)--->wt_max:");
//	scanf("%d",&wt_max);

	// For SPARX64 and SPARX128 both the S-BOX is 16bits.
	blocksize_len = 16;
	Bit_Align = 0xFFFF;
	ValueMax_Align = 0x7FFF;
	V_MSB = 0x8000;

	printf("\n");
	printf("Constructing SPARX-128 Tables... \n");
	ARX_carry_DDTm_construct();
	time_ARX_DDT = clock();
	run_time =  (time_ARX_DDT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct SPARX tables: %.2f seconds.  \n", run_time);

	for(i=1; i <= search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
	{
		fscanf(sparx_128_best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
	}

	printf("-----------------------Search SPARX-128 Differntials---------------------------\n");
	SPARX_128_round_1_diff(search_round);

	printf("-----------------------Record SPARX-128 Differntial trails---------------------\n");

	for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
	{
		prob = prob + (wt_nmu[i] * pow(2,-i));
		prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
		printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
	}
	printf("++++++++++++++++++\n ");
	printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
	//printf("input:0x%012x %012x ======>> output:0x%012x %012x \n",input_diff_L,input_diff_R,output_diff_L,output_diff_R);
	printf( "0x%04x %04x %04x %04x %04x %04x %04x %04x \n"
			"==================>> \n"
		    "0x%04x %04x %04x %04x %04x %04x %04x %04x \n",
			X_in_0,X_in_1,X_in_2,X_in_3,X_in_4,X_in_5,X_in_6,X_in_7,
			Y_out_0,Y_out_1,Y_out_2,Y_out_3,Y_out_4,Y_out_5,Y_out_6,Y_out_7);

	printf(" wt_min: -%d ===>> wt_max: -%d \n",n_P_bestofR_w[search_round],wt_max);
	printf(" %d Rounds Differential with total %d trails.\n",search_round,count);
	printf(" Probability weight is: %.2Lf \n",prob_w);
	printf("++++++++++++++++++\n ");


	time_finish = clock();
	run_time =  (double)(time_finish - time_start) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours. \n", run_time,run_time/60.0,run_time/3600.0 );
	printf("Auto-search END! \n");
	printf("|************************************************************************|\n");

	return 1;
}

u16 SPARX_128_round_1(u16 search_round)
{
	u16 best = 0;
	u16 wt_round_1 = 0;
	u16 wt_Block_0 = 0,wt_Block_1 = 1,wt_Block_2 = 0,wt_Block_3 = 0;


	///////////////////round 1 entry////////////////////
	if( search_round < 2)
	{
		return 0;
	}

	// 限定SPARX-128的首轮的概率重量  blocksize_len-1
	for(wt_round_1 = 1; wt_round_1 < 2;wt_round_1++)  //0::n-1  //各个分块最多15比特的概率重量:61
	{
		// thr_d : the bits number of alpha/beta/gamma that the position not equal at the same time.
		if ((wt_round_1 + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::
		}
		P_w[1] = wt_round_1;

		for(wt_Block_0=0; wt_Block_0 <= wt_round_1; wt_Block_0++) //15
		{
			for(wt_Block_1=0; wt_Block_1 <= wt_round_1; wt_Block_1++) //15
			{
				for(wt_Block_2=0; wt_Block_2 <= wt_round_1; wt_Block_2++) //15
				{
					for(wt_Block_3=0; wt_Block_3 <= wt_round_1; wt_Block_3++)//15
					{
						if((wt_Block_0 + wt_Block_1 + wt_Block_2 + wt_Block_3) == wt_round_1)
						{
							//printf("TTTTTTEST 1 \n");
							best = SPARX_128_round_1_BLOCK_0(search_round,
									wt_Block_0,wt_Block_1,wt_Block_2,wt_Block_3);
							if(best== 1 )
							{
								return 1;
							}
						}
					}
				}
			}
		}
	}

	return best;
}

u16 SPARX_128_round_1_BLOCK_0(u16 search_round,
		u16 w_B_0, u16 w_B_1,u16 w_B_2,u16 w_B_3)
{
	u16 best = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;

	u16 M0 = 0;
	u16 N0 = 15;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;
	u16 j_abc = 0;

	M0 = w_B_0;

	if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
	{
		for(j_abc = 0; j_abc < 4;j_abc++)
		{
			if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = V_MSB;
			}
			else
			{
				Input_alpha = 0;  // & Bit_Align;
			}

			if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
			{
				Input_beta = V_MSB;
			}
			else
			{
				Input_beta = 0; // & Bit_Align;
			}

			if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
			{
				Input_gamma = V_MSB;
			}
			else
			{
				Input_gamma = 0;  // & Bit_Align;
			}
			/////
			//printf("TTTTTTEST 2 \n");
			best = SPARX_128_round_1_BLOCK_1(search_round,
					w_B_1, w_B_2, w_B_3,
					Input_gamma,Input_beta
					);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			wt_block[0][1] = M0;
			X_128_r[0][1] = (ROTATE_LEFT(Input_alpha, 7, blocksize_len)) & Bit_Align;
			X_128_r[1][1] = Input_beta  & Bit_Align;
			return 1;
		}
#endif
		}
		}
		else  //M0 > 0.
		{
			for ( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for ( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for ( i = 1; i<=M0; i++) { C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			best = SPARX_128_round_1_BLOCK_0_MSB(search_round,
					 w_B_0, w_B_1, w_B_2, w_B_3,
					 C0);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		return 1;
	}
#endif

		do
		{
			if (I0 == 0)
			{
				break;
			}
			else
			{
				if (T0[I0] < 0)
				{
					if ((-T0[I0]) != (I0-1))
					{
						T0[I0-1] = T0[I0];
					}
					T0[I0] = I0-1;
				}
				if ( A0[I0]==0 )
				{
					X0 = I0;
					Y0 = F0[L0];
					if (A0[I0-1] == 1)
					{
						F0[I0] = F0[I0 - 1];
					}
					else
					{
						F0[I0] = I0;
					}
					if (F0[L0] == L0)
					{
						L0 = I0; I0 = T0[I0];
						goto BLOCK_Comb_0;
					}
					if (L0 == N0)
					{
						T0[F0[N0]] = -I0 - 1;
						T0[I0 + 1] = T0[I0];
						I0 = F0[N0];
						F0[N0] = F0[N0] + 1;
						goto BLOCK_Comb_0;
					}
					T0[L0] = -I0-1;
					T0[I0+1] = T0[I0];
					F0[L0] = F0[L0] + 1;
					I0 = L0;
					goto BLOCK_Comb_0;
				}
				Y0 = I0;
				if (I0 != L0)
				{
					F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
					if (L0 == N0)
					{
						if (I0 == (F0[N0] - 1))
						{
							I0 = T0[I0];
							goto BLOCK_Comb_0;
						}
						T0[F0[N0]-1] = -I0-1;
						T0[I0+1] = T0[I0];
						I0 = F0[N0] - 1;
						goto BLOCK_Comb_0;
					}
					T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0; goto BLOCK_Comb_0;
				}
				X0 = N0;
				F0[L0 - 1] = F0[L0];
				F0[N0] = N0;
				L0 = N0;
				if (I0 == N0 - 1)
				{
					I0 = T0[N0 - 1];
					goto BLOCK_Comb_0;
				}
				T0[N0 - 1] = -I0 - 1;
				T0[I0 + 1] = T0[I0];
				I0 = N0 - 1;
				BLOCK_Comb_0:
						A0[X0] = 1;
						A0[Y0] = 0;
						H0[X0] = Z0 = H0[Y0];
						C0[Z0] = X0;
						}
////////////////////////////////////
			//printf("TTTTTTEST 2-2 \n");
			best = SPARX_128_round_1_BLOCK_0_MSB(search_round,
					 w_B_0, w_B_1, w_B_2, w_B_3,
					 C0);
#if 1   //是否找到第一条最优路径就返回？
			if(best == 1 )
			{
				return 1;
			}
#endif
					} while(1);
					}
////////////////////
	return best;
}


u16 SPARX_128_round_1_BLOCK_0_MSB(u16 search_round,
		u16 w_B_0, u16 w_B_1,u16 w_B_2,u16 w_B_3,
		char *posi)
{
	u16 state = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;
	u16 j_abc = 0;

	//printf("TTTTTTEST 1-msb \n");

	//2018年11月27日18:29:45 //全空间
	for(j_abc = 0; j_abc < 8;j_abc++)   // MSB
	{
		//if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
		if((j_abc & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = V_MSB;
		}
		else
		{
			Input_alpha = 0;  // & Bit_Align;
		}

		//if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
		if((j_abc & 0x2) != 0) // alpha bit j.
		{
			Input_beta = V_MSB;
		}
		else
		{
			Input_beta = 0; // & Bit_Align;
		}

		//if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
		if((j_abc & 0x1) != 0) // alpha bit j.
		{
			Input_gamma = V_MSB;
		}
		else
		{
			Input_gamma = 0;  // & Bit_Align;
		}

		if((j_abc==1) || (j_abc==2) || (j_abc==4) || (j_abc==7) )
		{
			Input_alpha |= 0x7FFF;
			Input_beta  |= 0x7FFF;
			Input_gamma |= 0x7FFF;
		}

		state = SPARX_128_round_1_BLOCK_0_Middle(search_round,
				w_B_0, w_B_1, w_B_2, w_B_3,
				Input_alpha,Input_beta,Input_gamma,
				posi,w_B_0	);

#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
}
	return state;
}

u16 SPARX_128_round_1_BLOCK_0_Middle(u16 search_round,
		u16 w_B_0, u16 w_B_1,u16 w_B_2,u16 w_B_3,
		u16 alpha, u16 beta, u16 gamma,
		char *posi,u16 cur_posi)
{
	u16 state = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u16 indx_tmp = 0;
//	u16 i = 0;
	u16 bit_i = 1;

		//indx_tmp = 1 << (posi[cur_posi] - 1);
		indx_tmp = posi[cur_posi] - 1;

		// Middle bit positionsof of alpha/beta/gamma
		if( cur_posi > 1)  // Middle bit positionsof of alpha/beta/gamma
		{

			for(j_abc = 1; j_abc < 7; j_abc++)   // MSB //for speck32/48/64
			//for(i = 0; i < 3; i++)   // MSB //for speck96/128
			{
				//j_abc = set_A_3[i];  //for speck96/128

				if((j_abc & 0x4) != 0) // alpha bit j.
				{
					Input_alpha = alpha | (bit_i << indx_tmp);
				}
				else
				{
					//Input_alpha = alpha; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
					Input_alpha = (alpha & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
				}

				if((j_abc & 0x2) != 0) // alpha bit j.
				{
					Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
				}
				else
				{
					//Input_beta = beta; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
					Input_beta = (beta & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
				}

				if((j_abc & 0x1) != 0) // alpha bit j.
				{
					Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
				}
				else
				{
					//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
					Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
				}

				//set A_3 of Middle
				if( (j_abc==3) || (j_abc==5) || (j_abc==6) )
				{
					// setA对应到下一个不全同比特位置,全设置为0才满足差分有效性条件.
					for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
					{
						Input_alpha &= ~(bit_i << j_last);
						Input_beta  &= ~(bit_i << j_last);
						Input_gamma &= ~(bit_i << j_last);
					}
				}     //对于speck96和speck128,不考虑导致后续比特全wei 1情况
				else //set B_3 of Middle //if((j_abc==1) || (j_abc==2) || (j_abc==4) )
				{
					// setB_3对应到下一个不全同比特位置,全设置为 1 才满足差分有效性条件.
					for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
					{
						Input_alpha ^= (bit_i << j_last);
						Input_beta  ^= (bit_i << j_last);
						Input_gamma ^= (bit_i << j_last);
					}
				}

				state = SPARX_128_round_1_BLOCK_0_Middle(search_round,
						w_B_0, w_B_1, w_B_2, w_B_3,
						Input_alpha,Input_beta,Input_gamma,
						posi,cur_posi-1	);

	#if 1   //是否找到第一条最优路径就返回？
		if(state == 1 )
		{
			return 1;
		}
	#endif
			}
		}
		else 	//call last position.
		{
			state = SPARX_128_round_1_BLOCK_0_Last(search_round,
					 w_B_0, w_B_1, w_B_2, w_B_3,
					 alpha, beta, gamma,
					posi);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
		}

	return state;
}

u16 SPARX_128_round_1_BLOCK_0_Last(u16 search_round,
		u16 w_B_0, u16 w_B_1,u16 w_B_2,u16 w_B_3,
		u16 alpha, u16 beta, u16 gamma,
		char *posi)
{
	u16 state = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u16 indx_tmp = 0;
	u16 bit_i = 1;

	indx_tmp = posi[1] - 1;

	// Last bit position of alpha/beta/gamma // set_A_3
	for(j_abc = 0; j_abc < 3;j_abc++)// Last bit position.
	{
		if((set_A_3[j_abc] & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = alpha | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_alpha = alpha; // & ( ~(1 << indx_tmp))) & Bit_Align;
			Input_alpha = (alpha & ( ~(bit_i << indx_tmp))) & Bit_Align;
		}

		if((set_A_3[j_abc] & 0x2) != 0) // alpha bit j.
		{
			Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_beta = beta; // & ( ~(1 << indx_tmp))) & Bit_Align;
			Input_beta = (beta & ( ~(bit_i << indx_tmp))) & Bit_Align;
		}

		if((set_A_3[j_abc] & 0x1) != 0) // alpha bit j.
		{
			Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ) & Bit_Align;
			Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ) & Bit_Align;
		}


 	 	 // 若考虑set_B的情况,则需要在此将最低非全0比特位后面的比特全部清零
		if(posi[1] > 1)
			for(j_last=0; j_last< indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
			{
				Input_alpha &= ~(bit_i << j_last);
				Input_beta  &= ~(bit_i << j_last);
				Input_gamma &= ~(bit_i << j_last);
			}

		state = SPARX_128_round_1_BLOCK_1(search_round,
				 w_B_1, w_B_2, w_B_3,
				 (u16)Input_gamma,(u16)Input_beta);

#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		wt_block[0][1] = w_B_0;
		X_128_r[0][1] = (ROTATE_LEFT(Input_alpha, 7, blocksize_len)) & Bit_Align;
		X_128_r[1][1] = Input_beta  & Bit_Align;
		return 1;
	}
#endif
	}
	return state;
}


u16 SPARX_128_round_1_BLOCK_1(u16 search_round,
		u16 w_B_1,u16 w_B_2,u16 w_B_3,
		u16 x_in_0, u16 x_in_1)
{
	u16 best = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;

	u16 M0 = 0;
	u16 N0 = 15;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;
	u16 j_abc = 0;

	M0 = w_B_1;

	if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
	{
		for(j_abc = 0; j_abc < 4;j_abc++)
		{
			if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = V_MSB;
			}
			else
			{
				Input_alpha = 0;  // & Bit_Align;
			}

			if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
			{
				Input_beta = V_MSB;
			}
			else
			{
				Input_beta = 0; // & Bit_Align;
			}

			if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
			{
				Input_gamma = V_MSB;
			}
			else
			{
				Input_gamma = 0;  // & Bit_Align;
			}
			/////
			//printf("TTTTTTEST block 1-1 \n");
			best = SPARX_128_round_1_BLOCK_2(search_round,
					w_B_2, w_B_3,
					x_in_0, x_in_1,Input_gamma,Input_beta
					);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			wt_block[1][1] = w_B_1;
			X_128_r[2][1] = (ROTATE_LEFT(Input_alpha, 7, blocksize_len)) & Bit_Align;
			X_128_r[3][1] = Input_beta  & Bit_Align;
			return 1;
		}
#endif
					}
	}
	else  //M0 > 0.
	{
		for ( i=0; i<=(N0-M0); i++) A0[i] = 0;
		for ( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
		for ( i = 1; i<=M0; i++) { C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
		T0[N0-M0] = -1;
		T0[1] = 0;
		F0[N0] = N0 - M0 + 1;
		I0 = N0 - M0; L0 = N0;


		best = SPARX_128_round_1_BLOCK_1_MSB(search_round,
				w_B_1, w_B_2, w_B_3,
				x_in_0, x_in_1,
				C0);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		return 1;
	}
#endif

		do
		{
			if (I0 == 0)
			{
				break;
			}
			else
			{
				if (T0[I0] < 0)
				{
					if ((-T0[I0]) != (I0-1))
					{
						T0[I0-1] = T0[I0];
					}
					T0[I0] = I0-1;
				}
				if ( A0[I0]==0 )
				{
					X0 = I0;
					Y0 = F0[L0];
					if (A0[I0-1] == 1)
					{
						F0[I0] = F0[I0 - 1];
					}
					else
					{
						F0[I0] = I0;
					}
					if (F0[L0] == L0)
					{
						L0 = I0; I0 = T0[I0];
						goto BLOCK_Comb_1;
					}
					if (L0 == N0)
					{
						T0[F0[N0]] = -I0 - 1;
						T0[I0 + 1] = T0[I0];
						I0 = F0[N0];
						F0[N0] = F0[N0] + 1;
						goto BLOCK_Comb_1;
					}
					T0[L0] = -I0-1;
					T0[I0+1] = T0[I0];
					F0[L0] = F0[L0] + 1;
					I0 = L0;
					goto BLOCK_Comb_1;
				}
				Y0 = I0;
				if (I0 != L0)
				{
					F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
					if (L0 == N0)
					{
						if (I0 == (F0[N0] - 1))
						{
							I0 = T0[I0];
							goto BLOCK_Comb_1;
						}
						T0[F0[N0]-1] = -I0-1;
						T0[I0+1] = T0[I0];
						I0 = F0[N0] - 1;
						goto BLOCK_Comb_1;
					}
					T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0; goto BLOCK_Comb_1;
				}
				X0 = N0;
				F0[L0 - 1] = F0[L0];
				F0[N0] = N0;
				L0 = N0;
				if (I0 == N0 - 1)
				{
					I0 = T0[N0 - 1];
					goto BLOCK_Comb_1;
				}
				T0[N0 - 1] = -I0 - 1;
				T0[I0 + 1] = T0[I0];
				I0 = N0 - 1;
				BLOCK_Comb_1:
						A0[X0] = 1;
						A0[Y0] = 0;
						H0[X0] = Z0 = H0[Y0];
						C0[Z0] = X0;
						}
////////////////////////////////////
			best = SPARX_128_round_1_BLOCK_1_MSB(search_round,
					w_B_1, w_B_2, w_B_3,
					x_in_0, x_in_1,
					C0);
#if 1   //是否找到第一条最优路径就返回？
			if(best == 1 )
			{
				return 1;
			}
#endif
					} while(1);
					}
////////////////////
	return best;
}

u16 SPARX_128_round_1_BLOCK_1_MSB(u16 search_round,
		u16 w_B_1,u16 w_B_2,u16 w_B_3,
		u16 x_in_0, u16 x_in_1,
		char *posi)
{
	u16 state = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;
	u16 j_abc = 0;

		//2018年11月27日18:29:45 //全空间
		for(j_abc = 0; j_abc < 8;j_abc++)   // MSB
		{
			//if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = V_MSB;
			}
			else
			{
				Input_alpha = 0;  // & Bit_Align;
			}

			//if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
			if((j_abc & 0x2) != 0) // alpha bit j.
			{
				Input_beta = V_MSB;
			}
			else
			{
				Input_beta = 0; // & Bit_Align;
			}

			//if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
			if((j_abc & 0x1) != 0) // alpha bit j.
			{
				Input_gamma = V_MSB;
			}
			else
			{
				Input_gamma = 0;  // & Bit_Align;
			}

			if((j_abc==1) || (j_abc==2) || (j_abc==4) || (j_abc==7) )
			{
				Input_alpha |= 0x7FFF;
				Input_beta  |= 0x7FFF;
				Input_gamma |= 0x7FFF;
			}

			state = SPARX_128_round_1_BLOCK_1_Middle(search_round,
					w_B_1, w_B_2, w_B_3,
					x_in_0, x_in_1,
					Input_alpha,Input_beta,Input_gamma,
					posi,w_B_1);
	#if 1   //是否找到第一条最优路径就返回？
		if(state == 1 )
		{
			return 1;
		}
	#endif
	}
		return state;
	}

u16 SPARX_128_round_1_BLOCK_1_Middle(u16 search_round,
		u16 w_B_1,u16 w_B_2,u16 w_B_3,
		u16 x_in_0, u16 x_in_1,
		u16 alpha, u16 beta, u16 gamma,
		char *posi,u16 cur_posi)
{
	u16 state = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u16 indx_tmp = 0;
//	u16 i = 0;
	u16 bit_i = 1;

	//indx_tmp = 1 << (posi[cur_posi] - 1);
	indx_tmp = posi[cur_posi] - 1;

			// Middle bit positionsof of alpha/beta/gamma
			if( cur_posi > 1)  // Middle bit positionsof of alpha/beta/gamma
			{

				for(j_abc = 1; j_abc < 7; j_abc++)   // MSB //for speck32/48/64
				//for(i = 0; i < 3; i++)   // MSB //for speck96/128
				{
					//j_abc = set_A_3[i];  //for speck96/128

					if((j_abc & 0x4) != 0) // alpha bit j.
					{
						Input_alpha = alpha | (bit_i << indx_tmp);
					}
					else
					{
						//Input_alpha = alpha; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
						Input_alpha = (alpha & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
					}

					if((j_abc & 0x2) != 0) // alpha bit j.
					{
						Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
					}
					else
					{
						//Input_beta = beta; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
						Input_beta = (beta & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
					}

					if((j_abc & 0x1) != 0) // alpha bit j.
					{
						Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
					}
					else
					{
						//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
						Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
					}

					//set A_3 of Middle
					if( (j_abc==3) || (j_abc==5) || (j_abc==6) )
					{
						// setA对应到下一个不全同比特位置,全设置为0才满足差分有效性条件.
						for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
						{
							Input_alpha &= ~(bit_i << j_last);
							Input_beta  &= ~(bit_i << j_last);
							Input_gamma &= ~(bit_i << j_last);
						}
					}     //对于speck96和speck128,不考虑导致后续比特全wei 1情况
					else //set B_3 of Middle //if((j_abc==1) || (j_abc==2) || (j_abc==4) )
					{
						// setB_3对应到下一个不全同比特位置,全设置为 1 才满足差分有效性条件.
						for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
						{
							Input_alpha ^= (bit_i << j_last);
							Input_beta  ^= (bit_i << j_last);
							Input_gamma ^= (bit_i << j_last);
						}
					}

					state = SPARX_128_round_1_BLOCK_1_Middle(search_round,
							w_B_1, w_B_2, w_B_3,
							x_in_0, x_in_1,
							Input_alpha,Input_beta,Input_gamma,
							posi,cur_posi-1	);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
				}
			}
			else 	//call last position.
			{
				state = SPARX_128_round_1_BLOCK_1_Last( search_round,
						w_B_1, w_B_2, w_B_3,
						x_in_0, x_in_1,
						alpha, beta, gamma,
						posi);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
			}
	return state;
}

u16 SPARX_128_round_1_BLOCK_1_Last(u16 search_round,
		u16 w_B_1,u16 w_B_2,u16 w_B_3,
		u16 x_in_0, u16 x_in_1,
		u16 alpha, u16 beta, u16 gamma,
		char *posi)
{
	u16 state = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u16 indx_tmp = 0;
	u16 bit_i = 1;

		indx_tmp = posi[1] - 1;

		// Last bit position of alpha/beta/gamma // set_A_3
		for(j_abc = 0; j_abc < 3;j_abc++)// Last bit position.
		{
			if((set_A_3[j_abc] & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = alpha | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_alpha = alpha; // & ( ~(1 << indx_tmp))) & Bit_Align;
				Input_alpha = (alpha & ( ~(bit_i << indx_tmp))) & Bit_Align;
			}

			if((set_A_3[j_abc] & 0x2) != 0) // alpha bit j.
			{
				Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_beta = beta; // & ( ~(1 << indx_tmp))) & Bit_Align;
				Input_beta = (beta & ( ~(bit_i << indx_tmp))) & Bit_Align;
			}

			if((set_A_3[j_abc] & 0x1) != 0) // alpha bit j.
			{
				Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ) & Bit_Align;
				Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ) & Bit_Align;
			}

	 	 	 // 若考虑set_B的情况,则需要在此将最低非全0比特位后面的比特全部清零
			if(posi[1] > 1)
				for(j_last=0; j_last< indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
				{
					Input_alpha &= ~(bit_i << j_last);
					Input_beta  &= ~(bit_i << j_last);
					Input_gamma &= ~(bit_i << j_last);
				}

			state = SPARX_128_round_1_BLOCK_2(search_round,
					 w_B_2, w_B_3,
					 x_in_0, x_in_1, (u16)Input_gamma, (u16)Input_beta );
	#if 1   //是否找到第一条最优路径就返回？
		if(state == 1 )
		{
			wt_block[1][1] = w_B_1;
			X_128_r[2][1] = (ROTATE_LEFT(Input_alpha, 7, blocksize_len)) & Bit_Align;
			X_128_r[3][1] = Input_beta  & Bit_Align;
			return 1;
		}
	#endif
		}
	return state;
}


u16 SPARX_128_round_1_BLOCK_2(u16 search_round,
		u16 w_B_2,u16 w_B_3,
		u16 x_in_0, u16 x_in_1,u16 x_in_2, u16 x_in_3)
{
	u16 best = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;

	u16 M0 = 0;
	u16 N0 = 15;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;
	u16 j_abc = 0;

	M0 = w_B_2;

	if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
	{
		for(j_abc = 0; j_abc < 4;j_abc++)
		{
			if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = V_MSB;
			}
			else
			{
				Input_alpha = 0;  // & Bit_Align;
			}

			if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
			{
				Input_beta = V_MSB;
			}
			else
			{
				Input_beta = 0; // & Bit_Align;
			}

			if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
			{
				Input_gamma = V_MSB;
			}
			else
			{
				Input_gamma = 0;  // & Bit_Align;
			}
			/////
			//printf("TTTTTTEST block 3-1 \n");
			best = SPARX_128_round_1_BLOCK_3(search_round,
					w_B_3,
					x_in_0, x_in_1, x_in_2, x_in_3,Input_gamma, Input_beta);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			wt_block[2][1] = w_B_2;
			X_128_r[4][1] = (ROTATE_LEFT(Input_alpha, 7, blocksize_len)) & Bit_Align;
			X_128_r[5][1] = Input_beta & Bit_Align;
			return 1;
		}
#endif
		}
	}
	else  //M0 > 0.
	{
		for ( i=0; i<=(N0-M0); i++) A0[i] = 0;
		for ( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
		for ( i = 1; i<=M0; i++) { C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
		T0[N0-M0] = -1;
		T0[1] = 0;
		F0[N0] = N0 - M0 + 1;
		I0 = N0 - M0; L0 = N0;

		best = SPARX_128_round_1_BLOCK_2_MSB(search_round,
				w_B_2, w_B_3,
				x_in_0, x_in_1,x_in_2, x_in_3,
				C0);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		return 1;
	}
#endif

			do
			{
				if (I0 == 0)
				{
					break;
				}
				else
				{
					if (T0[I0] < 0)
					{
						if ((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if ( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if (A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if (F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto BLOCK_Comb_2;
						}
						if (L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto BLOCK_Comb_2;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto BLOCK_Comb_2;
					}
					Y0 = I0;
					if (I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if (L0 == N0)
						{
							if (I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto BLOCK_Comb_2;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto BLOCK_Comb_2;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0; goto BLOCK_Comb_2;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if (I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto BLOCK_Comb_2;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
					BLOCK_Comb_2:
							A0[X0] = 1;
							A0[Y0] = 0;
							H0[X0] = Z0 = H0[Y0];
							C0[Z0] = X0;
							}
	////////////////////////////////////
				best = SPARX_128_round_1_BLOCK_2_MSB(search_round,
						w_B_2, w_B_3,
						x_in_0, x_in_1,x_in_2, x_in_3,
						C0);
	#if 1   //是否找到第一条最优路径就返回？
				if(best == 1 )
				{
					return 1;
				}
	#endif
						} while(1);
						}
	////////////////////
		return best;
}

u16 SPARX_128_round_1_BLOCK_2_MSB(u16 search_round,
		u16 w_B_2,u16 w_B_3,
		u16 x_in_0, u16 x_in_1,u16 x_in_2, u16 x_in_3,
		char *posi)
{
	u16 state = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;
	u16 j_abc = 0;

		//2018年11月27日18:29:45 //全空间
		for(j_abc = 0; j_abc < 8;j_abc++)   // MSB
		{
			//if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = V_MSB;
			}
			else
			{
				Input_alpha = 0;  // & Bit_Align;
			}

			//if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
			if((j_abc & 0x2) != 0) // alpha bit j.
			{
				Input_beta = V_MSB;
			}
			else
			{
				Input_beta = 0; // & Bit_Align;
			}

			//if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
			if((j_abc & 0x1) != 0) // alpha bit j.
			{
				Input_gamma = V_MSB;
			}
			else
			{
				Input_gamma = 0;  // & Bit_Align;
			}

			if((j_abc==1) || (j_abc==2) || (j_abc==4) || (j_abc==7) )
			{
				Input_alpha |= 0x7FFF;
				Input_beta  |= 0x7FFF;
				Input_gamma |= 0x7FFF;
			}

			state = SPARX_128_round_1_BLOCK_2_Middle(search_round,
					w_B_2, w_B_3,
					x_in_0, x_in_1,x_in_2, x_in_3,
					Input_alpha,Input_beta,Input_gamma,
					posi,w_B_2	);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
	}
		return state;
}

u16 SPARX_128_round_1_BLOCK_2_Middle(u16 search_round,
		u16 w_B_2,u16 w_B_3,
		u16 x_in_0, u16 x_in_1,u16 x_in_2, u16 x_in_3,
		u16 alpha, u16 beta, u16 gamma,
		char *posi,u16 cur_posi)
{
	u16 state = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u16 indx_tmp = 0;
//	u16 i = 0;
	u16 bit_i = 1;

		//indx_tmp = 1 << (posi[cur_posi] - 1);
		indx_tmp = posi[cur_posi] - 1;

		// Middle bit positionsof of alpha/beta/gamma
		if( cur_posi > 1)  // Middle bit positionsof of alpha/beta/gamma
		{

			for(j_abc = 1; j_abc < 7; j_abc++)   // MSB //for speck32/48/64
			//for(i = 0; i < 3; i++)   // MSB //for speck96/128
			{
				//j_abc = set_A_3[i];  //for speck96/128

				if((j_abc & 0x4) != 0) // alpha bit j.
				{
					Input_alpha = alpha | (bit_i << indx_tmp);
				}
				else
				{
					//Input_alpha = alpha; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
					Input_alpha = (alpha & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
				}

				if((j_abc & 0x2) != 0) // alpha bit j.
				{
					Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
				}
				else
				{
					//Input_beta = beta; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
					Input_beta = (beta & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
				}

				if((j_abc & 0x1) != 0) // alpha bit j.
				{
					Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
				}
				else
				{
					//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
					Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
				}

				//set A_3 of Middle
				if( (j_abc==3) || (j_abc==5) || (j_abc==6) )
				{
					// setA对应到下一个不全同比特位置,全设置为0才满足差分有效性条件.
					for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
					{
						Input_alpha &= ~(bit_i << j_last);
						Input_beta  &= ~(bit_i << j_last);
						Input_gamma &= ~(bit_i << j_last);
					}
				}     //对于speck96和speck128,不考虑导致后续比特全wei 1情况
				else //set B_3 of Middle //if((j_abc==1) || (j_abc==2) || (j_abc==4) )
				{
					// setB_3对应到下一个不全同比特位置,全设置为 1 才满足差分有效性条件.
					for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
					{
						Input_alpha ^= (bit_i << j_last);
						Input_beta  ^= (bit_i << j_last);
						Input_gamma ^= (bit_i << j_last);
					}
				}

				state = SPARX_128_round_1_BLOCK_2_Middle(search_round,
						w_B_2, w_B_3,
						x_in_0, x_in_1,x_in_2, x_in_3,
						Input_alpha,Input_beta,Input_gamma,
						posi,cur_posi-1	);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
			}
				}
				else 	//call last position.
				{
					state = SPARX_128_round_1_BLOCK_2_Last(search_round,
							w_B_2, w_B_3,
							x_in_0, x_in_1,x_in_2, x_in_3,
							alpha, beta, gamma,
							posi);
	#if 1   //是否找到第一条最优路径就返回？
		if(state == 1 )
		{
			return 1;
		}
	#endif
				}
	return state;
}

u16 SPARX_128_round_1_BLOCK_2_Last(u16 search_round,
		u16 w_B_2,u16 w_B_3,
		u16 x_in_0, u16 x_in_1,u16 x_in_2, u16 x_in_3,
		u16 alpha, u16 beta, u16 gamma,
		char *posi)
{
	u16 state = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u16 indx_tmp = 0;
	u16 bit_i = 1;

		indx_tmp = posi[1] - 1;

		// Last bit position of alpha/beta/gamma // set_A_3
		for(j_abc = 0; j_abc < 3;j_abc++)// Last bit position.
		{
			if((set_A_3[j_abc] & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = alpha | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_alpha = alpha; // & ( ~(1 << indx_tmp))) & Bit_Align;
				Input_alpha = (alpha & ( ~(bit_i << indx_tmp))) & Bit_Align;
			}

			if((set_A_3[j_abc] & 0x2) != 0) // alpha bit j.
			{
				Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_beta = beta; // & ( ~(1 << indx_tmp))) & Bit_Align;
				Input_beta = (beta & ( ~(bit_i << indx_tmp))) & Bit_Align;
			}

			if((set_A_3[j_abc] & 0x1) != 0) // alpha bit j.
			{
				Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ) & Bit_Align;
				Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ) & Bit_Align;
			}

	 	 	 // 若考虑set_B的情况,则需要在此将最低非全0比特位后面的比特全部清零
			if(posi[1] > 1)
				for(j_last=0; j_last< indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
				{
					Input_alpha &= ~(bit_i << j_last);
					Input_beta  &= ~(bit_i << j_last);
					Input_gamma &= ~(bit_i << j_last);
				}

			state = SPARX_128_round_1_BLOCK_3(search_round,
					 w_B_3,
					 x_in_0, x_in_1, x_in_2, x_in_3,(u16)Input_gamma, (u16)Input_beta );

	#if 1   //是否找到第一条最优路径就返回？
		if(state == 1 )
		{
			wt_block[2][1] = w_B_2;
			X_128_r[4][1] = (ROTATE_LEFT(Input_alpha, 7, blocksize_len)) & Bit_Align;
			X_128_r[5][1] = Input_beta  & Bit_Align;
			return 1;
		}
	#endif
		}
	return state;
}


u16 SPARX_128_round_1_BLOCK_3(u16 search_round,
		u16 w_B_3,
		u16 x_in_0, u16 x_in_1,u16 x_in_2, u16 x_in_3,u16 x_in_4, u16 x_in_5)
{
	u16 best = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;

	u16 M0 = 0;
	u16 N0 = 15;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;
	u16 j_abc = 0;

		M0 = w_B_3;

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			for(j_abc = 0; j_abc < 4;j_abc++)
			{
				if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
				{
					Input_alpha = V_MSB;
				}
				else
				{
					Input_alpha = 0;  // & Bit_Align;
				}

				if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
				{
					Input_beta = V_MSB;
				}
				else
				{
					Input_beta = 0; // & Bit_Align;
				}

				if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
				{
					Input_gamma = V_MSB;
				}
				else
				{
					Input_gamma = 0;  // & Bit_Align;
				}
				/////
				//printf("TTTTTTEST block 3-R \n");
				best = SPARX_128_round_r(search_round, 2,
						x_in_0, x_in_1, x_in_2, x_in_3, x_in_4, x_in_5,Input_gamma,Input_beta );
	#if 1   //是否找到第一条最优路径就返回？
			if(best == 1 )
			{
				wt_block[3][1] = w_B_3;
				X_128_r[6][1] = (ROTATE_LEFT(Input_alpha, 7, blocksize_len)) & Bit_Align;
				X_128_r[7][1] = Input_beta  & Bit_Align;
				return 1;
			}
	#endif
						}
		}
		else  //M0 > 0.
		{
			for ( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for ( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for ( i = 1; i<=M0; i++) { C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			best = SPARX_128_round_1_BLOCK_3_MSB(search_round,
					w_B_3,
					x_in_0, x_in_1, x_in_2, x_in_3, x_in_4, x_in_5,
					C0);
	#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
	#endif

			do
			{
				if (I0 == 0)
				{
					break;
				}
				else
				{
					if (T0[I0] < 0)
					{
						if ((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if ( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if (A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if (F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto BLOCK_Comb_3;
						}
						if (L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto BLOCK_Comb_3;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto BLOCK_Comb_3;
					}
					Y0 = I0;
					if (I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if (L0 == N0)
						{
							if (I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto BLOCK_Comb_3;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto BLOCK_Comb_3;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0; goto BLOCK_Comb_3;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if (I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto BLOCK_Comb_3;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
					BLOCK_Comb_3:
							A0[X0] = 1;
							A0[Y0] = 0;
							H0[X0] = Z0 = H0[Y0];
							C0[Z0] = X0;
							}
	////////////////////////////////////
				best = SPARX_128_round_1_BLOCK_3_MSB(search_round,
						w_B_3,
						x_in_0, x_in_1, x_in_2, x_in_3, x_in_4, x_in_5,
						C0);
	#if 1   //是否找到第一条最优路径就返回？
				if(best == 1 )
				{
					return 1;
				}
	#endif
						} while(1);
						}
	////////////////////
		return best;
}

u16 SPARX_128_round_1_BLOCK_3_MSB(u16 search_round,
		u16 w_B_3,
		u16 x_in_0, u16 x_in_1,u16 x_in_2, u16 x_in_3,u16 x_in_4, u16 x_in_5,
		char *posi)
{
	u16 state = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;
	u16 j_abc = 0;

			//2018年11月27日18:29:45 //全空间
			for(j_abc = 0; j_abc < 8;j_abc++)   // MSB
			{
				//if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
				if((j_abc & 0x4) != 0) // alpha bit j.
				{
					Input_alpha = V_MSB;
				}
				else
				{
					Input_alpha = 0;  // & Bit_Align;
				}

				//if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
				if((j_abc & 0x2) != 0) // alpha bit j.
				{
					Input_beta = V_MSB;
				}
				else
				{
					Input_beta = 0; // & Bit_Align;
				}

				//if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
				if((j_abc & 0x1) != 0) // alpha bit j.
				{
					Input_gamma = V_MSB;
				}
				else
				{
					Input_gamma = 0;  // & Bit_Align;
				}

				if((j_abc==1) || (j_abc==2) || (j_abc==4) || (j_abc==7) )
				{
					Input_alpha |= 0x7FFF;
					Input_beta  |= 0x7FFF;
					Input_gamma |= 0x7FFF;
				}

				state = SPARX_128_round_1_BLOCK_3_Middle(search_round,
						w_B_3,
						x_in_0, x_in_1,x_in_2, x_in_3,x_in_4, x_in_5,
						Input_alpha,Input_beta,Input_gamma,
						posi,w_B_3 );
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
		}
	return state;
}

u16 SPARX_128_round_1_BLOCK_3_Middle(u16 search_round,
		u16 w_B_3,
		u16 x_in_0, u16 x_in_1,u16 x_in_2, u16 x_in_3,u16 x_in_4, u16 x_in_5,
		u16 alpha, u16 beta, u16 gamma,
		char *posi,u16 cur_posi)
{
	u16 state = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u16 indx_tmp = 0;
//	u16 i = 0;
	u16 bit_i = 1;

			//indx_tmp = 1 << (posi[cur_posi] - 1);
			indx_tmp = posi[cur_posi] - 1;

					// Middle bit positionsof of alpha/beta/gamma
					if( cur_posi > 1)  // Middle bit positionsof of alpha/beta/gamma
					{

						for(j_abc = 1; j_abc < 7; j_abc++)   // MSB //for speck32/48/64
						//for(i = 0; i < 3; i++)   // MSB //for speck96/128
						{
							//j_abc = set_A_3[i];  //for speck96/128

							if((j_abc & 0x4) != 0) // alpha bit j.
							{
								Input_alpha = alpha | (bit_i << indx_tmp);
							}
							else
							{
								//Input_alpha = alpha; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
								Input_alpha = (alpha & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
							}

							if((j_abc & 0x2) != 0) // alpha bit j.
							{
								Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
							}
							else
							{
								//Input_beta = beta; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
								Input_beta = (beta & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
							}

							if((j_abc & 0x1) != 0) // alpha bit j.
							{
								Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
							}
							else
							{
								//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
								Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
							}

							//set A_3 of Middle
							if( (j_abc==3) || (j_abc==5) || (j_abc==6) )
							{
								// setA对应到下一个不全同比特位置,全设置为0才满足差分有效性条件.
								for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
								{
									Input_alpha &= ~(bit_i << j_last);
									Input_beta  &= ~(bit_i << j_last);
									Input_gamma &= ~(bit_i << j_last);
								}
							}     //对于speck96和speck128,不考虑导致后续比特全wei 1情况
							else //set B_3 of Middle //if((j_abc==1) || (j_abc==2) || (j_abc==4) )
							{
								// setB_3对应到下一个不全同比特位置,全设置为 1 才满足差分有效性条件.
								for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
								{
									Input_alpha ^= (bit_i << j_last);
									Input_beta  ^= (bit_i << j_last);
									Input_gamma ^= (bit_i << j_last);
								}
							}

							state = SPARX_128_round_1_BLOCK_3_Middle(search_round,
									w_B_3,
									x_in_0, x_in_1,x_in_2, x_in_3,x_in_4, x_in_5,
									Input_alpha,Input_beta,Input_gamma,
									posi,cur_posi-1	);
	#if 1   //是否找到第一条最优路径就返回？
		if(state == 1 )
		{
			return 1;
		}
	#endif
				}
					}
					else 	//call last position.
					{
						state = SPARX_128_round_1_BLOCK_3_Last(search_round,
								w_B_3,
								x_in_0, x_in_1,x_in_2, x_in_3,x_in_4, x_in_5,
								alpha, beta, gamma,
								posi);
		#if 1   //是否找到第一条最优路径就返回？
			if(state == 1 )
			{
				return 1;
			}
		#endif
					}
	return state;
}

u16 SPARX_128_round_1_BLOCK_3_Last(u16 search_round,
		u16 w_B_3,
		u16 x_in_0, u16 x_in_1,u16 x_in_2, u16 x_in_3,u16 x_in_4, u16 x_in_5,
		u16 alpha, u16 beta, u16 gamma,
		char *posi)
{
	u16 state = 0;
	u16 Input_alpha = 0;
	u16 Input_beta = 0;
	u16 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u16 indx_tmp = 0;
	u16 bit_i = 1;

			indx_tmp = posi[1] - 1;

			// Last bit position of alpha/beta/gamma // set_A_3
			for(j_abc = 0; j_abc < 3;j_abc++)// Last bit position.
			{
				if((set_A_3[j_abc] & 0x4) != 0) // alpha bit j.
				{
					Input_alpha = alpha | (bit_i << indx_tmp); // & Bit_Align;
				}
				else
				{
					//Input_alpha = alpha; // & ( ~(1 << indx_tmp))) & Bit_Align;
					Input_alpha = (alpha & ( ~(bit_i << indx_tmp))) & Bit_Align;
				}

				if((set_A_3[j_abc] & 0x2) != 0) // alpha bit j.
				{
					Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
				}
				else
				{
					//Input_beta = beta; // & ( ~(1 << indx_tmp))) & Bit_Align;
					Input_beta = (beta & ( ~(bit_i << indx_tmp))) & Bit_Align;
				}

				if((set_A_3[j_abc] & 0x1) != 0) // alpha bit j.
				{
					Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
				}
				else
				{
					//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ) & Bit_Align;
					Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ) & Bit_Align;
				}

		 	 	 // 若考虑set_B的情况,则需要在此将最低非全0比特位后面的比特全部清零
				if(posi[1] > 1)
					for(j_last=0; j_last< indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
					{
						Input_alpha &= ~(bit_i << j_last);
						Input_beta  &= ~(bit_i << j_last);
						Input_gamma &= ~(bit_i << j_last);
					}
				/*
				state = SPARX_128_round_r(search_round, 2,
						0x0000,0x0000,0x0000,0x0000,
						0x0000,0x0000,0x0040,0x0010);
*/
				state = SPARX_128_round_r(search_round, 2,
						x_in_0, x_in_1, x_in_2, x_in_3, x_in_4, x_in_5,
						(u16)Input_gamma,(u16)Input_beta );


#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		wt_block[3][1] = w_B_3;
		X_128_r[6][1] = (ROTATE_LEFT(Input_alpha, 7, blocksize_len)) & Bit_Align;
		X_128_r[7][1] = Input_beta  & Bit_Align;

//		X_128_r[6][1] = 0x2800;
//		X_128_r[7][1] = 0x0010;


		return 1;
	}
#endif
			}
	return state;
}

u16 SPARX_128_round_1_diff(u16 search_round)
{
	u16 best = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16 w_cmp = 0;
	u16 X_tmp[8] = {0};
	u16 xr0 =0,xr2=0,xr4 =0,xr6=0;
	u16 xor_Block[4] = {0};
	u16 wt_xor_Block[4] = {0};
	u16 wt_xor_Block_MSB[4] = {0};
	u64 AB_block[4][2] = {0};
	u16 alpha_block[4][2] = {0};
	u16 beta_block[4][2]  = {0};
	u16 gamma_block[4][2] = {0};
	u16 carry_tmp_block[4] = {0};
	u16 carry_block[4] = {0};
	u16 i0_l=0,i1_l=0,i2_l=0,i3_l=0;
	u16 i0_r=0,i1_r=0,i2_r=0,i3_r=0;
	u16 j0_l=0,j1_l=0,j2_l=0,j3_l=0;
	u16 j0_r=0,j1_r=0,j2_r=0,j3_r=0;
	u16 gamma_Output[4] = {0};

	X_tmp[0] = (ROTATE_RIGHT(X_in_0,7,blocksize_len)) & Bit_Align;
	X_tmp[1] = X_in_1;
	X_tmp[2] = (ROTATE_RIGHT(X_in_2,7,blocksize_len)) & Bit_Align;
	X_tmp[3] = X_in_3;
	X_tmp[4] = (ROTATE_RIGHT(X_in_4,7,blocksize_len)) & Bit_Align;
	X_tmp[5] = X_in_5;
	X_tmp[6] = (ROTATE_RIGHT(X_in_6, 7, blocksize_len)) & Bit_Align;
	X_tmp[7] = X_in_7;

	//Block 0 LSB
	alpha_block[0][0] = X_tmp[0] & 0xFF; //8 bit
	beta_block[0][0]  = X_tmp[1] & 0xFF; //8 bit
	AB_block[0][0] = (alpha_block[0][0] << 8) | beta_block[0][0];
	carry_tmp_block[0] = ((alpha_block[0][0] >> 7) << 2) + ((beta_block[0][0] >> 7) << 1);
	//carry_0_block[0] = 0;
	//Block 0 MSB
	alpha_block[0][1]= X_tmp[0] & 0xFF00; //8 bit
	beta_block[0][1] = (X_tmp[1] >> 8) & 0xFF; //8 bit
	AB_block[0][1] = alpha_block[0][1] | beta_block[0][1];
	wt_xor_Block_MSB[0] = cDDT_AB_wt_min[AB_block[0][1]];

	//Block 1 LSB
	alpha_block[1][0] = X_tmp[2] & 0xFF; //8 bit
	beta_block[1][0]  = X_tmp[3] & 0xFF; //8 bit
	AB_block[1][0] = (alpha_block[1][0] << 8) | beta_block[1][0];
	carry_tmp_block[1] = ((alpha_block[1][0] >> 7) << 2) + ((beta_block[1][0] >> 7) << 1);
	//carry_0_block[1] = 0;
	//Block 1 MSB
	alpha_block[1][1]= X_tmp[2] & 0xFF00; //8 bit
	beta_block[1][1] = (X_tmp[3] >> 8) & 0xFF; //8 bit
	AB_block[1][1] = alpha_block[1][1] | beta_block[1][1];
	wt_xor_Block_MSB[1] = cDDT_AB_wt_min[AB_block[1][1]];


	//Block 2 LSB
	alpha_block[2][0] = X_tmp[4] & 0xFF; //8 bit
	beta_block[2][0]  = X_tmp[5] & 0xFF; //8 bit
	AB_block[2][0] = (alpha_block[2][0] << 8) | beta_block[2][0];
	carry_tmp_block[2] = ((alpha_block[2][0] >> 7) << 2) + ((beta_block[2][0] >> 7) << 1);
	//carry_0_block[2] = 0;
	//Block 2 MSB
	alpha_block[2][1]= X_tmp[4] & 0xFF00; //8 bit
	beta_block[2][1] = (X_tmp[5] >> 8) & 0xFF; //8 bit
	AB_block[2][1] = alpha_block[2][1] | beta_block[2][1];
	wt_xor_Block_MSB[2] = cDDT_AB_wt_min[AB_block[2][1]];

	//Block 3 LSB
	alpha_block[3][0] = X_tmp[6] & 0xFF; //8 bit
	beta_block[3][0]  = X_tmp[7] & 0xFF; //8 bit
	AB_block[3][0] = (alpha_block[3][0] << 8) | beta_block[3][0];
	carry_tmp_block[3] = ((alpha_block[3][0] >> 7) << 2) + ((beta_block[3][0] >> 7) << 1);
	//carry_0_block[2] = 0;
	//Block 3 MSB
	alpha_block[3][1]= X_tmp[6] & 0xFF00; //8 bit
	beta_block[3][1] = (X_tmp[7] >> 8) & 0xFF; //8 bit
	AB_block[3][1] = alpha_block[3][1] | beta_block[3][1];
	wt_xor_Block_MSB[3] = cDDT_AB_wt_min[AB_block[3][1]];


//	w_cmp = wt_max - n_P_bestofR_w[search_round - 1];

	///////////开始组合可能的gamma
	//wt of BLock 0
	for(i0_r = cDDT_wt_min[0][AB_block[0][0]]; i0_r <= cDDT_wt_max[0][AB_block[0][0]]; i0_r++)
	{
//		if(i0_r + wt_xor_Block_MSB[0] +
//				wt_xor_Block[1] + wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 0
		for(j0_r=0; j0_r < cDDT_n[0][AB_block[0][0]][i0_r]; j0_r++)
		{
			gamma_block[0][0] = cDDT_v[0][AB_block[0][0]][i0_r][j0_r];
			carry_block[0] = carry_tmp_block[0] + (gamma_block[0][0] >> 7);
	for(i0_l = MSB_cDDT_wt_min[carry_block[0]][AB_block[0][1]]; i0_l <= MSB_cDDT_wt_max[carry_block[0]][AB_block[0][1]]; i0_l++)
	{
//		if(i0_r + i0_l +
//				wt_xor_Block[1] + wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0_l=0; j0_l < MSB_cDDT_n[carry_block[0]][AB_block[0][1]][i0_l]; j0_l++)
		{
			gamma_block[0][1] = MSB_cDDT_v[carry_block[0]][AB_block[0][1]][i0_l][j0_l];
			gamma_Output[0] = ((gamma_block[0][1] << 8) | gamma_block[0][0]) & 0xFFFF;


	//wt of BLock 1
	for(i1_r = cDDT_wt_min[0][AB_block[1][0]]; i1_r <= cDDT_wt_max[0][AB_block[1][0]]; i1_r++)
	{
//		if(i0_r + i0_l + wt_xor_Block_MSB[1] + i1_r +
//				wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 1
		for(j1_r=0; j1_r < cDDT_n[0][AB_block[1][0]][i1_r]; j1_r++)
		{
			gamma_block[1][0] = cDDT_v[0][AB_block[1][0]][i1_r][j1_r];
			carry_block[1] = carry_tmp_block[1] + (gamma_block[1][0] >> 7);
	for(i1_l = MSB_cDDT_wt_min[carry_block[1]][AB_block[1][1]]; i1_l <= MSB_cDDT_wt_max[carry_block[1]][AB_block[1][1]]; i1_l++)
	{
//		if(i0_l + i0_r + i1_l + i1_r +
//				wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1_l=0; j1_l < MSB_cDDT_n[carry_block[1]][AB_block[1][1]][i1_l]; j1_l++)
		{
			gamma_block[1][1] = MSB_cDDT_v[carry_block[1]][AB_block[1][1]][i1_l][j1_l];
			gamma_Output[1] = ((gamma_block[1][1] << 8) | gamma_block[1][0]) & 0xFFFF;


	//wt of BLock 2
	for(i2_r = cDDT_wt_min[0][AB_block[2][0]]; i2_r <= cDDT_wt_max[0][AB_block[2][0]]; i2_r++)
	{
//		if(i0_l + i0_r + i1_l + i1_r + wt_xor_Block_MSB[2] + i2_r +
//				wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 2
		for(j2_r=0; j2_r < cDDT_n[0][AB_block[2][0]][i2_r]; j2_r++)
		{
			gamma_block[2][0] = cDDT_v[0][AB_block[2][0]][i2_r][j2_r];
			carry_block[2] = carry_tmp_block[2] + (gamma_block[2][0] >> 7);
	for(i2_l = MSB_cDDT_wt_min[carry_block[2]][AB_block[2][1]]; i2_l <= MSB_cDDT_wt_max[carry_block[2]][AB_block[2][1]]; i2_l++)
	{
//		if(i0_l + i0_r + i1_l + i1_r + i2_l + i2_r +
//				wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2_l=0; j2_l < MSB_cDDT_n[carry_block[2]][AB_block[2][1]][i2_l]; j2_l++)
		{
			gamma_block[2][1] = MSB_cDDT_v[carry_block[2]][AB_block[2][1]][i2_l][j2_l];
			gamma_Output[2] = ((gamma_block[2][1] << 8) | gamma_block[2][0]) & 0xFFFF;


	//wt of BLock 3
	for(i3_r = cDDT_wt_min[0][AB_block[3][0]]; i3_r <= cDDT_wt_max[0][AB_block[3][0]]; i3_r++)
	{
//		if(i0_l + i0_r + i1_l + i1_r + i2_l +
//				i3_r + wt_xor_Block_MSB[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 3
		for(j3_r=0; j3_r < cDDT_n[0][AB_block[3][0]][i3_r]; j3_r++)
		{
			gamma_block[3][0] = cDDT_v[0][AB_block[3][0]][i3_r][j3_r];
			carry_block[3] = carry_tmp_block[3] + (gamma_block[3][0] >> 7);
	for(i3_l = MSB_cDDT_wt_min[carry_block[3]][AB_block[3][1]]; i3_l <= MSB_cDDT_wt_max[carry_block[3]][AB_block[3][1]]; i3_l++)
	{
//		if(i0_l + i0_r + i1_l + i1_r + i2_l + i2_r +
//				i3_l + i3_r > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3_l=0; j3_l < MSB_cDDT_n[carry_block[3]][AB_block[3][1]][i3_l]; j3_l++)
		{
			gamma_block[3][1] = MSB_cDDT_v[carry_block[3]][AB_block[3][1]][i3_l][j3_l];
			gamma_Output[3] = ((gamma_block[3][1] << 8) | gamma_block[3][0]) & 0xFFFF;

			P_w[1] = i0_l + i0_r + i1_l + i1_r + i2_l + i2_r + i3_l + i3_r;

			//调用下一轮
			best = SPARX_128_round_r_diff(search_round, 2,
					(u16)gamma_Output[0], (u16)X_tmp[1],
					(u16)gamma_Output[1], (u16)X_tmp[3],
					(u16)gamma_Output[2], (u16)X_tmp[5],
					(u16)gamma_Output[3], (u16)X_tmp[7]);

		}}}}}}}}}}}}}}}}

	return best;
}

u16 SPARX_128_round_r(u16 search_round, u16 cur_round,
		u16 x_in_0, u16 x_in_1,u16 x_in_2, u16 x_in_3,
		u16 x_in_4, u16 x_in_5,u16 x_in_6, u16 x_in_7)
{
	u16 best = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16 w_cmp = 0;
	u16 X_tmp[8] = {0};
	u16 xr0 =0,xr2=0,xr4 =0,xr6=0;
	u16 xor_Block[4] = {0};
	u16 wt_xor_Block[4] = {0};
	u16 wt_xor_Block_MSB[4] = {0};
	u64 AB_block[4][2] = {0};
	u16 alpha_block[4][2] = {0};
	u16 beta_block[4][2]  = {0};
	u16 gamma_block[4][2] = {0};
	u16 carry_tmp_block[4] = {0};
	u16 carry_block[4] = {0};
	u16 i0_l=0,i1_l=0,i2_l=0,i3_l=0;
	u16 i0_r=0,i1_r=0,i2_r=0,i3_r=0;
	u16 j0_l=0,j1_l=0,j2_l=0,j3_l=0;
	u16 j0_r=0,j1_r=0,j2_r=0,j3_r=0;
	u16 gamma_Output[4] = {0};
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;



	if(search_round == cur_round)
	{
		best = SPARX_128_round_N(search_round,
				x_in_0, x_in_1, x_in_2, x_in_3,
				x_in_4, x_in_5,x_in_6, x_in_7);
		return best;
	}

	if(((cur_round -1) % 4) == 0) //5,9,13,,,,
	{
		X_tmp[0] = x_in_0 & Bit_Align;
		X_tmp[1] = (x_in_0 ^ ROTATE_LEFT(x_in_1,2,blocksize_len)) & Bit_Align;
		X_tmp[2] = x_in_2 & Bit_Align;
		X_tmp[3] = (x_in_2 ^ ROTATE_LEFT(x_in_3,2,blocksize_len)) & Bit_Align;
		X_tmp[4] = x_in_4 & Bit_Align;
		X_tmp[5] = (x_in_4 ^ ROTATE_LEFT(x_in_5,2,blocksize_len)) & Bit_Align;
		X_tmp[6] = x_in_6 & Bit_Align;
		X_tmp[7] = (x_in_6 ^ ROTATE_LEFT(x_in_7,2,blocksize_len)) & Bit_Align;

		//L前后的需要输出  //用于输出经L变换前的前轮输出
		IN128_L_X[cur_round/4][0] = X_tmp[0];
		IN128_L_X[cur_round/4][1] = X_tmp[1];
		IN128_L_X[cur_round/4][2] = X_tmp[2];
		IN128_L_X[cur_round/4][3] = X_tmp[3];
		IN128_L_X[cur_round/4][4] = X_tmp[4];
		IN128_L_X[cur_round/4][5] = X_tmp[5];
		IN128_L_X[cur_round/4][6] = X_tmp[6];
		IN128_L_X[cur_round/4][7] = X_tmp[7];

		// L // switch function.
		L4_Switch_per4Round(&X_tmp[0],&X_tmp[1],&X_tmp[2],&X_tmp[3],
				&X_tmp[4],&X_tmp[5],&X_tmp[6],&X_tmp[7]);

		xr0 = X_tmp[0];
		xr2 = X_tmp[2];
		xr4 = X_tmp[4];
		xr6 = X_tmp[6];

		X_tmp[0] = (ROTATE_RIGHT(xr0,7,blocksize_len)) & Bit_Align;
		X_tmp[2] = (ROTATE_RIGHT(xr2,7,blocksize_len)) & Bit_Align;
		X_tmp[4] = (ROTATE_RIGHT(xr4,7,blocksize_len)) & Bit_Align;
		X_tmp[6] = (ROTATE_RIGHT(xr6,7,blocksize_len)) & Bit_Align;
		//printf("x0: %x x1: %x x2: %x x3: %x \n",*X0 ,*X1,*X2,*X3);
	}
	else
	{
		X_tmp[0] = (ROTATE_RIGHT(x_in_0,7,blocksize_len)) & Bit_Align;
		X_tmp[1] = (x_in_0 ^ ROTATE_LEFT(x_in_1,2,blocksize_len)) & Bit_Align;
		X_tmp[2] = (ROTATE_RIGHT(x_in_2,7,blocksize_len)) & Bit_Align;
		X_tmp[3] = (x_in_2 ^ ROTATE_LEFT(x_in_3,2,blocksize_len)) & Bit_Align;
		X_tmp[4] = (ROTATE_RIGHT(x_in_4,7,blocksize_len)) & Bit_Align;
		X_tmp[5] = (x_in_4 ^ ROTATE_LEFT(x_in_5,2,blocksize_len)) & Bit_Align;
		X_tmp[6] = (ROTATE_RIGHT(x_in_6, 7, blocksize_len)) & Bit_Align;
		X_tmp[7] = (x_in_6 ^ ROTATE_LEFT(x_in_7,2,blocksize_len)) & Bit_Align;
	}

	xor_Block[0] = (X_tmp[0] ^ X_tmp[1]) & ValueMax_Align;
	xor_Block[1] = (X_tmp[2] ^ X_tmp[3]) & ValueMax_Align;
	xor_Block[2] = (X_tmp[4] ^ X_tmp[5]) & ValueMax_Align;
	xor_Block[3] = (X_tmp[6] ^ X_tmp[7]) & ValueMax_Align;

	wt_xor_Block[0] = HM_weight(xor_Block[0]);
	wt_xor_Block[1] = HM_weight(xor_Block[1]);
	wt_xor_Block[2] = HM_weight(xor_Block[2]);
	wt_xor_Block[3] = HM_weight(xor_Block[3]);

	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = Bn_w - p_sumof_r - n_P_bestofR_w[search_round - cur_round];
	if (wt_xor_Block[0] + wt_xor_Block[1] + wt_xor_Block[2] + wt_xor_Block[3] > w_cmp)
	{
		return 0;
	}


	//Block 0 LSB
	alpha_block[0][0] = X_tmp[0] & 0xFF; //8 bit
	beta_block[0][0]  = X_tmp[1] & 0xFF; //8 bit
	AB_block[0][0] = (alpha_block[0][0] << 8) | beta_block[0][0];
	carry_tmp_block[0] = ((alpha_block[0][0] >> 7) << 2) + ((beta_block[0][0] >> 7) << 1);
	//carry_0_block[0] = 0;
	//Block 0 MSB
	alpha_block[0][1]= X_tmp[0] & 0xFF00; //8 bit
	beta_block[0][1] = (X_tmp[1] >> 8) & 0xFF; //8 bit
	AB_block[0][1] = alpha_block[0][1] | beta_block[0][1];
	wt_xor_Block_MSB[0] = cDDT_AB_wt_min[AB_block[0][1]];

	//Block 1 LSB
	alpha_block[1][0] = X_tmp[2] & 0xFF; //8 bit
	beta_block[1][0]  = X_tmp[3] & 0xFF; //8 bit
	AB_block[1][0] = (alpha_block[1][0] << 8) | beta_block[1][0];
	carry_tmp_block[1] = ((alpha_block[1][0] >> 7) << 2) + ((beta_block[1][0] >> 7) << 1);
	//carry_0_block[1] = 0;
	//Block 1 MSB
	alpha_block[1][1]= X_tmp[2] & 0xFF00; //8 bit
	beta_block[1][1] = (X_tmp[3] >> 8) & 0xFF; //8 bit
	AB_block[1][1] = alpha_block[1][1] | beta_block[1][1];
	wt_xor_Block_MSB[1] = cDDT_AB_wt_min[AB_block[1][1]];


	//Block 2 LSB
	alpha_block[2][0] = X_tmp[4] & 0xFF; //8 bit
	beta_block[2][0]  = X_tmp[5] & 0xFF; //8 bit
	AB_block[2][0] = (alpha_block[2][0] << 8) | beta_block[2][0];
	carry_tmp_block[2] = ((alpha_block[2][0] >> 7) << 2) + ((beta_block[2][0] >> 7) << 1);
	//carry_0_block[2] = 0;
	//Block 2 MSB
	alpha_block[2][1]= X_tmp[4] & 0xFF00; //8 bit
	beta_block[2][1] = (X_tmp[5] >> 8) & 0xFF; //8 bit
	AB_block[2][1] = alpha_block[2][1] | beta_block[2][1];
	wt_xor_Block_MSB[2] = cDDT_AB_wt_min[AB_block[2][1]];

	//Block 3 LSB
	alpha_block[3][0] = X_tmp[6] & 0xFF; //8 bit
	beta_block[3][0]  = X_tmp[7] & 0xFF; //8 bit
	AB_block[3][0] = (alpha_block[3][0] << 8) | beta_block[3][0];
	carry_tmp_block[3] = ((alpha_block[3][0] >> 7) << 2) + ((beta_block[3][0] >> 7) << 1);
	//carry_0_block[2] = 0;
	//Block 3 MSB
	alpha_block[3][1]= X_tmp[6] & 0xFF00; //8 bit
	beta_block[3][1] = (X_tmp[7] >> 8) & 0xFF; //8 bit
	AB_block[3][1] = alpha_block[3][1] | beta_block[3][1];
	wt_xor_Block_MSB[3] = cDDT_AB_wt_min[AB_block[3][1]];

	///////////开始组合可能的gamma// 每个block的概率重量范围可以限定
	//wt of BLock 0
	for(i0_r = cDDT_wt_min[0][AB_block[0][0]];
			i0_r <= cDDT_wt_min[0][AB_block[0][0]] ; i0_r++)  //cDDT_wt_max[0][AB_block[0][0]]
	{
		if(i0_r + wt_xor_Block_MSB[0] +
				wt_xor_Block[1] + wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 0
		for(j0_r=0; j0_r < cDDT_n[0][AB_block[0][0]][i0_r]; j0_r++)
		{
			gamma_block[0][0] = cDDT_v[0][AB_block[0][0]][i0_r][j0_r];
			carry_block[0] = carry_tmp_block[0] + (gamma_block[0][0] >> 7);
	for(i0_l = MSB_cDDT_wt_min[carry_block[0]][AB_block[0][1]];
			i0_l <= MSB_cDDT_wt_min[carry_block[0]][AB_block[0][1]]; i0_l++)  //MSB_cDDT_wt_max[carry_block[0]][AB_block[0][1]]
	{
		w1 = i0_r + i0_l;
		if(w1 +	wt_xor_Block[1] + wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0_l=0; j0_l < MSB_cDDT_n[carry_block[0]][AB_block[0][1]][i0_l]; j0_l++)
		{
			gamma_block[0][1] = MSB_cDDT_v[carry_block[0]][AB_block[0][1]][i0_l][j0_l];
			gamma_Output[0] = ((gamma_block[0][1] << 8) | gamma_block[0][0]) & 0xFFFF;


	//wt of BLock 1
	for(i1_r = cDDT_wt_min[0][AB_block[1][0]];
			i1_r <= cDDT_wt_min[0][AB_block[1][0]]; i1_r++)  //cDDT_wt_max[0][AB_block[1][0]]
	{
		w2 = w1 + i1_r;
		if(w2 + wt_xor_Block_MSB[1] +
				wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 1
		for(j1_r=0; j1_r < cDDT_n[0][AB_block[1][0]][i1_r]; j1_r++)
		{
			gamma_block[1][0] = cDDT_v[0][AB_block[1][0]][i1_r][j1_r];
			carry_block[1] = carry_tmp_block[1] + (gamma_block[1][0] >> 7);
	for(i1_l = MSB_cDDT_wt_min[carry_block[1]][AB_block[1][1]];
			i1_l <= MSB_cDDT_wt_min[carry_block[1]][AB_block[1][1]]; i1_l++)  //MSB_cDDT_wt_max[carry_block[1]][AB_block[1][1]]
	{
		w3 = w2 + i1_l;
		if(w3 + wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1_l=0; j1_l < MSB_cDDT_n[carry_block[1]][AB_block[1][1]][i1_l]; j1_l++)
		{
			gamma_block[1][1] = MSB_cDDT_v[carry_block[1]][AB_block[1][1]][i1_l][j1_l];
			gamma_Output[1] = ((gamma_block[1][1] << 8) | gamma_block[1][0]) & 0xFFFF;


	//wt of BLock 2
	for(i2_r = cDDT_wt_min[0][AB_block[2][0]];
			i2_r <= cDDT_wt_min[0][AB_block[2][0]]; i2_r++)  //cDDT_wt_max[0][AB_block[2][0]]
	{
		w4 = w3 + i2_r;
		if(w4 + wt_xor_Block_MSB[2] +
				wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 2
		for(j2_r=0; j2_r < cDDT_n[0][AB_block[2][0]][i2_r]; j2_r++)
		{
			gamma_block[2][0] = cDDT_v[0][AB_block[2][0]][i2_r][j2_r];
			carry_block[2] = carry_tmp_block[2] + (gamma_block[2][0] >> 7);
	for(i2_l = MSB_cDDT_wt_min[carry_block[2]][AB_block[2][1]];
			i2_l <= MSB_cDDT_wt_min[carry_block[2]][AB_block[2][1]]; i2_l++)  //MSB_cDDT_wt_max[carry_block[2]][AB_block[2][1]]
	{
		w5 = w4 + i2_l;
		if(w5 +
				wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2_l=0; j2_l < MSB_cDDT_n[carry_block[2]][AB_block[2][1]][i2_l]; j2_l++)
		{
			gamma_block[2][1] = MSB_cDDT_v[carry_block[2]][AB_block[2][1]][i2_l][j2_l];
			gamma_Output[2] = ((gamma_block[2][1] << 8) | gamma_block[2][0]) & 0xFFFF;


	//wt of BLock 3
	for(i3_r = cDDT_wt_min[0][AB_block[3][0]];
			i3_r <= cDDT_wt_min[0][AB_block[3][0]]; i3_r++)  //cDDT_wt_max[0][AB_block[3][0]]
	{
		w6 = w5 + i3_r;
		if(w6 +
			  wt_xor_Block_MSB[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 3
		for(j3_r=0; j3_r < cDDT_n[0][AB_block[3][0]][i3_r]; j3_r++)
		{
			gamma_block[3][0] = cDDT_v[0][AB_block[3][0]][i3_r][j3_r];
			carry_block[3] = carry_tmp_block[3] + (gamma_block[3][0] >> 7);
	for(i3_l = MSB_cDDT_wt_min[carry_block[3]][AB_block[3][1]];
			i3_l <= MSB_cDDT_wt_min[carry_block[3]][AB_block[3][1]]; i3_l++) //MSB_cDDT_wt_max[carry_block[3]][AB_block[3][1]]
	{
		w7 = w6 + i3_l;
		if(w7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3_l=0; j3_l < MSB_cDDT_n[carry_block[3]][AB_block[3][1]][i3_l]; j3_l++)
		{
			gamma_block[3][1] = MSB_cDDT_v[carry_block[3]][AB_block[3][1]][i3_l][j3_l];
			gamma_Output[3] = ((gamma_block[3][1] << 8) | gamma_block[3][0]) & 0xFFFF;

			P_w[cur_round] = w7; //i0_l + i0_r + i1_l + i1_r + i2_l + i2_r + i3_l + i3_r;

			//调用下一轮
			best = SPARX_128_round_r(search_round, cur_round + 1,
					(u16)gamma_Output[0], (u16)X_tmp[1],
					(u16)gamma_Output[1], (u16)X_tmp[3],
					(u16)gamma_Output[2], (u16)X_tmp[5],
					(u16)gamma_Output[3], (u16)X_tmp[7]);

#if 1   //是否找到第一条最优路径就返回？
	if( best == 1 )
	{
		wt_block[0][cur_round] = i0_l + i0_r;
		wt_block[1][cur_round] = i1_l + i1_r;
		wt_block[2][cur_round] = i2_l + i2_r;
		wt_block[3][cur_round] = i3_l + i3_r;

		if(((cur_round -1) % 4) == 0) //5,9,13...
		{
			X_128_r[0][cur_round] = xr0;
			X_128_r[1][cur_round] = X_tmp[1];
			X_128_r[2][cur_round] = xr2;
			X_128_r[3][cur_round] = X_tmp[3];
			X_128_r[4][cur_round] = xr4;
			X_128_r[5][cur_round] = X_tmp[5];
			X_128_r[6][cur_round] = xr6;
			X_128_r[7][cur_round] = X_tmp[7];
		}
		else
		{
			X_128_r[0][cur_round] = x_in_0;
			X_128_r[1][cur_round] = X_tmp[1];
			X_128_r[2][cur_round] = x_in_2;
			X_128_r[3][cur_round] = X_tmp[3];
			X_128_r[4][cur_round] = x_in_4;
			X_128_r[5][cur_round] = X_tmp[5];
			X_128_r[6][cur_round] = x_in_6;
			X_128_r[7][cur_round] = X_tmp[7];
		}

		return 1;
	}
#endif
		}}}}}}}}}}}}}}}}
	return best;
}

u16 SPARX_128_round_r_diff(u16 search_round, u16 cur_round,
		u16 x_in_0, u16 x_in_1,u16 x_in_2, u16 x_in_3,
		u16 x_in_4, u16 x_in_5,u16 x_in_6, u16 x_in_7)
{
	u16 best = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16 w_cmp = 0;
	u16 X_tmp[8] = {0};
	u16 xr0 =0,xr2=0,xr4 =0,xr6=0;
	u16 xor_Block[4] = {0};
	u16 wt_xor_Block[4] = {0};
	u16 wt_xor_Block_MSB[4] = {0};
	u64 AB_block[4][2] = {0};
	u16 alpha_block[4][2] = {0};
	u16 beta_block[4][2]  = {0};
	u16 gamma_block[4][2] = {0};
	u16 carry_tmp_block[4] = {0};
	u16 carry_block[4] = {0};
	u16 i0_l=0,i1_l=0,i2_l=0,i3_l=0;
	u16 i0_r=0,i1_r=0,i2_r=0,i3_r=0;
	u16 j0_l=0,j1_l=0,j2_l=0,j3_l=0;
	u16 j0_r=0,j1_r=0,j2_r=0,j3_r=0;
	u16 gamma_Output[4] = {0};
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;


	if(search_round == cur_round)
	{
		best = SPARX_128_round_N_diff(search_round,
				x_in_0, x_in_1, x_in_2, x_in_3,
				x_in_4, x_in_5,x_in_6, x_in_7);
		return best;
	}


	if(((cur_round -1) % 4) == 0) //5,9,13,,,,
	{
		X_tmp[0] = x_in_0 & Bit_Align;
		X_tmp[1] = (x_in_0 ^ ROTATE_LEFT(x_in_1,2,blocksize_len)) & Bit_Align;
		X_tmp[2] = x_in_2 & Bit_Align;
		X_tmp[3] = (x_in_2 ^ ROTATE_LEFT(x_in_3,2,blocksize_len)) & Bit_Align;
		X_tmp[4] = x_in_4 & Bit_Align;
		X_tmp[5] = (x_in_4 ^ ROTATE_LEFT(x_in_5,2,blocksize_len)) & Bit_Align;
		X_tmp[6] = x_in_6 & Bit_Align;
		X_tmp[7] = (x_in_6 ^ ROTATE_LEFT(x_in_7,2,blocksize_len)) & Bit_Align;

		//L前后的需要输出  //用于输出经L变换前的前轮输出
		IN128_L_X[cur_round/4][0] = X_tmp[0];
		IN128_L_X[cur_round/4][1] = X_tmp[1];
		IN128_L_X[cur_round/4][2] = X_tmp[2];
		IN128_L_X[cur_round/4][3] = X_tmp[3];
		IN128_L_X[cur_round/4][4] = X_tmp[4];
		IN128_L_X[cur_round/4][5] = X_tmp[5];
		IN128_L_X[cur_round/4][6] = X_tmp[6];
		IN128_L_X[cur_round/4][7] = X_tmp[7];

		// L // switch function.
		L4_Switch_per4Round(&X_tmp[0],&X_tmp[1],&X_tmp[2],&X_tmp[3],
				&X_tmp[4],&X_tmp[5],&X_tmp[6],&X_tmp[7]);

		xr0 = X_tmp[0];
		xr2 = X_tmp[2];
		xr4 = X_tmp[4];
		xr6 = X_tmp[6];

		X_tmp[0] = (ROTATE_RIGHT(xr0,7,blocksize_len)) & Bit_Align;
		X_tmp[2] = (ROTATE_RIGHT(xr2,7,blocksize_len)) & Bit_Align;
		X_tmp[4] = (ROTATE_RIGHT(xr4,7,blocksize_len)) & Bit_Align;
		X_tmp[6] = (ROTATE_RIGHT(xr6,7,blocksize_len)) & Bit_Align;
		//printf("x0: %x x1: %x x2: %x x3: %x \n",*X0 ,*X1,*X2,*X3);
	}
	else
	{
		X_tmp[0] = (ROTATE_RIGHT(x_in_0,7,blocksize_len)) & Bit_Align;
		X_tmp[1] = (x_in_0 ^ ROTATE_LEFT(x_in_1,2,blocksize_len)) & Bit_Align;
		X_tmp[2] = (ROTATE_RIGHT(x_in_2,7,blocksize_len)) & Bit_Align;
		X_tmp[3] = (x_in_2 ^ ROTATE_LEFT(x_in_3,2,blocksize_len)) & Bit_Align;
		X_tmp[4] = (ROTATE_RIGHT(x_in_4,7,blocksize_len)) & Bit_Align;
		X_tmp[5] = (x_in_4 ^ ROTATE_LEFT(x_in_5,2,blocksize_len)) & Bit_Align;
		X_tmp[6] = (ROTATE_RIGHT(x_in_6, 7, blocksize_len)) & Bit_Align;
		X_tmp[7] = (x_in_6 ^ ROTATE_LEFT(x_in_7,2,blocksize_len)) & Bit_Align;
	}

	xor_Block[0] = (X_tmp[0] ^ X_tmp[1]) & ValueMax_Align;
	xor_Block[1] = (X_tmp[2] ^ X_tmp[3]) & ValueMax_Align;
	xor_Block[2] = (X_tmp[4] ^ X_tmp[5]) & ValueMax_Align;
	xor_Block[3] = (X_tmp[6] ^ X_tmp[7]) & ValueMax_Align;

	wt_xor_Block[0] = HM_weight(xor_Block[0]);
	wt_xor_Block[1] = HM_weight(xor_Block[1]);
	wt_xor_Block[2] = HM_weight(xor_Block[2]);
	wt_xor_Block[3] = HM_weight(xor_Block[3]);

	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r - n_P_bestofR_w[search_round - cur_round];
	if (wt_xor_Block[0] + wt_xor_Block[1] + wt_xor_Block[2] + wt_xor_Block[3] > w_cmp)
	{
		return 0;
	}


	//Block 0 LSB
	alpha_block[0][0] = X_tmp[0] & 0xFF; //8 bit
	beta_block[0][0]  = X_tmp[1] & 0xFF; //8 bit
	AB_block[0][0] = (alpha_block[0][0] << 8) | beta_block[0][0];
	carry_tmp_block[0] = ((alpha_block[0][0] >> 7) << 2) + ((beta_block[0][0] >> 7) << 1);
	//carry_0_block[0] = 0;
	//Block 0 MSB
	alpha_block[0][1]= X_tmp[0] & 0xFF00; //8 bit
	beta_block[0][1] = (X_tmp[1] >> 8) & 0xFF; //8 bit
	AB_block[0][1] = alpha_block[0][1] | beta_block[0][1];
	wt_xor_Block_MSB[0] = cDDT_AB_wt_min[AB_block[0][1]];

	//Block 1 LSB
	alpha_block[1][0] = X_tmp[2] & 0xFF; //8 bit
	beta_block[1][0]  = X_tmp[3] & 0xFF; //8 bit
	AB_block[1][0] = (alpha_block[1][0] << 8) | beta_block[1][0];
	carry_tmp_block[1] = ((alpha_block[1][0] >> 7) << 2) + ((beta_block[1][0] >> 7) << 1);
	//carry_0_block[1] = 0;
	//Block 1 MSB
	alpha_block[1][1]= X_tmp[2] & 0xFF00; //8 bit
	beta_block[1][1] = (X_tmp[3] >> 8) & 0xFF; //8 bit
	AB_block[1][1] = alpha_block[1][1] | beta_block[1][1];
	wt_xor_Block_MSB[1] = cDDT_AB_wt_min[AB_block[1][1]];


	//Block 2 LSB
	alpha_block[2][0] = X_tmp[4] & 0xFF; //8 bit
	beta_block[2][0]  = X_tmp[5] & 0xFF; //8 bit
	AB_block[2][0] = (alpha_block[2][0] << 8) | beta_block[2][0];
	carry_tmp_block[2] = ((alpha_block[2][0] >> 7) << 2) + ((beta_block[2][0] >> 7) << 1);
	//carry_0_block[2] = 0;
	//Block 2 MSB
	alpha_block[2][1]= X_tmp[4] & 0xFF00; //8 bit
	beta_block[2][1] = (X_tmp[5] >> 8) & 0xFF; //8 bit
	AB_block[2][1] = alpha_block[2][1] | beta_block[2][1];
	wt_xor_Block_MSB[2] = cDDT_AB_wt_min[AB_block[2][1]];

	//Block 3 LSB
	alpha_block[3][0] = X_tmp[6] & 0xFF; //8 bit
	beta_block[3][0]  = X_tmp[7] & 0xFF; //8 bit
	AB_block[3][0] = (alpha_block[3][0] << 8) | beta_block[3][0];
	carry_tmp_block[3] = ((alpha_block[3][0] >> 7) << 2) + ((beta_block[3][0] >> 7) << 1);
	//carry_0_block[2] = 0;
	//Block 3 MSB
	alpha_block[3][1]= X_tmp[6] & 0xFF00; //8 bit
	beta_block[3][1] = (X_tmp[7] >> 8) & 0xFF; //8 bit
	AB_block[3][1] = alpha_block[3][1] | beta_block[3][1];
	wt_xor_Block_MSB[3] = cDDT_AB_wt_min[AB_block[3][1]];

	///////////开始组合可能的gamma
	//wt of BLock 0
	for(i0_r = cDDT_wt_min[0][AB_block[0][0]]; i0_r <= cDDT_wt_max[0][AB_block[0][0]]; i0_r++)
	{
		if(i0_r + wt_xor_Block_MSB[0] +
				wt_xor_Block[1] + wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 0
		for(j0_r=0; j0_r < cDDT_n[0][AB_block[0][0]][i0_r]; j0_r++)
		{
			gamma_block[0][0] = cDDT_v[0][AB_block[0][0]][i0_r][j0_r];
			carry_block[0] = carry_tmp_block[0] + (gamma_block[0][0] >> 7);
	for(i0_l = MSB_cDDT_wt_min[carry_block[0]][AB_block[0][1]]; i0_l <= MSB_cDDT_wt_max[carry_block[0]][AB_block[0][1]]; i0_l++)
	{
		w1 = i0_r + i0_l;
		if(w1 +	wt_xor_Block[1] + wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}
		for(j0_l=0; j0_l < MSB_cDDT_n[carry_block[0]][AB_block[0][1]][i0_l]; j0_l++)
		{
			gamma_block[0][1] = MSB_cDDT_v[carry_block[0]][AB_block[0][1]][i0_l][j0_l];
			gamma_Output[0] = ((gamma_block[0][1] << 8) | gamma_block[0][0]) & 0xFFFF;


	//wt of BLock 1
	for(i1_r = cDDT_wt_min[0][AB_block[1][0]]; i1_r <= cDDT_wt_max[0][AB_block[1][0]]; i1_r++)
	{
		w2 = w1 + i1_r;
		if(w2 + wt_xor_Block_MSB[1] +
				wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 1
		for(j1_r=0; j1_r < cDDT_n[0][AB_block[1][0]][i1_r]; j1_r++)
		{
			gamma_block[1][0] = cDDT_v[0][AB_block[1][0]][i1_r][j1_r];
			carry_block[1] = carry_tmp_block[1] + (gamma_block[1][0] >> 7);
	for(i1_l = MSB_cDDT_wt_min[carry_block[1]][AB_block[1][1]]; i1_l <= MSB_cDDT_wt_max[carry_block[1]][AB_block[1][1]]; i1_l++)
	{
		w3 = w2 + i1_l;
		if(w3 + wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;} //break 要比 continue 高效,直接结束.
		for(j1_l=0; j1_l < MSB_cDDT_n[carry_block[1]][AB_block[1][1]][i1_l]; j1_l++)
		{
			gamma_block[1][1] = MSB_cDDT_v[carry_block[1]][AB_block[1][1]][i1_l][j1_l];
			gamma_Output[1] = ((gamma_block[1][1] << 8) | gamma_block[1][0]) & 0xFFFF;


	//wt of BLock 2
	for(i2_r = cDDT_wt_min[0][AB_block[2][0]]; i2_r <= cDDT_wt_max[0][AB_block[2][0]]; i2_r++)
	{
		w4 = w3 + i2_r;
		if(w4 + wt_xor_Block_MSB[2] +
				wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 2
		for(j2_r=0; j2_r < cDDT_n[0][AB_block[2][0]][i2_r]; j2_r++)
		{
			gamma_block[2][0] = cDDT_v[0][AB_block[2][0]][i2_r][j2_r];
			carry_block[2] = carry_tmp_block[2] + (gamma_block[2][0] >> 7);
	for(i2_l = MSB_cDDT_wt_min[carry_block[2]][AB_block[2][1]]; i2_l <= MSB_cDDT_wt_max[carry_block[2]][AB_block[2][1]]; i2_l++)
	{
		w5 = w4 + i2_l;
		if(w5 +	wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2_l=0; j2_l < MSB_cDDT_n[carry_block[2]][AB_block[2][1]][i2_l]; j2_l++)
		{
			gamma_block[2][1] = MSB_cDDT_v[carry_block[2]][AB_block[2][1]][i2_l][j2_l];
			gamma_Output[2] = ((gamma_block[2][1] << 8) | gamma_block[2][0]) & 0xFFFF;


	//wt of BLock 3
	for(i3_r = cDDT_wt_min[0][AB_block[3][0]]; i3_r <= cDDT_wt_max[0][AB_block[3][0]]; i3_r++)
	{
		w6 = w5 + i3_r;
		if(w6 + wt_xor_Block_MSB[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 3
		for(j3_r=0; j3_r < cDDT_n[0][AB_block[3][0]][i3_r]; j3_r++)
		{
			gamma_block[3][0] = cDDT_v[0][AB_block[3][0]][i3_r][j3_r];
			carry_block[3] = carry_tmp_block[3] + (gamma_block[3][0] >> 7);
	for(i3_l = MSB_cDDT_wt_min[carry_block[3]][AB_block[3][1]]; i3_l <= MSB_cDDT_wt_max[carry_block[3]][AB_block[3][1]]; i3_l++)
	{
		w7 = w6 + i3_l;
		if(w7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3_l=0; j3_l < MSB_cDDT_n[carry_block[3]][AB_block[3][1]][i3_l]; j3_l++)
		{
			gamma_block[3][1] = MSB_cDDT_v[carry_block[3]][AB_block[3][1]][i3_l][j3_l];
			gamma_Output[3] = ((gamma_block[3][1] << 8) | gamma_block[3][0]) & 0xFFFF;

			P_w[cur_round] = w7;  //i0_l + i0_r + i1_l + i1_r + i2_l + i2_r + i3_l + i3_r;

			//调用下一轮
			best = SPARX_128_round_r_diff(search_round, cur_round + 1,
					(u16)gamma_Output[0], (u16)X_tmp[1],
					(u16)gamma_Output[1], (u16)X_tmp[3],
					(u16)gamma_Output[2], (u16)X_tmp[5],
					(u16)gamma_Output[3], (u16)X_tmp[7]);

		}}}}}}}}}}}}}}}}

	return best;
}


u16 SPARX_128_round_N(u16 search_round,
		u16 x_in_0, u16 x_in_1,u16 x_in_2, u16 x_in_3,
		u16 x_in_4, u16 x_in_5,u16 x_in_6, u16 x_in_7)
{
	u16 best = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16 w_cmp = 0;
	u16 X_tmp[8] = {0};
	u16 xr0 =0,xr2=0,xr4 =0,xr6=0;
	u16 xor_Block[4] = {0};
	u16 wt_xor_Block[4] = {0};
	u16 wt_xor_Block_MSB[4] = {0};
	u16 AB_block[4][2] = {0};
	u16 alpha_block[4][2] = {0};
	u16 beta_block[4][2]  = {0};
	u16 gamma_block[4][2] = {0};
	u16 carry_tmp_block[4] = {0};
	u16 carry_block[4] = {0};
	u16 i0_l=0,i1_l=0,i2_l=0,i3_l=0;
	u16 i0_r=0,i1_r=0,i2_r=0,i3_r=0;
	u16 j0_l=0,j1_l=0,j2_l=0,j3_l=0;
	u16 j0_r=0,j1_r=0,j2_r=0,j3_r=0;
	u16 gamma_Output[4] = {0};
	u16 X0_tmp_last[8] = {0};
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;


	if(((search_round -1) % 4) == 0) //5,9,13,,,,
	{
		X_tmp[0] = x_in_0 & Bit_Align;
		X_tmp[1] = (x_in_0 ^ ROTATE_LEFT(x_in_1,2,blocksize_len)) & Bit_Align;
		X_tmp[2] = x_in_2 & Bit_Align;
		X_tmp[3] = (x_in_2 ^ ROTATE_LEFT(x_in_3,2,blocksize_len)) & Bit_Align;
		X_tmp[4] = x_in_4 & Bit_Align;
		X_tmp[5] = (x_in_4 ^ ROTATE_LEFT(x_in_5,2,blocksize_len)) & Bit_Align;
		X_tmp[6] = x_in_6 & Bit_Align;
		X_tmp[7] = (x_in_6 ^ ROTATE_LEFT(x_in_7,2,blocksize_len)) & Bit_Align;

		//L前后的需要输出  //用于输出经L变换前的前轮输出
		IN128_L_X[search_round/4][0] = X_tmp[0];
		IN128_L_X[search_round/4][1] = X_tmp[1];
		IN128_L_X[search_round/4][2] = X_tmp[2];
		IN128_L_X[search_round/4][3] = X_tmp[3];
		IN128_L_X[search_round/4][4] = X_tmp[4];
		IN128_L_X[search_round/4][5] = X_tmp[5];
		IN128_L_X[search_round/4][6] = X_tmp[6];
		IN128_L_X[search_round/4][7] = X_tmp[7];

		// L // switch function.
		L4_Switch_per4Round(&X_tmp[0],&X_tmp[1],&X_tmp[2],&X_tmp[3],
				&X_tmp[4],&X_tmp[5],&X_tmp[6],&X_tmp[7]);

		xr0 = X_tmp[0];
		xr2 = X_tmp[2];
		xr4 = X_tmp[4];
		xr6 = X_tmp[6];

		X_tmp[0] = (ROTATE_RIGHT(xr0,7,blocksize_len)) & Bit_Align;
		X_tmp[2] = (ROTATE_RIGHT(xr2,7,blocksize_len)) & Bit_Align;
		X_tmp[4] = (ROTATE_RIGHT(xr4,7,blocksize_len)) & Bit_Align;
		X_tmp[6] = (ROTATE_RIGHT(xr6,7,blocksize_len)) & Bit_Align;
		//printf("x0: %x x1: %x x2: %x x3: %x \n",*X0 ,*X1,*X2,*X3);
	}
	else
	{
		X_tmp[0] = (ROTATE_RIGHT(x_in_0,7,blocksize_len)) & Bit_Align;
		X_tmp[1] = (x_in_0 ^ ROTATE_LEFT(x_in_1,2,blocksize_len)) & Bit_Align;
		X_tmp[2] = (ROTATE_RIGHT(x_in_2,7,blocksize_len)) & Bit_Align;
		X_tmp[3] = (x_in_2 ^ ROTATE_LEFT(x_in_3,2,blocksize_len)) & Bit_Align;
		X_tmp[4] = (ROTATE_RIGHT(x_in_4,7,blocksize_len)) & Bit_Align;
		X_tmp[5] = (x_in_4 ^ ROTATE_LEFT(x_in_5,2,blocksize_len)) & Bit_Align;
		X_tmp[6] = (ROTATE_RIGHT(x_in_6, 7, blocksize_len)) & Bit_Align;
		X_tmp[7] = (x_in_6 ^ ROTATE_LEFT(x_in_7,2,blocksize_len)) & Bit_Align;
	}

	xor_Block[0] = (X_tmp[0] ^ X_tmp[1]) & ValueMax_Align;
	xor_Block[1] = (X_tmp[2] ^ X_tmp[3]) & ValueMax_Align;
	xor_Block[2] = (X_tmp[4] ^ X_tmp[5]) & ValueMax_Align;
	xor_Block[3] = (X_tmp[6] ^ X_tmp[7]) & ValueMax_Align;

	wt_xor_Block[0] = HM_weight(xor_Block[0]);
	wt_xor_Block[1] = HM_weight(xor_Block[1]);
	wt_xor_Block[2] = HM_weight(xor_Block[2]);
	wt_xor_Block[3] = HM_weight(xor_Block[3]);

	for(i=1; i < search_round; i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = Bn_w - p_sumof_r;
	if (wt_xor_Block[0] + wt_xor_Block[1] + wt_xor_Block[2] + wt_xor_Block[3] > w_cmp)
	{
		return 0;
	}
	if(p_sumof_r == 0)
	{
		return 0;
	}

	//Block 0 LSB
	alpha_block[0][0] = X_tmp[0] & 0xFF; //8 bit
	beta_block[0][0]  = X_tmp[1] & 0xFF; //8 bit
	AB_block[0][0] = (alpha_block[0][0] << 8) | beta_block[0][0];
	carry_tmp_block[0] = ((alpha_block[0][0] >> 7) << 2) + ((beta_block[0][0] >> 7) << 1);
	//carry_0_block[0] = 0;
	//Block 0 MSB
	alpha_block[0][1]= X_tmp[0] & 0xFF00; //8 bit
	beta_block[0][1] = (X_tmp[1] >> 8) & 0xFF; //8 bit
	AB_block[0][1] = alpha_block[0][1] | beta_block[0][1];
	wt_xor_Block_MSB[0] = cDDT_AB_wt_min[AB_block[0][1]];

	//Block 1 LSB
	alpha_block[1][0] = X_tmp[2] & 0xFF; //8 bit
	beta_block[1][0]  = X_tmp[3] & 0xFF; //8 bit
	AB_block[1][0] = (alpha_block[1][0] << 8) | beta_block[1][0];
	carry_tmp_block[1] = ((alpha_block[1][0] >> 7) << 2) + ((beta_block[1][0] >> 7) << 1);
	//carry_0_block[1] = 0;
	//Block 1 MSB
	alpha_block[1][1]= X_tmp[2] & 0xFF00; //8 bit
	beta_block[1][1] = (X_tmp[3] >> 8) & 0xFF; //8 bit
	AB_block[1][1] = alpha_block[1][1] | beta_block[1][1];
	wt_xor_Block_MSB[1] = cDDT_AB_wt_min[AB_block[1][1]];


	//Block 2 LSB
	alpha_block[2][0] = X_tmp[4] & 0xFF; //8 bit
	beta_block[2][0]  = X_tmp[5] & 0xFF; //8 bit
	AB_block[2][0] = (alpha_block[2][0] << 8) | beta_block[2][0];
	carry_tmp_block[2] = ((alpha_block[2][0] >> 7) << 2) + ((beta_block[2][0] >> 7) << 1);
	//carry_0_block[2] = 0;
	//Block 2 MSB
	alpha_block[2][1]= X_tmp[4] & 0xFF00; //8 bit
	beta_block[2][1] = (X_tmp[5] >> 8) & 0xFF; //8 bit
	AB_block[2][1] = alpha_block[2][1] | beta_block[2][1];
	wt_xor_Block_MSB[2] = cDDT_AB_wt_min[AB_block[2][1]];

	//Block 3 LSB
	alpha_block[3][0] = X_tmp[6] & 0xFF; //8 bit
	beta_block[3][0]  = X_tmp[7] & 0xFF; //8 bit
	AB_block[3][0] = (alpha_block[3][0] << 8) | beta_block[3][0];
	carry_tmp_block[3] = ((alpha_block[3][0] >> 7) << 2) + ((beta_block[3][0] >> 7) << 1);
	//carry_0_block[2] = 0;
	//Block 3 MSB
	alpha_block[3][1]= X_tmp[6] & 0xFF00; //8 bit
	beta_block[3][1] = (X_tmp[7] >> 8) & 0xFF; //8 bit
	AB_block[3][1] = alpha_block[3][1] | beta_block[3][1];
	wt_xor_Block_MSB[3] = cDDT_AB_wt_min[AB_block[3][1]];


	///////////开始组合可能的gamma
	//wt of BLock 0
	for(i0_r = cDDT_wt_min[0][AB_block[0][0]];
			i0_r <= cDDT_wt_min[0][AB_block[0][0]]; i0_r++)  //cDDT_wt_max[0][AB_block[0][0]]
	{
		if(i0_r + wt_xor_Block_MSB[0] +
				wt_xor_Block[1] + wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 0
		for(j0_r=0; j0_r < cDDT_n[0][AB_block[0][0]][i0_r]; j0_r++)
		{
			gamma_block[0][0] = cDDT_v[0][AB_block[0][0]][i0_r][j0_r];
			carry_block[0] = carry_tmp_block[0] + (gamma_block[0][0] >> 7);
	for(i0_l = MSB_cDDT_wt_min[carry_block[0]][AB_block[0][1]];
			i0_l <= MSB_cDDT_wt_min[carry_block[0]][AB_block[0][1]]; i0_l++)  //MSB_cDDT_wt_max[carry_block[0]][AB_block[0][1]]
	{
		w1 = i0_r + i0_l;
		if(w1 +	wt_xor_Block[1] + wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;} //break 要比 continue 高效,直接结束.
		for(j0_l=0; j0_l < MSB_cDDT_n[carry_block[0]][AB_block[0][1]][i0_l]; j0_l++)
		{
			gamma_block[0][1] = MSB_cDDT_v[carry_block[0]][AB_block[0][1]][i0_l][j0_l];
			gamma_Output[0] = ((gamma_block[0][1] << 8) | gamma_block[0][0]) & 0xFFFF;


	//wt of BLock 1
	for(i1_r = cDDT_wt_min[0][AB_block[1][0]];
			i1_r <= cDDT_wt_min[0][AB_block[1][0]]; i1_r++)  //cDDT_wt_max[0][AB_block[1][0]]
	{
		w2 = w1 + i1_r;
		if(w2 + wt_xor_Block_MSB[1] +
				wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 1
		for(j1_r=0; j1_r < cDDT_n[0][AB_block[1][0]][i1_r]; j1_r++)
		{
			gamma_block[1][0] = cDDT_v[0][AB_block[1][0]][i1_r][j1_r];
			carry_block[1] = carry_tmp_block[1] + (gamma_block[1][0] >> 7);
	for(i1_l = MSB_cDDT_wt_min[carry_block[1]][AB_block[1][1]];
			i1_l <= MSB_cDDT_wt_min[carry_block[1]][AB_block[1][1]]; i1_l++) //MSB_cDDT_wt_max[carry_block[1]][AB_block[1][1]]
	{
		w3 = w2 + i1_l;
		if(w3 +	wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1_l=0; j1_l < MSB_cDDT_n[carry_block[1]][AB_block[1][1]][i1_l]; j1_l++)
		{
			gamma_block[1][1] = MSB_cDDT_v[carry_block[1]][AB_block[1][1]][i1_l][j1_l];
			gamma_Output[1] = ((gamma_block[1][1] << 8) | gamma_block[1][0]) & 0xFFFF;


	//wt of BLock 2
	for(i2_r = cDDT_wt_min[0][AB_block[2][0]];
			i2_r <= cDDT_wt_min[0][AB_block[2][0]]; i2_r++) //cDDT_wt_max[0][AB_block[2][0]]
	{
		w4 = w3 + i2_r;
		if(w4 + wt_xor_Block_MSB[2] +
				wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 2
		for(j2_r=0; j2_r < cDDT_n[0][AB_block[2][0]][i2_r]; j2_r++)
		{
			gamma_block[2][0] = cDDT_v[0][AB_block[2][0]][i2_r][j2_r];
			carry_block[2] = carry_tmp_block[2] + (gamma_block[2][0] >> 7);
	for(i2_l = MSB_cDDT_wt_min[carry_block[2]][AB_block[2][1]];
			i2_l <= MSB_cDDT_wt_min[carry_block[2]][AB_block[2][1]]; i2_l++) //MSB_cDDT_wt_max[carry_block[2]][AB_block[2][1]]
	{
		w5 = w4 + i2_l;
		if(w5 +	wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2_l=0; j2_l < MSB_cDDT_n[carry_block[2]][AB_block[2][1]][i2_l]; j2_l++)
		{
			gamma_block[2][1] = MSB_cDDT_v[carry_block[2]][AB_block[2][1]][i2_l][j2_l];
			gamma_Output[2] = ((gamma_block[2][1] << 8) | gamma_block[2][0]) & 0xFFFF;


	//wt of BLock 3
	for(i3_r = cDDT_wt_min[0][AB_block[3][0]];
			i3_r <= cDDT_wt_min[0][AB_block[3][0]]; i3_r++)  //cDDT_wt_max[0][AB_block[3][0]]
	{
		w6 = w5 + i3_r;
		if(w6 + wt_xor_Block_MSB[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 3
		for(j3_r=0; j3_r < cDDT_n[0][AB_block[3][0]][i3_r]; j3_r++)
		{
			gamma_block[3][0] = cDDT_v[0][AB_block[3][0]][i3_r][j3_r];
			carry_block[3] = carry_tmp_block[3] + (gamma_block[3][0] >> 7);
	for(i3_l = MSB_cDDT_wt_min[carry_block[3]][AB_block[3][1]];
			i3_l <= MSB_cDDT_wt_min[carry_block[3]][AB_block[3][1]]; i3_l++) //MSB_cDDT_wt_max[carry_block[3]][AB_block[3][1]]
	{
		w7 = w6 + i3_l;
		if(w7 > w_cmp ){break;}  // 比较是否为最优的Bn_w的最优路径
		if(w7 == w_cmp )  // 比较是否为最优的Bn_w的最优路径
		{
		for(j3_l=0; j3_l < MSB_cDDT_n[carry_block[3]][AB_block[3][1]][i3_l]; j3_l++)
		{
			gamma_block[3][1] = MSB_cDDT_v[carry_block[3]][AB_block[3][1]][i3_l][j3_l];
			gamma_Output[3] = ((gamma_block[3][1] << 8) | gamma_block[3][0]) & 0xFFFF;

			P_w[search_round] = w7; //i0_l + i0_r + i1_l + i1_r + i2_l + i2_r + i3_l + i3_r;
			n_P_bestofR_w[search_round] = Bn_w;

			//返回
			best = 1;

#if 1   //是否找到第一条最优路径就返回？
//	if( best == 1 )
	{
		wt_block[0][search_round] = i0_l + i0_r;
		wt_block[1][search_round] = i1_l + i1_r;
		wt_block[2][search_round] = i2_l + i2_r;
		wt_block[3][search_round] = i3_l + i3_r;

		if(((search_round -1) % 4) == 0) //本轮输入为经过L变换后的输出，作为输入
		{
			X_128_r[0][search_round] = xr0;
			X_128_r[1][search_round] = X_tmp[1];
			X_128_r[2][search_round] = xr2;
			X_128_r[3][search_round] = X_tmp[3];
			X_128_r[4][search_round] = xr4;
			X_128_r[5][search_round] = X_tmp[5];
			X_128_r[6][search_round] = xr6;
			X_128_r[7][search_round] = X_tmp[7];
		}
		else   //本轮输入为前轮输出直接为输入
		{
			X_128_r[0][search_round] = x_in_0;
			X_128_r[1][search_round] = X_tmp[1];
			X_128_r[2][search_round] = x_in_2;
			X_128_r[3][search_round] = X_tmp[3];
			X_128_r[4][search_round] = x_in_4;
			X_128_r[5][search_round] = X_tmp[5];
			X_128_r[6][search_round] = x_in_6;
			X_128_r[7][search_round] = X_tmp[7];
		}

		if((search_round % 4) == 0) //需要经过L变换，最后输出为经过L变换的结果
		{
			X0_tmp_last[0] = gamma_Output[0];
			X0_tmp_last[1] = gamma_Output[0] ^ (ROTATE_LEFT(X_tmp[1], 2,blocksize_len) & Bit_Align);
			X0_tmp_last[2] = gamma_Output[1];
			X0_tmp_last[3] = gamma_Output[1] ^ (ROTATE_LEFT(X_tmp[3], 2,blocksize_len) & Bit_Align);
			X0_tmp_last[4] = gamma_Output[2];
			X0_tmp_last[5] = gamma_Output[2] ^ (ROTATE_LEFT(X_tmp[5], 2,blocksize_len) & Bit_Align);
			X0_tmp_last[6] = gamma_Output[3];
			X0_tmp_last[7] = gamma_Output[3] ^ (ROTATE_LEFT(X_tmp[7], 2,blocksize_len) & Bit_Align);

			//L前后的需要输出  //用于输出经L变换前的前轮输出
			IN128_L_X[search_round/4][0] = X0_tmp_last[0];
			IN128_L_X[search_round/4][1] = X0_tmp_last[1];
			IN128_L_X[search_round/4][2] = X0_tmp_last[2];
			IN128_L_X[search_round/4][3] = X0_tmp_last[3];
			IN128_L_X[search_round/4][4] = X0_tmp_last[4];
			IN128_L_X[search_round/4][5] = X0_tmp_last[5];
			IN128_L_X[search_round/4][6] = X0_tmp_last[6];
			IN128_L_X[search_round/4][7] = X0_tmp_last[7];

			// L // switch function.
			L4_Switch_per4Round(&X0_tmp_last[0],&X0_tmp_last[1],&X0_tmp_last[2],&X0_tmp_last[3],
					&X0_tmp_last[4],&X0_tmp_last[5],&X0_tmp_last[6],&X0_tmp_last[7]);

			X_128_r[0][search_round +1] = X0_tmp_last[0];
			X_128_r[1][search_round +1] = X0_tmp_last[1];
			X_128_r[2][search_round +1] = X0_tmp_last[2];
			X_128_r[3][search_round +1] = X0_tmp_last[3];
			X_128_r[4][search_round +1] = X0_tmp_last[4];
			X_128_r[5][search_round +1] = X0_tmp_last[5];
			X_128_r[6][search_round +1] = X0_tmp_last[6];
			X_128_r[7][search_round +1] = X0_tmp_last[7];
		}
		else
		{
			X_128_r[0][search_round +1]= gamma_Output[0];
			X_128_r[1][search_round +1]= gamma_Output[0] ^ (ROTATE_LEFT(X_tmp[1], 2,blocksize_len) & Bit_Align);
			X_128_r[2][search_round +1]= gamma_Output[1];
			X_128_r[3][search_round +1]= gamma_Output[1] ^ (ROTATE_LEFT(X_tmp[3], 2,blocksize_len) & Bit_Align);
			X_128_r[4][search_round +1]= gamma_Output[2];
			X_128_r[5][search_round +1]= gamma_Output[2] ^ (ROTATE_LEFT(X_tmp[5], 2,blocksize_len) & Bit_Align);
			X_128_r[6][search_round +1]= gamma_Output[3];
			X_128_r[7][search_round +1]= gamma_Output[3] ^ (ROTATE_LEFT(X_tmp[7], 2,blocksize_len) & Bit_Align);
		}

		return 1;
	}
#endif
		}}}}}}}}}}}}}}}}}
	return best;
}


u16 SPARX_128_round_N_diff(u16 search_round,
		u16 x_in_0, u16 x_in_1,u16 x_in_2, u16 x_in_3,
		u16 x_in_4, u16 x_in_5,u16 x_in_6, u16 x_in_7)
{
	u16 best = 0;
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16 w_cmp = 0;
	u16 X_tmp[8] = {0};
	u16 xr0 =0,xr2=0,xr4 =0,xr6=0;
	u16 xor_Block[4] = {0};
	u16 wt_xor_Block[4] = {0};
	u16 wt_xor_Block_MSB[4] = {0};
	u16 AB_block[4][2] = {0};
	u16 alpha_block[4][2] = {0};
	u16 beta_block[4][2]  = {0};
	u16 gamma_block[4][2] = {0};
	u16 carry_tmp_block[4] = {0};
	u16 carry_block[4] = {0};
	u16 i0_l=0,i1_l=0,i2_l=0,i3_l=0;
	u16 i0_r=0,i1_r=0,i2_r=0,i3_r=0;
	u16 j0_l=0,j1_l=0,j2_l=0,j3_l=0;
	u16 j0_r=0,j1_r=0,j2_r=0,j3_r=0;
	u16 gamma_Output[4] = {0};
	u16 X0_tmp_last[8] = {0};
	u16 yr1=0,yr3=0,yr5=0,yr7=0;
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;

	if(((search_round -1) % 4) == 0) //5,9,13,,,,
	{
		X_tmp[0] = x_in_0 & Bit_Align;
		X_tmp[1] = (x_in_0 ^ ROTATE_LEFT(x_in_1,2,blocksize_len)) & Bit_Align;
		X_tmp[2] = x_in_2 & Bit_Align;
		X_tmp[3] = (x_in_2 ^ ROTATE_LEFT(x_in_3,2,blocksize_len)) & Bit_Align;
		X_tmp[4] = x_in_4 & Bit_Align;
		X_tmp[5] = (x_in_4 ^ ROTATE_LEFT(x_in_5,2,blocksize_len)) & Bit_Align;
		X_tmp[6] = x_in_6 & Bit_Align;
		X_tmp[7] = (x_in_6 ^ ROTATE_LEFT(x_in_7,2,blocksize_len)) & Bit_Align;

		//L前后的需要输出  //用于输出经L变换前的前轮输出
		IN128_L_X[search_round/4][0] = X_tmp[0];
		IN128_L_X[search_round/4][1] = X_tmp[1];
		IN128_L_X[search_round/4][2] = X_tmp[2];
		IN128_L_X[search_round/4][3] = X_tmp[3];
		IN128_L_X[search_round/4][4] = X_tmp[4];
		IN128_L_X[search_round/4][5] = X_tmp[5];
		IN128_L_X[search_round/4][6] = X_tmp[6];
		IN128_L_X[search_round/4][7] = X_tmp[7];

		// L // switch function.
		L4_Switch_per4Round(&X_tmp[0],&X_tmp[1],&X_tmp[2],&X_tmp[3],
				&X_tmp[4],&X_tmp[5],&X_tmp[6],&X_tmp[7]);

		xr0 = X_tmp[0];
		xr2 = X_tmp[2];
		xr4 = X_tmp[4];
		xr6 = X_tmp[6];

		X_tmp[0] = (ROTATE_RIGHT(xr0,7,blocksize_len)) & Bit_Align;
		X_tmp[2] = (ROTATE_RIGHT(xr2,7,blocksize_len)) & Bit_Align;
		X_tmp[4] = (ROTATE_RIGHT(xr4,7,blocksize_len)) & Bit_Align;
		X_tmp[6] = (ROTATE_RIGHT(xr6,7,blocksize_len)) & Bit_Align;
		//printf("x0: %x x1: %x x2: %x x3: %x \n",*X0 ,*X1,*X2,*X3);
	}
	else
	{
		X_tmp[0] = (ROTATE_RIGHT(x_in_0,7,blocksize_len)) & Bit_Align;
		X_tmp[1] = (x_in_0 ^ ROTATE_LEFT(x_in_1,2,blocksize_len)) & Bit_Align;
		X_tmp[2] = (ROTATE_RIGHT(x_in_2,7,blocksize_len)) & Bit_Align;
		X_tmp[3] = (x_in_2 ^ ROTATE_LEFT(x_in_3,2,blocksize_len)) & Bit_Align;
		X_tmp[4] = (ROTATE_RIGHT(x_in_4,7,blocksize_len)) & Bit_Align;
		X_tmp[5] = (x_in_4 ^ ROTATE_LEFT(x_in_5,2,blocksize_len)) & Bit_Align;
		X_tmp[6] = (ROTATE_RIGHT(x_in_6, 7, blocksize_len)) & Bit_Align;
		X_tmp[7] = (x_in_6 ^ ROTATE_LEFT(x_in_7,2,blocksize_len)) & Bit_Align;
	}

	xor_Block[0] = (X_tmp[0] ^ X_tmp[1]) & ValueMax_Align;
	xor_Block[1] = (X_tmp[2] ^ X_tmp[3]) & ValueMax_Align;
	xor_Block[2] = (X_tmp[4] ^ X_tmp[5]) & ValueMax_Align;
	xor_Block[3] = (X_tmp[6] ^ X_tmp[7]) & ValueMax_Align;

	wt_xor_Block[0] = HM_weight(xor_Block[0]);
	wt_xor_Block[1] = HM_weight(xor_Block[1]);
	wt_xor_Block[2] = HM_weight(xor_Block[2]);
	wt_xor_Block[3] = HM_weight(xor_Block[3]);

	for(i=1; i < search_round; i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r;
	if (wt_xor_Block[0] + wt_xor_Block[1] + wt_xor_Block[2] + wt_xor_Block[3] > w_cmp)
	{
		return 0;
	}
	if(p_sumof_r == 0)
	{
		return 0;
	}

	//Block 0 LSB
	alpha_block[0][0] = X_tmp[0] & 0xFF; //8 bit
	beta_block[0][0]  = X_tmp[1] & 0xFF; //8 bit
	AB_block[0][0] = (alpha_block[0][0] << 8) | beta_block[0][0];
	carry_tmp_block[0] = ((alpha_block[0][0] >> 7) << 2) + ((beta_block[0][0] >> 7) << 1);
	//carry_0_block[0] = 0;
	//Block 0 MSB
	alpha_block[0][1]= X_tmp[0] & 0xFF00; //8 bit
	beta_block[0][1] = (X_tmp[1] >> 8) & 0xFF; //8 bit
	AB_block[0][1] = alpha_block[0][1] | beta_block[0][1];
	wt_xor_Block_MSB[0] = cDDT_AB_wt_min[AB_block[0][1]];

	//Block 1 LSB
	alpha_block[1][0] = X_tmp[2] & 0xFF; //8 bit
	beta_block[1][0]  = X_tmp[3] & 0xFF; //8 bit
	AB_block[1][0] = (alpha_block[1][0] << 8) | beta_block[1][0];
	carry_tmp_block[1] = ((alpha_block[1][0] >> 7) << 2) + ((beta_block[1][0] >> 7) << 1);
	//carry_0_block[1] = 0;
	//Block 1 MSB
	alpha_block[1][1]= X_tmp[2] & 0xFF00; //8 bit
	beta_block[1][1] = (X_tmp[3] >> 8) & 0xFF; //8 bit
	AB_block[1][1] = alpha_block[1][1] | beta_block[1][1];
	wt_xor_Block_MSB[1] = cDDT_AB_wt_min[AB_block[1][1]];


	//Block 2 LSB
	alpha_block[2][0] = X_tmp[4] & 0xFF; //8 bit
	beta_block[2][0]  = X_tmp[5] & 0xFF; //8 bit
	AB_block[2][0] = (alpha_block[2][0] << 8) | beta_block[2][0];
	carry_tmp_block[2] = ((alpha_block[2][0] >> 7) << 2) + ((beta_block[2][0] >> 7) << 1);
	//carry_0_block[2] = 0;
	//Block 2 MSB
	alpha_block[2][1]= X_tmp[4] & 0xFF00; //8 bit
	beta_block[2][1] = (X_tmp[5] >> 8) & 0xFF; //8 bit
	AB_block[2][1] = alpha_block[2][1] | beta_block[2][1];
	wt_xor_Block_MSB[2] = cDDT_AB_wt_min[AB_block[2][1]];

	//Block 3 LSB
	alpha_block[3][0] = X_tmp[6] & 0xFF; //8 bit
	beta_block[3][0]  = X_tmp[7] & 0xFF; //8 bit
	AB_block[3][0] = (alpha_block[3][0] << 8) | beta_block[3][0];
	carry_tmp_block[3] = ((alpha_block[3][0] >> 7) << 2) + ((beta_block[3][0] >> 7) << 1);
	//carry_0_block[2] = 0;
	//Block 3 MSB
	alpha_block[3][1]= X_tmp[6] & 0xFF00; //8 bit
	beta_block[3][1] = (X_tmp[7] >> 8) & 0xFF; //8 bit
	AB_block[3][1] = alpha_block[3][1] | beta_block[3][1];
	wt_xor_Block_MSB[3] = cDDT_AB_wt_min[AB_block[3][1]];


	///////////开始组合可能的gamma
	//wt of BLock 0
	for(i0_r = cDDT_wt_min[0][AB_block[0][0]]; i0_r <= cDDT_wt_max[0][AB_block[0][0]]; i0_r++)
	{
//		if(i0_r + wt_xor_Block_MSB[0] +
//				wt_xor_Block[1] + wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;} //break 要比 continue 高效,直接结束.
		//gamma of BLock 0
		for(j0_r=0; j0_r < cDDT_n[0][AB_block[0][0]][i0_r]; j0_r++)
		{
			gamma_block[0][0] = cDDT_v[0][AB_block[0][0]][i0_r][j0_r];
			carry_block[0] = carry_tmp_block[0] + (gamma_block[0][0] >> 7);
	for(i0_l = MSB_cDDT_wt_min[carry_block[0]][AB_block[0][1]]; i0_l <= MSB_cDDT_wt_max[carry_block[0]][AB_block[0][1]]; i0_l++)
	{
		w1 = i0_r + i0_l;
//		if(w1 +	wt_xor_Block[1] + wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j0_l=0; j0_l < MSB_cDDT_n[carry_block[0]][AB_block[0][1]][i0_l]; j0_l++)
		{
			gamma_block[0][1] = MSB_cDDT_v[carry_block[0]][AB_block[0][1]][i0_l][j0_l];
			gamma_Output[0] = ((gamma_block[0][1] << 8) | gamma_block[0][0]) & 0xFFFF;

			if((search_round % 4) != 0) //
			{
				if(Y_out_0 != gamma_Output[0]) // 判断y0输出是否相等
				{
					continue;
				}
				yr1 = (gamma_Output[0] ^ (ROTATE_LEFT(X_tmp[1], 2,blocksize_len))) & Bit_Align;
				if(Y_out_1 != yr1) // 判断y1输出是否相等
				{
					continue;
				}
			}
			else //最后一轮需要经过L变换
			{
				if(Y_out_4!= gamma_Output[0] ) // 判断y4输出是否相等
				{
					continue;
				}
				yr5 = (gamma_Output[0] ^ (ROTATE_LEFT(X_tmp[1], 2,blocksize_len))) & Bit_Align;
				if(Y_out_5 != yr5) // 判断y5输出是否相等
				{
					continue;
				}
			}


	//wt of BLock 1
	for(i1_r = cDDT_wt_min[0][AB_block[1][0]]; i1_r <= cDDT_wt_max[0][AB_block[1][0]]; i1_r++)
	{
		w2 = w1 + i1_r;
//		if(w2 + wt_xor_Block_MSB[1] +
//				wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		//gamma of BLock 1
		for(j1_r=0; j1_r < cDDT_n[0][AB_block[1][0]][i1_r]; j1_r++)
		{
			gamma_block[1][0] = cDDT_v[0][AB_block[1][0]][i1_r][j1_r];
			carry_block[1] = carry_tmp_block[1] + (gamma_block[1][0] >> 7);
	for(i1_l = MSB_cDDT_wt_min[carry_block[1]][AB_block[1][1]]; i1_l <= MSB_cDDT_wt_max[carry_block[1]][AB_block[1][1]]; i1_l++)
	{
		w3 = w2 + i1_l;
//		if(w3 +	wt_xor_Block[2] +wt_xor_Block[3] > w_cmp ){break;} //break 要比 continue 高效,直接结束.
		for(j1_l=0; j1_l < MSB_cDDT_n[carry_block[1]][AB_block[1][1]][i1_l]; j1_l++)
		{
			gamma_block[1][1] = MSB_cDDT_v[carry_block[1]][AB_block[1][1]][i1_l][j1_l];
			gamma_Output[1] = ((gamma_block[1][1] << 8) | gamma_block[1][0]) & 0xFFFF;

			if((search_round % 4) != 0) //
			{
				if(Y_out_2 != gamma_Output[1] ) // 判断y0输出是否相等
				{
					continue;
				}
				yr3 = (gamma_Output[1] ^ (ROTATE_LEFT(X_tmp[3], 2,blocksize_len))) & Bit_Align;
				if(Y_out_3 != yr3) // 判断y1输出是否相等
				{
					continue;
				}
			}
			else //最后一轮需要经过L变换
			{
				if(Y_out_6!= gamma_Output[1] ) // 判断y4输出是否相等
				{
					continue;
				}
				yr7 = (gamma_Output[1] ^ (ROTATE_LEFT(X_tmp[3], 2,blocksize_len))) & Bit_Align;
				if(Y_out_7 != yr7) // 判断y5输出是否相等
				{
					continue;
				}
			}


	//wt of BLock 2
	for(i2_r = cDDT_wt_min[0][AB_block[2][0]]; i2_r <= cDDT_wt_max[0][AB_block[2][0]]; i2_r++)
	{
		w4 = w3 + i2_r;
//		if(w4 + wt_xor_Block_MSB[2] + wt_xor_Block[3] > w_cmp ){break;}
		//gamma of BLock 2
		for(j2_r=0; j2_r < cDDT_n[0][AB_block[2][0]][i2_r]; j2_r++)
		{
			gamma_block[2][0] = cDDT_v[0][AB_block[2][0]][i2_r][j2_r];
			carry_block[2] = carry_tmp_block[2] + (gamma_block[2][0] >> 7);
	for(i2_l = MSB_cDDT_wt_min[carry_block[2]][AB_block[2][1]]; i2_l <= MSB_cDDT_wt_max[carry_block[2]][AB_block[2][1]]; i2_l++)
	{
		w5 = w4 + i2_l;
//		if(w5 +	wt_xor_Block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2_l=0; j2_l < MSB_cDDT_n[carry_block[2]][AB_block[2][1]][i2_l]; j2_l++)
		{
			gamma_block[2][1] = MSB_cDDT_v[carry_block[2]][AB_block[2][1]][i2_l][j2_l];
			gamma_Output[2] = ((gamma_block[2][1] << 8) | gamma_block[2][0]) & 0xFFFF;

			if((search_round % 4) != 0) //
			{
				if(Y_out_4 != gamma_Output[2] ) // 判断y2输出是否相等
				{
					continue;
				}
				yr5 = (gamma_Output[2] ^ (ROTATE_LEFT(X_tmp[5], 2,blocksize_len))) & Bit_Align;
				if(Y_out_5 != yr5) // 判断y3输出是否相等
				{
					continue;
				}
			}


	//wt of BLock 3
	for(i3_r = cDDT_wt_min[0][AB_block[3][0]]; i3_r <= cDDT_wt_max[0][AB_block[3][0]]; i3_r++)
	{
		w6 = w5 + i3_r;
//		if(w6 + wt_xor_Block_MSB[3] > w_cmp ){break;}//break 要比 continue 高效,直接结束.
		//gamma of BLock 3
		for(j3_r=0; j3_r < cDDT_n[0][AB_block[3][0]][i3_r]; j3_r++)
		{
			gamma_block[3][0] = cDDT_v[0][AB_block[3][0]][i3_r][j3_r];
			carry_block[3] = carry_tmp_block[3] + (gamma_block[3][0] >> 7);
	for(i3_l = MSB_cDDT_wt_min[carry_block[3]][AB_block[3][1]]; i3_l <= MSB_cDDT_wt_max[carry_block[3]][AB_block[3][1]]; i3_l++)
	{
		// 比较是否为最优的Bn_w的最优路径
		w7 = w6 + i3_l;
//		if(w7 == w_cmp ){break;}  // 比较是否为最优的Bn_w的最优路径
//		if(i0_l + i0_r + i1_l + i1_r + i2_l + i2_r + i3_l + i3_r == w_cmp )
		{
		for(j3_l=0; j3_l < MSB_cDDT_n[carry_block[3]][AB_block[3][1]][i3_l]; j3_l++)
		{
			gamma_block[3][1] = MSB_cDDT_v[carry_block[3]][AB_block[3][1]][i3_l][j3_l];
			gamma_Output[3] = ((gamma_block[3][1] << 8) | gamma_block[3][0]) & 0xFFFF;

			P_w[search_round] = w7; //i0_l + i0_r + i1_l + i1_r + i2_l + i2_r + i3_l + i3_r;

			if((search_round % 4) != 0) //
			{
				if(Y_out_6 != gamma_Output[3] ) // 判断y2输出是否相等
				{
					continue;
				}
				yr7 = (gamma_Output[3] ^ (ROTATE_LEFT(X_tmp[7], 2,blocksize_len))) & Bit_Align;
				if(Y_out_7 != yr7) // 判断y3输出是否相等
				{
					continue;
				}

				//记录并输出
				count++;
				Bn_w = p_sumof_r + P_w[search_round] ;
				printf("count: %d    weight: %d \n",count,Bn_w);
				wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
			}
			else //最后一轮需要经过L变换
			{
				X0_tmp_last[0] = gamma_Output[0];
				X0_tmp_last[1] = gamma_Output[0] ^ (ROTATE_LEFT(X_tmp[1], 2,blocksize_len) & Bit_Align);
				X0_tmp_last[2] = gamma_Output[1];
				X0_tmp_last[3] = gamma_Output[1] ^ (ROTATE_LEFT(X_tmp[3], 2,blocksize_len) & Bit_Align);
				X0_tmp_last[4] = gamma_Output[2];
				X0_tmp_last[5] = gamma_Output[2] ^ (ROTATE_LEFT(X_tmp[5], 2,blocksize_len) & Bit_Align);
				X0_tmp_last[6] = gamma_Output[3];
				X0_tmp_last[7] = gamma_Output[3] ^ (ROTATE_LEFT(X_tmp[7], 2,blocksize_len) & Bit_Align);

				//L前后的需要输出  //用于输出经L变换前的前轮输出
				IN128_L_X[search_round/4][0] = X0_tmp_last[0];
				IN128_L_X[search_round/4][1] = X0_tmp_last[1];
				IN128_L_X[search_round/4][2] = X0_tmp_last[2];
				IN128_L_X[search_round/4][3] = X0_tmp_last[3];
				IN128_L_X[search_round/4][4] = X0_tmp_last[4];
				IN128_L_X[search_round/4][5] = X0_tmp_last[5];
				IN128_L_X[search_round/4][6] = X0_tmp_last[6];
				IN128_L_X[search_round/4][7] = X0_tmp_last[7];

				// L // switch function.
				L4_Switch_per4Round(&X0_tmp_last[0],&X0_tmp_last[1],&X0_tmp_last[2],&X0_tmp_last[3],
						&X0_tmp_last[4],&X0_tmp_last[5],&X0_tmp_last[6],&X0_tmp_last[7]);

				X_128_r[0][search_round +1] = X0_tmp_last[0];
				X_128_r[1][search_round +1] = X0_tmp_last[1];
				X_128_r[2][search_round +1] = X0_tmp_last[2];
				X_128_r[3][search_round +1] = X0_tmp_last[3];
				X_128_r[4][search_round +1] = X0_tmp_last[4];
				X_128_r[5][search_round +1] = X0_tmp_last[5];
				X_128_r[6][search_round +1] = X0_tmp_last[6];
				X_128_r[7][search_round +1] = X0_tmp_last[7];

				if((Y_out_0 != X_128_r[0][search_round +1]) ) // 判断y0输出是否相等
				{
					continue;
				}
				if(Y_out_1 != X_128_r[1][search_round +1] ) // 判断y1输出是否相等
				{
					continue;
				}
				if((Y_out_2 != X_128_r[2][search_round +1] ) ) // 判断y2输出是否相等
				{
					continue;
				}
				if(Y_out_3 != X_128_r[3][search_round +1] ) // 判断y3输出是否相等
				{
					continue;
				}
				if((Y_out_4 != X_128_r[4][search_round +1]) ) // 判断y0输出是否相等
				{
					continue;
				}
				if(Y_out_5 != X_128_r[5][search_round +1] ) // 判断y1输出是否相等
				{
					continue;
				}
				if((Y_out_6 != X_128_r[6][search_round +1] ) ) // 判断y2输出是否相等
				{
					continue;
				}
				if(Y_out_7 != X_128_r[7][search_round +1] ) // 判断y3输出是否相等
				{
					continue;
				}

				count++;
				Bn_w = p_sumof_r + P_w[search_round] ;
				printf("count: %d    weight: %d \n",count,Bn_w);
				wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;
			}

		}}}}}}}}}}}}}}}}}

	return best;
}


u16 SPARX64_linear_trail_search_entry (u16 search_round)
{
	u16 best = 0;
	u16 i = 0;
	FILE* SPARX_linear_best_Bn;


	SPARX_linear_best_Bn = fopen ("../tmp/sparx64_linear_Bn_wt.xlsx", "a+"); //  "w+"); //
	if((sc_blocksize != 64) && (sc_blocksize != 128))
	{
		printf("The block size of SPARX should be 64 or 128 bits. \n");
		return 0;
	}


	// For SPARX64 and SPARX128 both the S-BOX is 16bits.
	blocksize_len = 16;
	Bit_Align = 0xFFFF;
	ValueMax_Align = 0x7FFF;
	V_MSB = 0x8000;


	printf("Constructing SPARX64 cLAT Tables... \n");
	//构造部分的线性相关性近似表cLAT
	ARX_cLAT_construct();
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct SPARX64 cLAT: %.2f seconds.  \n", run_time);


	Bn_w = 0;
	if(search_round > 3)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(SPARX_linear_best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		Bn_w = n_P_bestofR_w[search_round -1] - 1;
	}

		Bn_w = 23;  //直接设定开始的概率重量,快速达到期望的概率重量
		do
		{
			Bn_w = Bn_w + 1;
			printf("Searching SPARX64 Bn_w: %d \n", Bn_w);

			// Search Entry.
			SPARX64_linear_round_1_Left(search_round);

/*
			//给第3轮的输入掩码
			u16 mask_3_Xr[4] ={0};
			mask_3_Xr[0] = 0x0205;
			mask_3_Xr[1] = 0x0204;
			mask_3_Xr[2] = 0x0205;
			mask_3_Xr[3] = 0x0204;
			P_w[1] = 0;  //
			P_w[2] = 0;
			//直接跳转到第R轮
		//		best = SPARX64_linear_round_r(2,1,  //search_round
		//				mask_3_Xr[0],mask_3_Xr[1],mask_3_Xr[2], mask_3_Xr[3]);
			//直接跳转到第Last轮
			//	best = SPARX64_linear_round_N(3,  //search_round
			//			mask_3_Xr[0],mask_3_Xr[1],mask_3_Xr[2], mask_3_Xr[3]);
*/


			time_Round = clock();
			run_time =  (time_Round - time_ARX_cLAT) / CLOCKS_PER_SEC;
			printf("Time: %.2f seconds.  \n", run_time);
		}while(Bn_w !=  n_P_bestofR_w[search_round]);   //end conditions.


		print_SPARX64_resoult(search_round);

		time_finish = clock();
		run_time = (double)(time_finish - time_ARX_cLAT) / CLOCKS_PER_SEC;
		printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours == %.2f days. \n", run_time,run_time/60.0,run_time/3600.0,run_time/86400.0 );
		printf("Auto-search END! \n");
		printf("|************************************************************************|\n");
		fclose(SPARX_linear_best_Bn);

	return best;
}

u16 SPARX64_linear_round_1_Left(u16 search_round)
{
	u16 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 wt_round_1_left = 0;
//	u16 wt_round_1_right = 0;

	u64 M0 = 0;
	u64 N0 = blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;

	//printf(" L1 \n");

	///////////////////round 1 entry/////////////////////
	if( search_round == 1)
	{
		return best;
	}

	for(wt_round_1_left = 0; wt_round_1_left < 2;wt_round_1_left++)  //0::n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if( (wt_round_1_left + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}

		M0 = wt_round_1_left;  //
		//P_w[1] = M0; //相关性重量的记录数组

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;
			//直接跳转到第1轮右侧部分
			best = SPARX64_linear_round_1_Right(search_round,wt_round_1_left,
					Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;
			//直接跳转到第2轮
			best = SPARX64_linear_round_1_Right(search_round,wt_round_1_left,
					Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			best = SPARX64_R1_mask_Last_left(search_round,wt_round_1_left,C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHANGE_SL1;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHANGE_SL1;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHANGE_SL1;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHANGE_SL1;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHANGE_SL1;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHANGE_SL1;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHANGE_SL1;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
			CHANGE_SL1:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}

///////////////输出其它的分布模式/////////////////
			best = SPARX64_R1_mask_Last_left(search_round,wt_round_1_left,C0);

#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}
	return best;
}


u16 SPARX64_R1_mask_Last_left
(u16 search_round,u16 Corr_1, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

		//跳转到高比特分析
		best = SPARX64_R1_mask_Middle_left(search_round,
				Input_u, Input_v, Input_w,
				Corr_1, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = SPARX64_R1_mask_Middle_left(search_round,
				Input_u, Input_v, Input_w,
				Corr_1, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = SPARX64_R1_mask_Middle_left(search_round,
					Input_u, Input_v, Input_w,
					Corr_1, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}

u16 SPARX64_R1_mask_Middle_left(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= Corr_1 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = SPARX64_R1_mask_MSB_left(search_round,
				tmp_U,tmp_V,tmp_W,
				Corr_1, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

				if(current_index < blocksize_len -2)
				{
				//跳转到高比特分析
				best = SPARX64_R1_mask_Middle_left(search_round,
						tmp_U, tmp_V, tmp_W,
						Corr_1, Corr_tmp_inc, posi,
						current_index + 1, Fwt);
				}
				else
				{
					best = SPARX64_R1_mask_MSB_left(search_round,
							tmp_U,tmp_V,tmp_W,
							Corr_1, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}



#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//跳转到高比特分析
				best = SPARX64_R1_mask_Middle_left(search_round,
						Input_u, Input_v, Input_w,
						Corr_1, Corr_tmp_inc, posi,
						current_index +1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = SPARX64_R1_mask_Middle_left(search_round,
							Input_u, Input_v, Input_w,
							Corr_1, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = SPARX64_R1_mask_Middle_left(search_round,
							Input_u, Input_v, Input_w,
							Corr_1, Corr_tmp_inc +1, posi,
							current_index +1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 SPARX64_R1_mask_MSB_left(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;

//	if(Corr_1 == Corr_tmp_inc)
//	{
//		printf("OK \n");
//	}


	//printf("OK \n");
	if(Corr_tmp_inc > Corr_1)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
	{
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			//跳转 第1轮的右侧
			best = SPARX64_linear_round_1_Right(search_round,
					Corr_1,tmp_U,tmp_V,tmp_W);
		}
		else
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//跳转 第1轮的右侧
			best = SPARX64_linear_round_1_Right(search_round,
					Corr_1,Input_u,Input_v,Input_w);
		}
	}
	else
	if( (posi[Corr_1]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
	{
		//Fwt = 0;//当前M向量该比特位无相关性重量
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
			//Input_u = tmp_U | (0 << current_index); //该位置置0
			//Input_v = tmp_V | (0 << current_index); //该位置置0
			//Input_w = tmp_W | (0 << current_index); //该位置置0

			if(current_index <= blocksize_len-2)
			{
				//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
				best = SPARX64_R1_mask_MSB_left(search_round,
						tmp_U,tmp_V,tmp_W,
						Corr_1, Corr_tmp_inc,posi,
						current_index + 1,Fwt);
			}
			else //直接跳转到第1轮的右侧
			{
				//跳转 第1轮的右侧
				best = SPARX64_linear_round_1_Right(search_round,
						Corr_1,tmp_U,tmp_V,tmp_W);
			}
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
			best = SPARX64_R1_mask_MSB_left(search_round,
					Input_u, Input_v, Input_w,
					Corr_1, Corr_tmp_inc,posi,
					current_index + 1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
	}
	else //////当前M向量该比特位you相关性重量, M_i = 1; (posi[Corr_1]-1) == current_index .
	{
		//Fwt = 1;//当前M向量该比特位you相关性重量
		//Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

		if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_B_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_B_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_B_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				//跳转 第1轮的右侧
				best = SPARX64_linear_round_1_Right(search_round,
						Corr_1,Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
			}
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_A_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_A_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_A_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				//跳转 第1轮的右侧
				best = SPARX64_linear_round_1_Right(search_round,
						Corr_1,Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return best;
}
#endif
			}
		}
	}

	return best;
}

u16 SPARX64_linear_round_1_Right(u16 search_round, u16 w1_left,
		u64 tmp_U_left,u64 tmp_V_left,u64 tmp_W_left)
{
	u16 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

//	u16 wt_round_1_left = 0;
	u16 wt_round_1_right = 0;

	u64 M0 = 0;
	u64 N0 = blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;

//	printf(" R1 \n");

	///////////////////round 1 entry/////////////////////
	if( search_round == 1)
	{
		return best;
	}

	for(wt_round_1_right = 0; wt_round_1_right < 2;wt_round_1_right++)  //0::n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if( (w1_left + wt_round_1_right +
				n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}

		M0 = wt_round_1_right;  //
		P_w[1] = w1_left + M0; //相关性重量的记录数组
		wt_l[1] = w1_left;
		wt_r[1] = wt_round_1_right;

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			//直接跳转到第2轮左侧部分
			best = SPARX64_linear_round_2_Left(search_round,
					tmp_U_left, tmp_V_left, tmp_W_left,
					Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;
			//直接跳转到第2轮左侧部分
			best = SPARX64_linear_round_2_Left(search_round,
					tmp_U_left, tmp_V_left, tmp_W_left,
					Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			//直接跳转
			best = SPARX64_R1_mask_Last_Right(search_round,
					tmp_U_left,tmp_V_left,tmp_W_left,
					wt_round_1_right,C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHANGE_SL2;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHANGE_SL2;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHANGE_SL2;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHANGE_SL2;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHANGE_SL2;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHANGE_SL2;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHANGE_SL2;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
		CHANGE_SL2:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}

///////////////输出其它的分布模式/////////////////
				//直接跳转到第2轮左侧部分
				best = SPARX64_R1_mask_Last_Right(search_round,
						tmp_U_left,tmp_V_left,tmp_W_left,
						wt_round_1_right,C0);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}
	return best;
}

u16 SPARX64_R1_mask_Last_Right(u16 search_round,
		u64 tmp_U_left,u64 tmp_V_left,u64 tmp_W_left,
		u16 Corr_1, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

		//跳转到高比特分析
		best = SPARX64_R1_mask_Middle_Right(search_round,
				tmp_U_left, tmp_V_left, tmp_W_left,
				Input_u, Input_v, Input_w,
				Corr_1, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = SPARX64_R1_mask_Middle_Right(search_round,
				tmp_U_left, tmp_V_left, tmp_W_left,
				Input_u, Input_v, Input_w,
				Corr_1, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = SPARX64_R1_mask_Middle_Right(search_round,
					tmp_U_left, tmp_V_left, tmp_W_left,
					Input_u, Input_v, Input_w,
					Corr_1, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}

	return best;
}

u16 SPARX64_R1_mask_Middle_Right(u16 search_round,
		u64 tmp_U_left,u64 tmp_V_left,u64 tmp_W_left,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= Corr_1 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = SPARX64_R1_mask_MSB_Right(search_round,
				tmp_U_left, tmp_V_left, tmp_W_left,
				tmp_U,tmp_V,tmp_W,
				Corr_1, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

				if(current_index < blocksize_len -2)
				{
				//跳转到高比特分析
				best = SPARX64_R1_mask_Middle_Right(search_round,
						tmp_U_left, tmp_V_left, tmp_W_left,
						tmp_U,tmp_V,tmp_W,
						Corr_1, Corr_inc, posi,
						current_index + 1, Fwt);
				}
				else
				{
					best = SPARX64_R1_mask_MSB_Right(search_round,
							tmp_U_left, tmp_V_left, tmp_W_left,
							tmp_U,tmp_V,tmp_W,
							Corr_1, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}



#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//跳转到高比特分析
				best = SPARX64_R1_mask_Middle_Right(search_round,
						tmp_U_left, tmp_V_left, tmp_W_left,
						Input_u, Input_v, Input_w,
						Corr_1, Corr_inc, posi,
						current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = SPARX64_R1_mask_Middle_Right(search_round,
							tmp_U_left, tmp_V_left, tmp_W_left,
							Input_u, Input_v, Input_w,
							Corr_1, Corr_inc +1, posi,
							current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = SPARX64_R1_mask_Middle_Right(search_round,
							tmp_U_left, tmp_V_left, tmp_W_left,
							Input_u, Input_v, Input_w,
							Corr_1, Corr_inc +1, posi,
							current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 SPARX64_R1_mask_MSB_Right(u16 search_round,
		u64 tmp_U_left,u64 tmp_V_left,u64 tmp_W_left,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;



	//printf("OK \n");
	if(Corr_tmp_inc > Corr_1)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
	{
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			//跳转 第2轮的左侧
			best = SPARX64_linear_round_2_Left(search_round,
					tmp_U_left, tmp_V_left, tmp_W_left,
					tmp_U,tmp_V,tmp_W);
		}
		else
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//跳转 第2轮的左侧
			best = SPARX64_linear_round_2_Left(search_round,
					tmp_U_left, tmp_V_left, tmp_W_left,
					Input_u,Input_v,Input_w);
		}
	}
	else
	if( (posi[Corr_1]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
	{
		//Fwt = 0;//当前M向量该比特位无相关性重量
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
			//Input_u = tmp_U | (0 << current_index); //该位置置0
			//Input_v = tmp_V | (0 << current_index); //该位置置0
			//Input_w = tmp_W | (0 << current_index); //该位置置0

			if(current_index <= blocksize_len-2)
			{
				//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
				best = SPARX64_R1_mask_MSB_Right(search_round,
						tmp_U_left, tmp_V_left, tmp_W_left,
						tmp_U,tmp_V,tmp_W,
						Corr_1, Corr_tmp_inc,posi,
						current_index + 1,Fwt);
			}
			else //直接跳转到第2轮的左侧
			{
				//跳转 第2轮的左侧
				best = SPARX64_linear_round_2_Left(search_round,
						tmp_U_left, tmp_V_left, tmp_W_left,
						tmp_U,tmp_V,tmp_W);
			}
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
			best = SPARX64_R1_mask_MSB_Right(search_round,
					tmp_U_left, tmp_V_left, tmp_W_left,
					Input_u, Input_v, Input_w,
					Corr_1, Corr_tmp_inc,posi,
					current_index + 1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
	}
	else //////当前M向量该比特位you相关性重量, M_i = 1; (posi[Corr_1]-1) == current_index .
	{
		//Fwt = 1;//当前M向量该比特位you相关性重量
		//Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_B_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_B_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_B_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				//跳转 第2轮的左侧
				best = SPARX64_linear_round_2_Left(search_round,
						tmp_U_left, tmp_V_left, tmp_W_left,
						Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
			}
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_A_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_A_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_A_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				//跳转 第2轮的左侧
				best = SPARX64_linear_round_2_Left(search_round,
						tmp_U_left, tmp_V_left, tmp_W_left,
						Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return best;
}
#endif
			}
		}
	}

	return best;
}

u16 SPARX64_linear_round_2_Left(u16 search_round,
		u64 tmp_U_left,u64 tmp_V_left,u64 tmp_W_left,
		u64 tmp_U_right,u64 tmp_V_right,u64 tmp_W_right)
{
	u16 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 wt_round_2_left = 0;
//	u16 wt_round_2_right = 0;

	u64 M0 = 0;
	u64 N0 = blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;

//	printf(" L2 \n");
	///////////////////round 1 entry/////////////////////
	if( search_round == 1)
	{
		return best;
	}

	for(wt_round_2_left = 0; wt_round_2_left < 2;wt_round_2_left++)  //0::n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if( (wt_round_2_left + P_w[1] + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}

		M0 = wt_round_2_left;  //
		//P_w[1] = M0; //相关性重量的记录数组

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;
			//直接跳转到第2轮右侧部分
			best = SPARX64_linear_round_2_Right(search_round,
					tmp_U_left,tmp_V_left,tmp_W_left,
					tmp_U_right, tmp_V_right, tmp_W_right,
					Input_u,Input_v,Input_w,
					wt_round_2_left);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;
			//直接跳转到第2轮
			//直接跳转到第2轮右侧部分
			best = SPARX64_linear_round_2_Right(search_round,
					tmp_U_left,tmp_V_left,tmp_W_left,
					tmp_U_right, tmp_V_right, tmp_W_right,
					Input_u,Input_v,Input_w,
					wt_round_2_left);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

//			printf(" L2 >0 --1  \n");
			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			best = SPARX64_R2_mask_Last_left(search_round,
					tmp_U_left,tmp_V_left,tmp_W_left,
					tmp_U_right, tmp_V_right, tmp_W_right,
					wt_round_2_left,C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHANGE_SR1;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHANGE_SR1;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHANGE_SR1;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHANGE_SR1;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHANGE_SR1;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHANGE_SR1;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHANGE_SR1;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
		CHANGE_SR1:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}

//				printf(" L2 >0 --2  \n");
///////////////输出其它的分布模式/////////////////
				best = SPARX64_R2_mask_Last_left(search_round,
						tmp_U_left,tmp_V_left,tmp_W_left,
						tmp_U_right, tmp_V_right, tmp_W_right,
						wt_round_2_left,C0);

#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}
	return best;
}

u16 SPARX64_R2_mask_Last_left(u16 search_round,
		u64 tmp_U_left,u64 tmp_V_left,u64 tmp_W_left,
		u64 tmp_U_right,u64 tmp_V_right,u64 tmp_W_right,
		u16 Corr_1, char *posi)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

//		printf(" L2_last_1 \n");
		//跳转到高比特分析
		best = SPARX64_R2_mask_Middle_left(search_round,
				tmp_U_left,tmp_V_left,tmp_W_left,
				tmp_U_right, tmp_V_right, tmp_W_right,
				Input_u, Input_v, Input_w,
				Corr_1, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

//		printf(" L2_last_2 \n");
		//跳转到高比特分析
		best = SPARX64_R2_mask_Middle_left(search_round,
				tmp_U_left,tmp_V_left,tmp_W_left,
				tmp_U_right, tmp_V_right, tmp_W_right,
				Input_u, Input_v, Input_w,
				Corr_1, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

//			printf(" L2_last_3 \n");
			//跳转到高比特分析
			best = SPARX64_R2_mask_Middle_left(search_round,
					tmp_U_left,tmp_V_left,tmp_W_left,
					tmp_U_right, tmp_V_right, tmp_W_right,
					Input_u, Input_v, Input_w,
					Corr_1, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}

	return best;
}

u16 SPARX64_R2_mask_Middle_left(u16 search_round,
		u64 tmp_U_left,u64 tmp_V_left,u64 tmp_W_left,
		u64 tmp_U_right,u64 tmp_V_right,u64 tmp_W_right,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= Corr_1 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
//		printf(" L2_middle_1 \n");
		best = SPARX64_R2_mask_MSB_left(search_round,
				tmp_U_left,tmp_V_left,tmp_W_left,
				tmp_U_right,tmp_V_right,tmp_W_right,
				tmp_U,tmp_V,tmp_W,
				Corr_1, Corr_tmp_inc, posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

			//	printf(" L2_middle_2 current_index: %d \n",current_index);   ///loooooooooop ???

				if(current_index < blocksize_len -2)
				{
//					printf(" L2_middle_>>> \n");
					//跳转到高比特分析
					best = SPARX64_R2_mask_Middle_left(search_round,
							tmp_U_left,tmp_V_left,tmp_W_left,
							tmp_U_right, tmp_V_right, tmp_W_right,
							tmp_U, tmp_V, tmp_W,
							Corr_1, Corr_inc, posi,
							current_index + 1, Fwt);
				}
				else
				{
//					printf(" L2_middle_<<<<< \n");
					best = SPARX64_R2_mask_MSB_left(search_round,
							tmp_U_left,tmp_V_left,tmp_W_left,
							tmp_U_right,tmp_V_right,tmp_W_right,
							tmp_U,tmp_V,tmp_W,
							Corr_1, Corr_tmp_inc, posi,
							current_index,pre_cor_0or1);

				}

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

//				printf(" L2_middle_3 \n");
				//跳转到高比特分析
				best = SPARX64_R2_mask_Middle_left(search_round,
						tmp_U_left,tmp_V_left,tmp_W_left,
						tmp_U_right, tmp_V_right, tmp_W_right,
						Input_u, Input_v, Input_w,
						Corr_1, Corr_inc, posi,
						current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

//					printf(" L2_middle_4 \n");
					//跳转到高比特分析
					best = SPARX64_R2_mask_Middle_left(search_round,
							tmp_U_left,tmp_V_left,tmp_W_left,
							tmp_U_right, tmp_V_right, tmp_W_right,
							Input_u, Input_v, Input_w,
							Corr_1, Corr_inc +1, posi,
							current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

//					printf(" L2_middle_5 \n");
					//跳转到高比特分析
					best = SPARX64_R2_mask_Middle_left(search_round,
							tmp_U_left,tmp_V_left,tmp_W_left,
							tmp_U_right, tmp_V_right, tmp_W_right,
							Input_u, Input_v, Input_w,
							Corr_1, Corr_inc +1, posi,
							current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 SPARX64_R2_mask_MSB_left(u16 search_round,
		u64 tmp_U_left,u64 tmp_V_left,u64 tmp_W_left,
		u64 tmp_U_right,u64 tmp_V_right,u64 tmp_W_right,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;

//	if(Corr_1 == Corr_tmp_inc)
//	{
//		printf("OK \n");
//	}

//	printf(" L2_MSB_1  \n");

	//printf("OK \n");
	if(Corr_tmp_inc > Corr_1)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
	{
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			//跳转 第2轮的右侧
			best = SPARX64_linear_round_2_Right(search_round,
					tmp_U_left,tmp_V_left,tmp_W_left,
					tmp_U_right,tmp_V_right,tmp_W_right,
					tmp_U,tmp_V,tmp_W,
					Corr_1);
		}
		else
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//跳转 第2轮的右侧
			best = SPARX64_linear_round_2_Right(search_round,
					tmp_U_left,tmp_V_left,tmp_W_left,
					tmp_U_right,tmp_V_right,tmp_W_right,
					Input_u,Input_v,Input_w,
					Corr_1);
		}
	}
	else
	if( (posi[Corr_1]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
	{
		//Fwt = 0;//当前M向量该比特位无相关性重量
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
			//Input_u = tmp_U | (0 << current_index); //该位置置0
			//Input_v = tmp_V | (0 << current_index); //该位置置0
			//Input_w = tmp_W | (0 << current_index); //该位置置0

			if(current_index <= blocksize_len-2)
			{
//				printf(" L2_MSB_2  \n");

				//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
				best = SPARX64_R2_mask_MSB_left(search_round,
						tmp_U_left,tmp_V_left,tmp_W_left,
						tmp_U_right,tmp_V_right,tmp_W_right,
						tmp_U,tmp_V,tmp_W,
						Corr_1, Corr_tmp_inc,posi,
						current_index + 1, Fwt);
			}
			else //直接跳转到第2轮的左侧
			{
//				printf(" L2_MSB_3  \n");
				//跳转 第2轮的右侧
				best = SPARX64_linear_round_2_Right(search_round,
						tmp_U_left,tmp_V_left,tmp_W_left,
						tmp_U_right,tmp_V_right,tmp_W_right,
						tmp_U,tmp_V,tmp_W,
						Corr_1);
			}
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

//			printf(" L2_MSB_4  \n");
			//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
			best = SPARX64_R2_mask_MSB_left(search_round,
					tmp_U_left,tmp_V_left,tmp_W_left,
					tmp_U_right,tmp_V_right,tmp_W_right,
					Input_u, Input_v, Input_w,
					Corr_1, Corr_tmp_inc,posi,
					current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
	}
	else //////当前M向量该比特位you相关性重量, M_i = 1; (posi[Corr_1]-1) == current_index .
	{
		//Fwt = 1;//当前M向量该比特位you相关性重量
		//Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_B_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_B_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_B_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

//				printf(" L2_MSB_5  \n");
				//跳转 第2轮的右侧
				best = SPARX64_linear_round_2_Right(search_round,
						tmp_U_left,tmp_V_left,tmp_W_left,
						tmp_U_right,tmp_V_right,tmp_W_right,
						Input_u,Input_v,Input_w,
						Corr_1);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
			}
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_A_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_A_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_A_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

//				printf(" L2_MSB_6  \n");
				//跳转 第2轮的右侧
				best = SPARX64_linear_round_2_Right(search_round,
						tmp_U_left,tmp_V_left,tmp_W_left,
						tmp_U_right,tmp_V_right,tmp_W_right,
						Input_u,Input_v,Input_w,
						Corr_1);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return best;
}
#endif
			}
		}
	}
	return best;
}


u16 SPARX64_linear_round_2_Right(u16 search_round,
		u64 tmp_U_left,u64 tmp_V_left,u64 tmp_W_left,
		u64 tmp_U_right,u64 tmp_V_right,u64 tmp_W_right,
		u64 tmp_U_left_2, u64 tmp_V_left_2, u64 tmp_W_left_2,
		u16 w2_left)
{
	u16 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u64 Input_tmp_right_L =0;
	u64 Input_tmp_right_R =0;

//	u16 wt_round_2_left = 0;
	u16 wt_round_2_right = 0;

	u64 M0 = 0;
	u64 N0 = blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;


//	printf(" R2 \n");
	///////////////////round 1 entry/////////////////////
	if( search_round == 1)
	{
		return best;
	}

	for(wt_round_2_right = 0; wt_round_2_right < 2;wt_round_2_right++)  //0::n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if( (w2_left + wt_round_2_right + P_w[1] +
				n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}

		M0 = wt_round_2_right;  //
		P_w[2] = w2_left + M0; //相关性重量的记录数组

		wt_l[2] = w2_left;
		wt_r[2] = wt_round_2_right;

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			//处理SPARX64的前两轮的输入输出差分

			//第2轮的输入掩码左边
			X_r[0][2] = (((tmp_V_left_2) << rol_a)
						| ((tmp_V_left_2) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
			X_r[1][2] = tmp_U_left ^ X_r[0][2];
			//第2轮的输出、第3轮的输入掩码 左边
			Input_tmp_right_L = tmp_W_left_2 ^ X_r[1][2];
			X_r[1][3] = ((Input_tmp_right_L << rol_b)
						| (Input_tmp_right_L >> (blocksize_len-rol_b))) & Bit_Align;//rol left
			X_r[0][3] = X_r[1][3] ^ tmp_U_left_2;

			//第2轮的输入掩码右边
			X_r[2][2] = ((Input_v << rol_a)
						| (Input_v >> (blocksize_len-rol_a))) & Bit_Align;//rol left
			X_r[3][2] = tmp_U_right ^ X_r[2][2];
			//第2轮的输出、第3轮的输入掩码 右边
			Input_tmp_right_R = Input_w ^ X_r[3][2];
			X_r[3][3] = ((Input_tmp_right_R << rol_b)
						| (Input_tmp_right_R >> (blocksize_len-rol_b))) & Bit_Align;//rol left
			X_r[2][3] = X_r[3][3] ^ Input_u;

//			printf(" R2_0 \n");

		//跳转 第3轮
		//直接跳转到第R轮
			best = SPARX64_linear_round_r(search_round, 3,
					X_r[0][3],X_r[1][3],X_r[2][3], X_r[3][3]);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		//第1轮的X0
		X_r[0][1] = ((tmp_V_left << rol_a)  |
				(tmp_V_left >> (blocksize_len-rol_a))) & Bit_Align;//rol left
		//第1轮的X1
		X_r[1][1] = ((X_r[1][2] >> rol_b) |
				X_r[1][2] << (blocksize_len - rol_b)) & Bit_Align;//rol right
		X_r[1][1] = tmp_W_left ^ X_r[1][1];

		//第1轮的X2
		X_r[2][1] = ((tmp_V_right << rol_a) |
				(tmp_V_right >> (blocksize_len-rol_a))) & Bit_Align;//rol left
		//第1轮的X3
		X_r[3][1] = ((X_r[3][2] >> rol_b) |
				(X_r[3][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
		X_r[3][1] = tmp_W_right ^ X_r[3][1];

		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;

			//处理SPARX64的前两轮的输入输出差分

			//第2轮的输入掩码左边
			X_r[0][2] = ((tmp_V_left_2 << rol_a)
						| (tmp_V_left_2 >> (blocksize_len-rol_a))) & Bit_Align;//rol left
			X_r[1][2] = tmp_U_left ^ X_r[0][2];
			//第2轮的输出、第3轮的输入掩码 左边
			Input_tmp_right_L = tmp_W_left_2 ^ X_r[1][2];
			X_r[1][3] = ((Input_tmp_right_L << rol_b)
						| (Input_tmp_right_L >> (blocksize_len-rol_b))) & Bit_Align;//rol left
			X_r[0][3] = X_r[1][3] ^ tmp_U_left_2;

			//第2轮的输入掩码右边
			X_r[2][2] = ((Input_v << rol_a)
						| (Input_v >> (blocksize_len-rol_a))) & Bit_Align;//rol left
			X_r[3][2] = tmp_U_right ^ X_r[2][2];
			//第2轮的输出、第3轮的输入掩码 右边
			Input_tmp_right_R = Input_w ^ X_r[3][2];
			X_r[3][3] = ((Input_tmp_right_R << rol_b)
						| (Input_tmp_right_R >> (blocksize_len-rol_b))) & Bit_Align;//rol left
			X_r[2][3] = X_r[3][3] ^ Input_u;

//			printf(" R2_1 \n");
			//跳转 第3轮
			//直接跳转到第R轮
				best = SPARX64_linear_round_r(search_round, 3,
						X_r[0][3],X_r[1][3],X_r[2][3], X_r[3][3]);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		//第1轮的X0
		X_r[0][1] = ((tmp_V_left << rol_a)  |
				(tmp_V_left >> (blocksize_len-rol_a))) & Bit_Align;//rol left
		//第1轮的X1
		X_r[1][1] = ((X_r[1][2] >> (rol_b)) |
				(X_r[1][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
		X_r[1][1] = tmp_W_left ^ X_r[1][1];

		//第1轮的X2
		X_r[2][1] = ((tmp_V_right << rol_a) |
				(tmp_V_right >> (blocksize_len-rol_a))) & Bit_Align;//rol left
		//第1轮的X3
		X_r[3][1] = ((X_r[3][2] >> (rol_b)) |
				(X_r[3][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
		X_r[3][1] = tmp_W_right ^ X_r[3][1];

		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{  	//printf(" R2 >0 \n");
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

//			printf(" R2_3 \n");

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			best = SPARX64_R2_mask_Last_Right(search_round,
					tmp_U_left,tmp_V_left,tmp_W_left,
					tmp_U_right, tmp_V_right, tmp_W_right,
					tmp_U_left_2,tmp_V_left_2,tmp_W_left_2,
					wt_round_2_right,C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHANGE_SR2;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHANGE_SR2;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHANGE_SR2;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHANGE_SR2;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHANGE_SR2;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHANGE_SR2;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHANGE_SR2;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
		CHANGE_SR2:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}

//				printf(" R2_4 \n");

///////////////输出其它的分布模式/////////////////
				best = SPARX64_R2_mask_Last_Right(search_round,
						tmp_U_left,tmp_V_left,tmp_W_left,
						tmp_U_right, tmp_V_right, tmp_W_right,
						tmp_U_left_2,tmp_V_left_2,tmp_W_left_2,
						wt_round_2_right,C0);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}
	return best;
}

u16 SPARX64_R2_mask_Last_Right(u16 search_round,
		u64 tmp_U_left,u64 tmp_V_left,u64 tmp_W_left,
		u64 tmp_U_right,u64 tmp_V_right,u64 tmp_W_right,
		u64 tmp_U_left_2, u64 tmp_V_left_2, u64 tmp_W_left_2,
		u16 Corr_1, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

//		printf(" R2_last_1 \n");

		//跳转到高比特分析
		best = SPARX64_R2_mask_Middle_Right(search_round,
				tmp_U_left,tmp_V_left,tmp_W_left,
				tmp_U_right, tmp_V_right, tmp_W_right,
				tmp_U_left_2,tmp_V_left_2,tmp_W_left_2,
				Input_u, Input_v, Input_w,
				Corr_1, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

//		printf(" R2_last_2 \n");
		//跳转到高比特分析
		best = SPARX64_R2_mask_Middle_Right(search_round,
				tmp_U_left,tmp_V_left,tmp_W_left,
				tmp_U_right, tmp_V_right, tmp_W_right,
				tmp_U_left_2,tmp_V_left_2,tmp_W_left_2,
				Input_u, Input_v, Input_w,
				Corr_1, Corr_inc, posi,
				1, Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

//			printf(" R2_last_3 \n");

			//跳转到高比特分析
			best = SPARX64_R2_mask_Middle_Right(search_round,
					tmp_U_left,tmp_V_left,tmp_W_left,
					tmp_U_right, tmp_V_right, tmp_W_right,
					tmp_U_left_2,tmp_V_left_2,tmp_W_left_2,
					Input_u, Input_v, Input_w,
					Corr_1, Corr_inc, posi,
					1, Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}

	return best;
}



u16 SPARX64_R2_mask_Middle_Right(u16 search_round,
		u64 tmp_U_left,u64 tmp_V_left,u64 tmp_W_left,
		u64 tmp_U_right,u64 tmp_V_right,u64 tmp_W_right,
		u64 tmp_U_left_2, u64 tmp_V_left_2, u64 tmp_W_left_2,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;

//	printf(" R2_middle_1 \n");

	if(Corr_tmp_inc >= Corr_1 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
//		printf(" R2_middle_msb \n");
		best = SPARX64_R2_mask_MSB_Right(search_round,
				tmp_U_left,tmp_V_left,tmp_W_left,
				tmp_U_right,tmp_V_right,tmp_W_right,
				tmp_U_left_2,tmp_V_left_2,tmp_W_left_2,
				tmp_U,tmp_V,tmp_W,
				Corr_1, Corr_tmp_inc, posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

//				printf(" R2_middle_2 \n");
				if(current_index < blocksize_len -2)
				{
				//跳转到高比特分析
				best = SPARX64_R2_mask_Middle_Right(search_round,
						tmp_U_left,tmp_V_left,tmp_W_left,
						tmp_U_right, tmp_V_right, tmp_W_right,
						tmp_U_left_2,tmp_V_left_2,tmp_W_left_2,
						tmp_U, tmp_V, tmp_W,
						Corr_1, Corr_inc, posi,
						current_index + 1, Fwt);
				}
				else
				{
					best = SPARX64_R2_mask_MSB_Right(search_round,
							tmp_U_left,tmp_V_left,tmp_W_left,
							tmp_U_right,tmp_V_right,tmp_W_right,
							tmp_U_left_2,tmp_V_left_2,tmp_W_left_2,
							tmp_U,tmp_V,tmp_W,
							Corr_1, Corr_tmp_inc, posi,
							current_index,pre_cor_0or1);
				}


#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

//				printf(" R2_middle_3 \n");

				//跳转到高比特分析
				best = SPARX64_R2_mask_Middle_Right(search_round,
						tmp_U_left,tmp_V_left,tmp_W_left,
						tmp_U_right, tmp_V_right, tmp_W_right,
						tmp_U_left_2,tmp_V_left_2,tmp_W_left_2,
						Input_u, Input_v, Input_w,
						Corr_1, Corr_inc, posi,
						current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

//					printf(" R2_middle_4 \n");

					//跳转到高比特分析
					best = SPARX64_R2_mask_Middle_Right(search_round,
							tmp_U_left,tmp_V_left,tmp_W_left,
							tmp_U_right, tmp_V_right, tmp_W_right,
							tmp_U_left_2,tmp_V_left_2,tmp_W_left_2,
							Input_u, Input_v, Input_w,
							Corr_1, Corr_inc + 1, posi,
							current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

//					printf(" R2_middle_5 \n");

					//跳转到高比特分析
					best = SPARX64_R2_mask_Middle_Right(search_round,
							tmp_U_left,tmp_V_left,tmp_W_left,
							tmp_U_right, tmp_V_right, tmp_W_right,
							tmp_U_left_2,tmp_V_left_2,tmp_W_left_2,
							Input_u, Input_v, Input_w,
							Corr_1, Corr_inc + 1, posi,
							current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}


u16 SPARX64_R2_mask_MSB_Right(u16 search_round,
		u64 tmp_U_left,u64 tmp_V_left,u64 tmp_W_left,
		u64 tmp_U_right,u64 tmp_V_right,u64 tmp_W_right,
		u64 tmp_U_left_2, u64 tmp_V_left_2, u64 tmp_W_left_2,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;

	u64 Input_tmp_right_L =0;
	u64 Input_tmp_right_R =0;


//	printf(" R2_MSB_1 \n");  	//printf("OK \n");
	if(Corr_tmp_inc > Corr_1)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
	{
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			//第2轮的输入掩码左边
			X_r[0][2] = (((tmp_V_left_2) << rol_a)
						| ((tmp_V_left_2) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
			X_r[1][2] = tmp_U_left ^ X_r[0][2];
			//第2轮的输出、第3轮的输入掩码 左边
			Input_tmp_right_L = tmp_W_left_2 ^ X_r[1][2];
			X_r[1][3] = ((Input_tmp_right_L << rol_b)
						| (Input_tmp_right_L >> (blocksize_len-rol_b))) & Bit_Align;//rol left
			X_r[0][3] = X_r[1][3] ^ tmp_U_left_2;

			//第2轮的输入掩码右边
			X_r[2][2] = ((tmp_V << rol_a)
						| (tmp_V >> (blocksize_len-rol_a))) & Bit_Align;//rol left
			X_r[3][2] = tmp_U_right ^ X_r[2][2];
			//第2轮的输出、第3轮的输入掩码 右边
			Input_tmp_right_R = tmp_W ^ X_r[3][2];
			X_r[3][3] = ((Input_tmp_right_R << rol_b)
						| (Input_tmp_right_R >> (blocksize_len-rol_b))) & Bit_Align;//rol left
			X_r[2][3] = X_r[3][3] ^ tmp_U;
		//跳转 第3轮
		//直接跳转到第R轮
			best = SPARX64_linear_round_r(search_round,3,
					X_r[0][3],X_r[1][3],X_r[2][3], X_r[3][3]);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	//第1轮的X0
	X_r[0][1] = ((tmp_V_left << rol_a)  |
			((tmp_V_left) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
	//第1轮的X1
	X_r[1][1] = ((X_r[1][2] >> rol_b) |
			(X_r[1][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
	X_r[1][1] = tmp_W_left ^ X_r[1][1];

	//第1轮的X2
	X_r[2][1] = ((tmp_V_right << rol_a) |
			(tmp_V_right >> (blocksize_len-rol_a))) & Bit_Align;//rol left
	//第1轮的X3
	X_r[3][1] = ((X_r[3][2] >> rol_b) |
			(X_r[3][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
	X_r[3][1] = tmp_W_right ^ X_r[3][1];

	return 1;
}
#endif
		}
		else
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//第2轮的输入掩码左边
			X_r[0][2] = (((tmp_V_left_2) << rol_a)
						| ((tmp_V_left_2) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
			X_r[1][2] = tmp_U_left ^ X_r[0][2];
			//第2轮的输出、第3轮的输入掩码 左边
			Input_tmp_right_L = tmp_W_left_2 ^ X_r[1][2];
			X_r[1][3] = ((Input_tmp_right_L << rol_b)
						| (Input_tmp_right_L >> (blocksize_len-rol_b))) & Bit_Align;//rol left
			X_r[0][3] = X_r[1][3] ^ tmp_U_left_2;

			//第2轮的输入掩码右边
			X_r[2][2] = ((Input_v << rol_a)
						| (Input_v >> (blocksize_len-rol_a))) & Bit_Align;//rol left
			X_r[3][2] = tmp_U_right ^ X_r[2][2];
			//第2轮的输出、第3轮的输入掩码 右边
			Input_tmp_right_R = Input_w ^ X_r[3][2];
			X_r[3][3] = ((Input_tmp_right_R << rol_b)
						| (Input_tmp_right_R >> (blocksize_len-rol_b))) & Bit_Align;//rol left
			X_r[2][3] = X_r[3][3] ^ Input_u;

		//跳转 第3轮
		//直接跳转到第R轮
			best = SPARX64_linear_round_r(search_round, 3,
					X_r[0][3],X_r[1][3],X_r[2][3], X_r[3][3]);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
//记录并返回UVW
//第1轮的X0
X_r[0][1] = ((tmp_V_left << rol_a)  |
		(tmp_V_left >> (blocksize_len-rol_a))) & Bit_Align;//rol left
//第1轮的X1
X_r[1][1] = ((X_r[1][2] >> rol_b) |
		(X_r[1][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
X_r[1][1] = tmp_W_left ^ X_r[1][1];

//第1轮的X2
X_r[2][1] = ((tmp_V_right << rol_a) |
		(tmp_V_right >> (blocksize_len-rol_a))) & Bit_Align;//rol left
//第1轮的X3
X_r[3][1] = ((X_r[3][2] >> rol_b) |
		(X_r[3][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
X_r[3][1] = tmp_W_right ^ X_r[3][1];

return 1;
}
#endif
		}
	}
	else
	if( (posi[Corr_1]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
	{
		//Fwt = 0;//当前M向量该比特位无相关性重量
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
			//Input_u = tmp_U | (0 << current_index); //该位置置0
			//Input_v = tmp_V | (0 << current_index); //该位置置0
			//Input_w = tmp_W | (0 << current_index); //该位置置0

			if(current_index <= blocksize_len-2)
			{
//				printf(" R2_MSB_2 \n");
				//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
				best = SPARX64_R2_mask_MSB_Right(search_round,
						tmp_U_left,tmp_V_left,tmp_W_left,
						tmp_U_right,tmp_V_right,tmp_W_right,
						tmp_U_left_2,tmp_V_left_2,tmp_W_left_2,
						tmp_U,tmp_V,tmp_W,
						Corr_1, Corr_tmp_inc, posi,
						current_index + 1, Fwt);
			}
			else //直接跳转到第2轮的左侧
			{
				/////////
				//第2轮的输入掩码左边
				X_r[0][2] = (((tmp_V_left_2) << rol_a)
							| ((tmp_V_left_2) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
				X_r[1][2] = tmp_U_left ^ X_r[0][2];
				//第2轮的输出、第3轮的输入掩码 左边
				Input_tmp_right_L = tmp_W_left_2 ^ X_r[1][2];
				X_r[1][3] = ((Input_tmp_right_L << rol_b)
							| (Input_tmp_right_L >> (blocksize_len-rol_b))) & Bit_Align;//rol left
				X_r[0][3] = X_r[1][3] ^ tmp_U_left_2;

				//第2轮的输入掩码右边
				X_r[2][2] = ((tmp_V << rol_a)
							| (tmp_V >> (blocksize_len-rol_a))) & Bit_Align;//rol left
				X_r[3][2] = tmp_U_right ^ X_r[2][2];
				//第2轮的输出、第3轮的输入掩码 右边
				Input_tmp_right_R = tmp_W ^ X_r[3][2];
				X_r[3][3] = ((Input_tmp_right_R << rol_b)
							| (Input_tmp_right_R >> (blocksize_len-rol_b))) & Bit_Align;//rol left
				X_r[2][3] = X_r[3][3] ^ tmp_U;

//				printf(" R2_MSB_3  %d %d %d %d \n",X_r[0][3],X_r[1][3],X_r[2][3], X_r[3][3]);
			//跳转 第3轮
			//直接跳转到第R轮
				best = SPARX64_linear_round_r(search_round,3,
						X_r[0][3],X_r[1][3],X_r[2][3], X_r[3][3]);
			}
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	//第1轮的X0
	X_r[0][1] = ((tmp_V_left << rol_a)  |
			((tmp_V_left) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
	//第1轮的X1
	X_r[1][1] = ((X_r[1][2] >> rol_b) |
			(X_r[1][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
	X_r[1][1] = tmp_W_left ^ X_r[1][1];

	//第1轮的X2
	X_r[2][1] = ((tmp_V_right << rol_a) |
			(tmp_V_right >> (blocksize_len-rol_a))) & Bit_Align;//rol left
	//第1轮的X3
	X_r[3][1] = ((X_r[3][2] >> rol_b) |
			(X_r[3][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
	X_r[3][1] = tmp_W_right ^ X_r[3][1];

	return 1;
}
#endif
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

//			printf(" R2_MSB_4 \n");
			//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
			best = SPARX64_R2_mask_MSB_Right(search_round,
					tmp_U_left,tmp_V_left,tmp_W_left,
					tmp_U_right,tmp_V_right,tmp_W_right,
					tmp_U_left_2,tmp_V_left_2,tmp_W_left_2,
					Input_u,Input_v,Input_w,
					Corr_1, Corr_tmp_inc, posi,
					current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
	}
	else //////当前M向量该比特位you相关性重量, M_i = 1; (posi[Corr_1]-1) == current_index .
	{
		//Fwt = 1;//当前M向量该比特位you相关性重量
		//Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_B_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_B_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_B_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				//////处理第1/2轮的输入输出掩码///
				//第2轮的输入掩码左边
				X_r[0][2] = (((tmp_V_left_2) << rol_a)
							| ((tmp_V_left_2) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
				X_r[1][2] = tmp_U_left ^ X_r[0][2];
				//第2轮的输出、第3轮的输入掩码 左边
				Input_tmp_right_L = tmp_W_left_2 ^ X_r[1][2];
				X_r[1][3] = ((Input_tmp_right_L << rol_b)
							| (Input_tmp_right_L >> (blocksize_len-rol_b))) & Bit_Align;//rol left
				X_r[0][3] = X_r[1][3] ^ tmp_U_left_2;

				//第2轮的输入掩码右边
				X_r[2][2] = ((Input_v << rol_a)
							| (Input_v >> (blocksize_len-rol_a))) & Bit_Align;//rol left
				X_r[3][2] = tmp_U_right ^ X_r[2][2];
				//第2轮的输出、第3轮的输入掩码 右边
				Input_tmp_right_R = Input_w ^ X_r[3][2];
				X_r[3][3] = ((Input_tmp_right_R << rol_b)
							| (Input_tmp_right_R >> (blocksize_len-rol_b))) & Bit_Align;//rol left
				X_r[2][3] = X_r[3][3] ^ Input_u;

//				printf(" R2_MSB_5 \n");

			//跳转 第3轮
			//直接跳转到第R轮
				best = SPARX64_linear_round_r(search_round, 3,
						X_r[0][3],X_r[1][3],X_r[2][3], X_r[3][3]);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	//第1轮的X0
	X_r[0][1] = ((tmp_V_left << rol_a)  |
			(tmp_V_left >> (blocksize_len-rol_a))) & Bit_Align;//rol left
	//第1轮的X1
	X_r[1][1] = ((X_r[1][2] >> rol_b) |
			(X_r[1][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
	X_r[1][1] = tmp_W_left ^ X_r[1][1];

	//第1轮的X2
	X_r[2][1] = ((tmp_V_right << rol_a) |
			(tmp_V_right >> (blocksize_len-rol_a))) & Bit_Align;//rol left
	//第1轮的X3
	X_r[3][1] = ((X_r[3][2] >> rol_b) |
			(X_r[3][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
	X_r[3][1] = tmp_W_right ^ X_r[3][1];

	return 1;
}
#endif
			}
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_A_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_A_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_A_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				//////处理第1/2轮的输入输出掩码/////

				//第2轮的输入掩码左边
				X_r[0][2] = (((tmp_V_left_2) << rol_a)
							| ((tmp_V_left_2) >> (blocksize_len-rol_a))) & Bit_Align;//rol left
				X_r[1][2] = tmp_U_left ^ X_r[0][2];
				//第2轮的输出、第3轮的输入掩码 左边
				Input_tmp_right_L = tmp_W_left_2 ^ X_r[1][2];
				X_r[1][3] = ((Input_tmp_right_L << rol_b)
							| (Input_tmp_right_L >> (blocksize_len-rol_b))) & Bit_Align;//rol left
				X_r[0][3] = X_r[1][3] ^ tmp_U_left_2;

				//第2轮的输入掩码右边
				X_r[2][2] = ((Input_v << rol_a)
							| (Input_v >> (blocksize_len-rol_a))) & Bit_Align;//rol left
				X_r[3][2] = tmp_U_right ^ X_r[2][2];
				//第2轮的输出、第3轮的输入掩码 右边
				Input_tmp_right_R = Input_w ^ X_r[3][2];
				X_r[3][3] = ((Input_tmp_right_R << rol_b)
							| (Input_tmp_right_R >> (blocksize_len-rol_b))) & Bit_Align;//rol left
				X_r[2][3] = X_r[3][3] ^ Input_u;

//				printf(" R2_MSB_6 \n");
			//跳转 第3轮
			//直接跳转到第R轮
				best = SPARX64_linear_round_r(search_round, 3,
						X_r[0][3],X_r[1][3],X_r[2][3], X_r[3][3]);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	//第1轮的X0
	X_r[0][1] = ((tmp_V_left << rol_a)  |
			(tmp_V_left >> (blocksize_len-rol_a))) & Bit_Align;//rol left
	//第1轮的X1
	X_r[1][1] = ((X_r[1][2] >> rol_b) |
			(X_r[1][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
	X_r[1][1] = tmp_W_left ^ X_r[1][1];

	//第1轮的X2
	X_r[2][1] = ((tmp_V_right << rol_a) |
			(tmp_V_right >> (blocksize_len-rol_a))) & Bit_Align;//rol left
	//第1轮的X3
	X_r[3][1] = ((X_r[3][2] >> rol_b) |
			(X_r[3][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
	X_r[3][1] = tmp_W_right ^ X_r[3][1];

	return best;
}
#endif
			}
		}
	}
	return best;
}


u16 SPARX64_linear_round_r(u16 search_round, u16 cur_round,
		u64 X0, u64 X1, u64 X2, u64 X3)
{
	u16 best = 0;

	u64 Input_v_L = 0;  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_L = 0;  //模加输入右侧掩码
	u64 Input_u_L = 0;  //模加输出掩码
	u64 Input_tmp_right_L = 0;  //
	u64 Input_v_R = 0;  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_R = 0;  //模加输入右侧掩码
	u64 Input_u_R = 0;  //模加输出掩码
	u64 Input_tmp_right_R = 0;  //

	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;

	u64 v_block_L[2] = {0}; //按照8比特进行切片
	u64 w_block_L[2] = {0};
	u64 u_block_L[2] = {0};
	u64 v_block_R[2] = {0}; //按照8比特进行切片
	u64 w_block_R[2] = {0};
	u64 u_block_R[2] = {0};

	u64 L_L = 0, L_L_tmp = 0;    //用于线性变换L后的线性掩码变量
	u64 X0_L =0, X1_L=0, X2_L=0, X3_L=0;

	u64 e_Mxor_L = 0; //用于记录M向量的高比特的异或和
	u64 e_Mxor_R = 0; //用于记录M向量的高比特的异或和
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0,i2=0,i3=0;
	u64 j0=0,j1=0,j2=0,j3=0;

//	printf(" search_round r: %d \n", cur_round);

	if(search_round == cur_round)
	{
		best = SPARX64_linear_round_N(search_round, X0,X1,X2,X3);
		return best;
	}


	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = Bn_w - p_sumof_r - n_P_bestofR_w[search_round - cur_round];


	Input_v_L = ((X0 >> rol_a) |
			(X0 << (blocksize_len - rol_a))) & Bit_Align;//rol right
	//m1 //从MSB向LSB的方向进行分块
	v_block_L[0] =  (Input_v_L >> 8) & 0xFF; //MSB 8 bit
	//m0
	v_block_L[1] =  (Input_v_L) & 0xFF; //LSB 8 bit

	Input_v_R = ((X2 >> rol_a) |
			(X2 << (blocksize_len - rol_a))) & Bit_Align;//rol right
	//m1 //从MSB向LSB的方向进行分块
	v_block_R[0] =  (Input_v_R >> 8) & 0xFF; //MSB 8 bit
	//m0
	v_block_R[1] =  (Input_v_R) & 0xFF; //LSB 8 bit

	//bound wt
	wt_cor_bound = cLAT_wtcor_min[v_block_L[0]][0] +
			cLAT_wtcor_min[v_block_L[1]][0] +
			cLAT_wtcor_min[v_block_R[0]][0] +
			cLAT_wtcor_min[v_block_R[1]][0];

//	printf(" Round juge wt_cor_bound:%d  w_cmp:%d \n", wt_cor_bound,w_cmp );

	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

//	printf(" Round  %x %x %x %x \n", X0,X1,X2,X3 );

	for(i0 = cLAT_wtcor_min[v_block_L[0]][0]; i0 < 8; i0++)
	{
		if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
	for(j0=0; j0 < cLAT_WU_numb[v_block_L[0]][0][i0]; j0++)
	{
		w_block_L[0] = cLAT_W[v_block_L[0]][0][i0][j0];
		u_block_L[0] = cLAT_U[v_block_L[0]][0][i0][j0];

		//e_Mxor[1] = HM_weight(u_block[0] ^ w_block[0] ^ v_block[0]) % 2; // 0 or 1.
		e_Mxor_L = cLAT_UVW_bro[u_block_L[0]][v_block_L[0]][w_block_L[0]][0];
		//if(e_Mxor[1] >1 ){continue;}
////
	for(i1 = cLAT_wtcor_min[v_block_L[1]][e_Mxor_L]; i1 <= 8; i1++)
	{
		if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cLAT_WU_numb[v_block_L[1]][e_Mxor_L][i1]; j1++)
	{
		w_block_L[1] = cLAT_W[v_block_L[1]][e_Mxor_L][i1][j1];
		u_block_L[1] = cLAT_U[v_block_L[1]][e_Mxor_L][i1][j1];
		//e_Mxor[2] = (HM_weight(u_block[1] ^ w_block[1] ^ v_block[1]) + e_Mxor[1]) % 2; // 0 or 1.

		Input_w_L = (w_block_L[0] << 8) | w_block_L[1];  //模加输入右侧掩码
		Input_u_L = (u_block_L[0] << 8) | u_block_L[1];  //模加输入右侧掩码


////////////////
		for(i2 = cLAT_wtcor_min[v_block_R[0]][0]; i2 < 8; i2++)
		{
			if(i0 + i1 + i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j2=0; j2 < cLAT_WU_numb[v_block_R[0]][0][i2]; j2++)
		{
			w_block_R[0] = cLAT_W[v_block_R[0]][0][i2][j2];
			u_block_R[0] = cLAT_U[v_block_R[0]][0][i2][j2];

			//e_Mxor[1] = HM_weight(u_block[0] ^ w_block[0] ^ v_block[0]) % 2; // 0 or 1.
			e_Mxor_R = cLAT_UVW_bro[u_block_R[0]][v_block_R[0]][w_block_R[0]][0];
			//if(e_Mxor[1] >1 ){continue;}
///
		for(i3 = cLAT_wtcor_min[v_block_R[1]][e_Mxor_R]; i3 <= 8; i3++)
		{
			if(i0 + i1 + i2 + i3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < cLAT_WU_numb[v_block_R[1]][e_Mxor_R][i3]; j3++)
		{
			w_block_R[1] = cLAT_W[v_block_R[1]][e_Mxor_R][i3][j3];
			u_block_R[1] = cLAT_U[v_block_R[1]][e_Mxor_R][i3][j3];
			//e_Mxor[2] = (HM_weight(u_block[1] ^ w_block[1] ^ v_block[1]) + e_Mxor[1]) % 2; // 0 or 1.

			Input_w_R = (w_block_R[0] << 8) | w_block_R[1];  //模加输入右侧掩码
			Input_u_R = (u_block_R[0] << 8) | u_block_R[1];  //模加输入右侧掩码

///
			//处理本来的输出掩码 左
			Input_tmp_right_L = X1 ^ Input_w_L;
			X_r[1][cur_round + 1] = ((Input_tmp_right_L << rol_b) |
					(Input_tmp_right_L >> (blocksize_len-rol_b))) & Bit_Align; //rol left
			X_r[0][cur_round + 1] = X_r[1][cur_round + 1] ^ Input_u_L;

			//处理本来的输出掩码 右
			Input_tmp_right_R = X3 ^ Input_w_R;
			X_r[3][cur_round + 1] = ((Input_tmp_right_R << rol_b) |
					(Input_tmp_right_R >> (blocksize_len-rol_b))) & Bit_Align; //rol left
			X_r[2][cur_round + 1] = X_r[3][cur_round + 1] ^ Input_u_R;

		wt_l[cur_round] = i0 + i1;
		wt_r[cur_round] = i2 + i3;
		P_w[cur_round] = wt_l[cur_round] + wt_r[cur_round];  //当前轮的线性相关性重量

		if(((cur_round) % 3) == 0) //下一轮为 4,7,10,13,16,...
		{
			//L前的输出掩码需要输出
			IN_L_X[cur_round/3][0] = X_r[0][cur_round + 1];  //记录的是L变换前的值
			IN_L_X[cur_round/3][1] = X_r[1][cur_round + 1];
			IN_L_X[cur_round/3][2] = X_r[2][cur_round + 1];
			IN_L_X[cur_round/3][3] = X_r[3][cur_round + 1];

			L_L = X_r[2][cur_round + 1] ^ X_r[3][cur_round + 1];
			L_L_tmp = ((L_L >> 8) |
					(L_L << (blocksize_len - 8))) & Bit_Align;//rol right

			X0_L = X_r[2][cur_round + 1];
			X1_L = X_r[3][cur_round + 1]; //注意L函数的线性传播
			X2_L = X_r[2][cur_round + 1] ^ X_r[0][cur_round + 1] ^ L_L_tmp;   //
			X3_L = X_r[3][cur_round + 1] ^ X_r[1][cur_round + 1] ^ L_L_tmp;   //

			X_r[0][cur_round + 1] = X0_L;
			X_r[1][cur_round + 1] = X1_L;
			X_r[2][cur_round + 1] = X2_L;
			X_r[3][cur_round + 1] = X3_L;
		}

//		printf(" Next  search_round r: %d \n", cur_round);
		//跳转 下一轮
		best = SPARX64_linear_round_r(search_round,cur_round + 1,
				X_r[0][cur_round + 1],X_r[1][cur_round + 1],
				X_r[2][cur_round + 1],X_r[3][cur_round + 1]);
#if 1   //是否找到第一条最优路径就返回？
if( best == 1 )
	return 1;
#endif
	}}}}
	}}}}

	return best;
}

u16 SPARX64_linear_round_N(u16 search_round, u64 X0, u64 X1, u64 X2, u64 X3)
{
	u16 best = 0;

	u64 Input_v_L = 0;  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_L = 0;  //模加输入右侧掩码
	u64 Input_u_L = 0;  //模加输出掩码
	u64 Input_tmp_right_L = 0;  //
	u64 Input_v_R = 0;  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_R = 0;  //模加输入右侧掩码
	u64 Input_u_R = 0;  //模加输出掩码
	u64 Input_tmp_right_R = 0;  //

	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;

	u64 v_block_L[2] = {0}; //按照8比特进行切片
	u64 w_block_L[2] = {0};
	u64 u_block_L[2] = {0};
	u64 v_block_R[2] = {0}; //按照8比特进行切片
	u64 w_block_R[2] = {0};
	u64 u_block_R[2] = {0};

	u64 L_L = 0, L_L_tmp = 0;    //用于线性变换L后的线性掩码变量
	u64 X0_L =0, X1_L=0, X2_L=0, X3_L=0;

	u64 e_Mxor_L = 0; //用于记录M向量的高比特的异或和
	u64 e_Mxor_R = 0; //用于记录M向量的高比特的异或和
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0,i2=0,i3=0;
	u64 j0=0,j1=0,j2=0,j3=0;

//	printf(" search_round N \n");

	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = Bn_w - p_sumof_r;

	if((X0==0) && (X1==0) && (X2==0) && (X3==0))
	{
		return 0;
	}

	Input_v_L = ((X0 >> rol_a) |
			(X0 << (blocksize_len - rol_a))) & Bit_Align;//rol right
	//m1 //从MSB向LSB的方向进行分块
	v_block_L[0] =  (Input_v_L >> 8) & 0xFF; //MSB 8 bit
	//m0
	v_block_L[1] =  (Input_v_L) & 0xFF; //LSB 8 bit

	Input_v_R = ((X2 >> rol_a) |
			(X2 << (blocksize_len - rol_a))) & Bit_Align;//rol right
	//m1 //从MSB向LSB的方向进行分块
	v_block_R[0] =  (Input_v_R >> 8) & 0xFF; //MSB 8 bit
	//m0
	v_block_R[1] =  (Input_v_R) & 0xFF; //LSB 8 bit


	//bound wt
	wt_cor_bound = cLAT_wtcor_min[v_block_L[0]][0] +
			cLAT_wtcor_min[v_block_L[1]][0] +
			cLAT_wtcor_min[v_block_R[0]][0] +
			cLAT_wtcor_min[v_block_R[1]][0];
	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}


	for(i0 = cLAT_wtcor_min[v_block_L[0]][0]; i0 < 8; i0++)
	{
		if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
	for(j0=0; j0 < cLAT_WU_numb[v_block_L[0]][0][i0]; j0++)
	{
		w_block_L[0] = cLAT_W[v_block_L[0]][0][i0][j0];
		u_block_L[0] = cLAT_U[v_block_L[0]][0][i0][j0];

		//e_Mxor[1] = HM_weight(u_block[0] ^ w_block[0] ^ v_block[0]) % 2; // 0 or 1.
		e_Mxor_L = cLAT_UVW_bro[u_block_L[0]][v_block_L[0]][w_block_L[0]][0];
		//if(e_Mxor[1] >1 ){continue;}

	for(i1 = cLAT_wtcor_min[v_block_L[1]][e_Mxor_L]; i1 <= 8; i1++)
	{
		if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cLAT_WU_numb[v_block_L[1]][e_Mxor_L][i1]; j1++)
	{
		w_block_L[1] = cLAT_W[v_block_L[1]][e_Mxor_L][i1][j1];
		u_block_L[1] = cLAT_U[v_block_L[1]][e_Mxor_L][i1][j1];
		//e_Mxor[2] = (HM_weight(u_block[1] ^ w_block[1] ^ v_block[1]) + e_Mxor[1]) % 2; // 0 or 1.

		Input_w_L = (w_block_L[0] << 8) | w_block_L[1];  //模加输入右侧掩码
		Input_u_L = (u_block_L[0] << 8) | u_block_L[1];  //模加输入右侧掩码

///
		for(i2 = cLAT_wtcor_min[v_block_R[0]][0]; i2 < 8; i2++)
		{
			if(i0 + i1 + i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j2=0; j2 < cLAT_WU_numb[v_block_R[0]][0][i2]; j2++)
		{
			w_block_R[0] = cLAT_W[v_block_R[0]][0][i2][j2];
			u_block_R[0] = cLAT_U[v_block_R[0]][0][i2][j2];

			//e_Mxor[1] = HM_weight(u_block[0] ^ w_block[0] ^ v_block[0]) % 2; // 0 or 1.
			e_Mxor_R = cLAT_UVW_bro[u_block_R[0]][v_block_R[0]][w_block_R[0]][0];
			//if(e_Mxor[1] >1 ){continue;}

		for(i3 = cLAT_wtcor_min[v_block_R[1]][e_Mxor_R]; i3 <= 8; i3++)
		{
			if(i0 + i1 + i2 + i3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < cLAT_WU_numb[v_block_R[1]][e_Mxor_R][i3]; j3++)
		{
			w_block_R[1] = cLAT_W[v_block_R[1]][e_Mxor_R][i3][j3];
			u_block_R[1] = cLAT_U[v_block_R[1]][e_Mxor_R][i3][j3];
			//e_Mxor[2] = (HM_weight(u_block[1] ^ w_block[1] ^ v_block[1]) + e_Mxor[1]) % 2; // 0 or 1.

			Input_w_R = (w_block_R[0] << 8) | w_block_R[1];  //模加输入右侧掩码
			Input_u_R = (u_block_R[0] << 8) | u_block_R[1];  //模加输入右侧掩码


			//处理本来的输出掩码 左
			Input_tmp_right_L = X1 ^ Input_w_L;
			X_r[1][search_round + 1] = ((Input_tmp_right_L << rol_b) |
					(Input_tmp_right_L >> (blocksize_len-rol_b))) & Bit_Align; //rol left
			X_r[0][search_round + 1] = X_r[1][search_round + 1] ^ Input_u_L;

			//处理本来的输出掩码 右
			Input_tmp_right_R = X3 ^ Input_w_R;
			X_r[3][search_round + 1] = ((Input_tmp_right_R << rol_b) |
					(Input_tmp_right_R >> (blocksize_len-rol_b))) & Bit_Align; //rol left
			X_r[2][search_round + 1] = X_r[3][search_round + 1] ^ Input_u_R;

		wt_l[search_round] = i0 + i1;
		wt_r[search_round] = i2 + i3;
		P_w[search_round] = wt_l[search_round] + wt_r[search_round];  //当前轮的线性相关性重量

//		printf(" search_round N--i0: %d i1:%d i2:%d i3:%d \n",i0,i1,i2,i3);
//		printf(" search_round N--P_w:%d ---w_cmp:%d \n",P_w[search_round],w_cmp);

		if(P_w[search_round] == w_cmp)
		{
			best = 1;
			n_P_bestofR_w[search_round] = Bn_w;

			if(((search_round ) % 3) == 0) //4,7,10,13,16,...
			{
				//L前的输出掩码需要输出
				IN_L_X[search_round/3][0] = X_r[0][search_round + 1];  //记录的是L变换前的值
				IN_L_X[search_round/3][1] = X_r[1][search_round + 1];
				IN_L_X[search_round/3][2] = X_r[2][search_round + 1];
				IN_L_X[search_round/3][3] = X_r[3][search_round + 1];

				L_L = X_r[2][search_round + 1] ^ X_r[3][search_round + 1];
				L_L_tmp = ((L_L >> 8) |
						(L_L << (blocksize_len - 8))) & Bit_Align;//rol right

				X0_L = X_r[2][search_round + 1];
				X1_L = X_r[3][search_round + 1]; //注意L函数的线性传播
				X2_L = X_r[2][search_round + 1] ^ X_r[0][search_round + 1] ^ L_L_tmp;   //
				X3_L = X_r[3][search_round + 1] ^ X_r[1][search_round + 1] ^ L_L_tmp;   //

				X_r[0][search_round +1] = X0_L;
				X_r[1][search_round +1] = X1_L;
				X_r[2][search_round +1] = X2_L;
				X_r[3][search_round +1] = X3_L;

				//printf("0x%04x 0x%04x 0x%04x 0x%04x \n",X0_L,X1_L,X2_L,X3_L);
			}
		}

#if 1
		if( best == 1 )
		{
			return best;
		}
#endif
	}}}}
	}}}}

	return best;
}

u16 SPARX64_linear_Hull_search_entry (u16 search_round)
{
	u16 best = 0;
	u16 i = 0;
	FILE* SPARX_linear_best_Bn;


	SPARX_linear_best_Bn = fopen ("../tmp/sparx64_linear_Bn_wt.xlsx", "a+"); //  "w+"); //
	for(i=1; i <= search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
	{
		fscanf(SPARX_linear_best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
		//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
	}

	if((sc_blocksize != 64) && (sc_blocksize != 128))
	{
		printf("The block size of SPARX should be 64 or 128 bits. \n");
		return 0;
	}


	//设定输入输出掩码
	/* Get the input difference of r rounds.
	printf("Xr0: 0x");  scanf("%x",&X_in_0);
	printf("Xr1: 0x"); 	scanf("%x",&X_in_1);
	printf("Xr2: 0x"); 	scanf("%x",&X_in_2);
	printf("Xr3: 0x");  scanf("%x",&X_in_3);

	printf("Yr0: 0x");  scanf("%x",&Y_out_0);
	printf("Yr1: 0x"); 	scanf("%x",&Y_out_1);
	printf("Yr2: 0x"); 	scanf("%x",&Y_out_2);
	printf("Yr3: 0x");  scanf("%x",&Y_out_3);
*/


	//设定输入输出掩码，和期望的线性相关性重量
	X_in_0 = 0x0080;
	X_in_1 = 0x4001;
	X_in_2 = 0x00c0;
	X_in_3 = 0xf001;

	Y_out_0 = 0x38a8;
	Y_out_1 = 0x2080;
	Y_out_2 = 0x2058;
	Y_out_3 = 0x2040;

	wt_max = 30;
	n_P_bestofR_w[search_round] =28;



	Bn_w = n_P_bestofR_w[search_round];
	//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
	printf("wt_min(:%d)--->wt_max: %d \n", n_P_bestofR_w[search_round], wt_max);
//	scanf("%d",&wt_max);

	rol_a = 7;	/* a */
	rol_b = 2;   /* b */
	// For SPARX64 and SPARX128 both the S-BOX is 16bits.
	blocksize_len = 16;
	Bit_Align = 0xFFFF;
	ValueMax_Align = 0x7FFF;
	V_MSB = 0x8000;

	printf("Constructing SPARX64 cLAT Tables... \n");
	//构造部分的线性相关性近似表cLAT
	ARX_cLAT_construct();
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct SPARX64 cLAT: %.2f seconds.  \n", run_time);

	printf("-----------------------Search SPARX64 Linear Hulls---------------------------\n");
	//搜索SPARX64的 Linear Hull的程序入口
	SPARX64_linear_Hull_round_r(search_round, 1, X_in_0,X_in_1,X_in_2,X_in_3);

	printf("-----------------------Search SPARX64 Linear Hulls END-----------------------\n");
	for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
	{
		prob = prob + (wt_nmu[i] * pow(2,-2*i));
		prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
		printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
	}
	printf("++++++++++++++++++\n ");
	printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
	//printf("input:0x%012x %012x ======>> output:0x%012x %012x \n",input_diff_L,input_diff_R,output_diff_L,output_diff_R);
	printf("0x%04x %04x %04x %04x ======>> 0x%04x %04x %04x %04x \n",
			X_in_0,X_in_1,X_in_2,X_in_3,Y_out_0,Y_out_1,Y_out_2,Y_out_3);

	printf(" wt_min: -%d ===>> wt_max: -%d \n",n_P_bestofR_w[search_round],wt_max);
	printf(" %d Rounds Differential with total %d trails.\n",search_round,count);
	printf(" Probability weight is: %.2Lf \n",prob_w);
	printf("++++++++++++++++++\n ");

	fclose(SPARX_linear_best_Bn);

	time_finish = clock();
	run_time =  (double)(time_finish - time_start) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours. \n", run_time,run_time/60.0,run_time/3600.0 );
	printf("Auto-search END! \n");
	printf("|************************************************************************|\n");

	return best;
}


u16 SPARX64_linear_Hull_round_r(u16 search_round, u16 cur_round,
		u64 X0, u64 X1, u64 X2, u64 X3)
{
	u16 best = 0;

	u64 Input_v_L = 0;  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_L = 0;  //模加输入右侧掩码
	u64 Input_u_L = 0;  //模加输出掩码
	u64 Input_tmp_right_L = 0;  //
	u64 Input_v_R = 0;  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_R = 0;  //模加输入右侧掩码
	u64 Input_u_R = 0;  //模加输出掩码
	u64 Input_tmp_right_R = 0;  //

	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;

	u64 v_block_L[2] = {0}; //按照8比特进行切片
	u64 w_block_L[2] = {0};
	u64 u_block_L[2] = {0};
	u64 v_block_R[2] = {0}; //按照8比特进行切片
	u64 w_block_R[2] = {0};
	u64 u_block_R[2] = {0};

	u64 L_L = 0, L_L_tmp = 0;    //用于线性变换L后的线性掩码变量
	u64 X0_L =0, X1_L=0, X2_L=0, X3_L=0;

	u64 e_Mxor_L = 0; //用于记录M向量的高比特的异或和
	u64 e_Mxor_R = 0; //用于记录M向量的高比特的异或和
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0,i2=0,i3=0;
	u64 j0=0,j1=0,j2=0,j3=0;

//	printf(" search_round r: %d \n", cur_round);

	if(search_round == cur_round)
	{
		best = SPARX64_linear_Hull_round_N(search_round, X0,X1,X2,X3);
		return best;
	}


	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r - n_P_bestofR_w[search_round - cur_round];


	Input_v_L = ((X0 >> rol_a) |
			(X0 << (blocksize_len - rol_a))) & Bit_Align;//rol right
	//m1 //从MSB向LSB的方向进行分块
	v_block_L[0] =  (Input_v_L >> 8) & 0xFF; //MSB 8 bit
	//m0
	v_block_L[1] =  (Input_v_L) & 0xFF; //LSB 8 bit

	Input_v_R = ((X2 >> rol_a) |
			(X2 << (blocksize_len - rol_a))) & Bit_Align;//rol right
	//m1 //从MSB向LSB的方向进行分块
	v_block_R[0] =  (Input_v_R >> 8) & 0xFF; //MSB 8 bit
	//m0
	v_block_R[1] =  (Input_v_R) & 0xFF; //LSB 8 bit

	//bound wt
	wt_cor_bound = cLAT_wtcor_min[v_block_L[0]][0] +
			cLAT_wtcor_min[v_block_L[1]][0] +
			cLAT_wtcor_min[v_block_R[0]][0] +
			cLAT_wtcor_min[v_block_R[1]][0];
//	printf(" Round juge wt_cor_bound:%d  w_cmp:%d \n", wt_cor_bound,w_cmp );
	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

//	printf(" Round  %x %x %x %x \n", X0,X1,X2,X3 );

	for(i0 = cLAT_wtcor_min[v_block_L[0]][0]; i0 < 8; i0++)
	{
		if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
	for(j0=0; j0 < cLAT_WU_numb[v_block_L[0]][0][i0]; j0++)
	{
		w_block_L[0] = cLAT_W[v_block_L[0]][0][i0][j0];
		u_block_L[0] = cLAT_U[v_block_L[0]][0][i0][j0];
		e_Mxor_L = cLAT_UVW_bro[u_block_L[0]][v_block_L[0]][w_block_L[0]][0];
		//if(e_Mxor[1] >1 ){continue;}

	for(i1 = cLAT_wtcor_min[v_block_L[1]][e_Mxor_L]; i1 <= 8; i1++)
	{
		if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cLAT_WU_numb[v_block_L[1]][e_Mxor_L][i1]; j1++)
	{
		w_block_L[1] = cLAT_W[v_block_L[1]][e_Mxor_L][i1][j1];
		u_block_L[1] = cLAT_U[v_block_L[1]][e_Mxor_L][i1][j1];
		//e_Mxor[2] = (HM_weight(u_block[1] ^ w_block[1] ^ v_block[1]) + e_Mxor[1]) % 2; // 0 or 1.

		Input_w_L = (w_block_L[0] << 8) | w_block_L[1];  //模加输入右侧掩码
		Input_u_L = (u_block_L[0] << 8) | u_block_L[1];  //模加输入右侧掩码


////////////////
		for(i2 = cLAT_wtcor_min[v_block_R[0]][0]; i2 < 8; i2++)
		{
			if(i0 + i1 + i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j2=0; j2 < cLAT_WU_numb[v_block_R[0]][0][i2]; j2++)
		{
			w_block_R[0] = cLAT_W[v_block_R[0]][0][i2][j2];
			u_block_R[0] = cLAT_U[v_block_R[0]][0][i2][j2];

			//e_Mxor[1] = HM_weight(u_block[0] ^ w_block[0] ^ v_block[0]) % 2; // 0 or 1.
			e_Mxor_R = cLAT_UVW_bro[u_block_R[0]][v_block_R[0]][w_block_R[0]][0];
			//if(e_Mxor[1] >1 ){continue;}

		for(i3 = cLAT_wtcor_min[v_block_R[1]][e_Mxor_R]; i3 <= 8; i3++)
		{
			if(i0 + i1 + i2 + i3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < cLAT_WU_numb[v_block_R[1]][e_Mxor_R][i3]; j3++)
		{
			w_block_R[1] = cLAT_W[v_block_R[1]][e_Mxor_R][i3][j3];
			u_block_R[1] = cLAT_U[v_block_R[1]][e_Mxor_R][i3][j3];
			//e_Mxor[2] = (HM_weight(u_block[1] ^ w_block[1] ^ v_block[1]) + e_Mxor[1]) % 2; // 0 or 1.

			Input_w_R = (w_block_R[0] << 8) | w_block_R[1];  //模加输入右侧掩码
			Input_u_R = (u_block_R[0] << 8) | u_block_R[1];  //模加输入右侧掩码

///
			//处理本来的输出掩码 左
			Input_tmp_right_L = X1 ^ Input_w_L;
			X_r[1][cur_round + 1] = ((Input_tmp_right_L << rol_b) |
					(Input_tmp_right_L >> (blocksize_len-rol_b))) & Bit_Align; //rol left
			X_r[0][cur_round + 1] = X_r[1][cur_round + 1] ^ Input_u_L;

			//处理本来的输出掩码 右
			Input_tmp_right_R = X3 ^ Input_w_R;
			X_r[3][cur_round + 1] = ((Input_tmp_right_R << rol_b) |
					(Input_tmp_right_R >> (blocksize_len-rol_b))) & Bit_Align; //rol left
			X_r[2][cur_round + 1] = X_r[3][cur_round + 1] ^ Input_u_R;

		wt_l[cur_round] = i0 + i1;
		wt_r[cur_round] = i2 + i3;
		P_w[cur_round] = wt_l[cur_round] + wt_r[cur_round];  //当前轮的线性相关性重量

		if(((cur_round) % 3) == 0) //下一轮为 4,7,10,13,16,...
		{
			//L前的输出掩码需要输出
			IN_L_X[cur_round/3][0] = X_r[0][cur_round + 1];  //记录的是L变换前的值
			IN_L_X[cur_round/3][1] = X_r[1][cur_round + 1];
			IN_L_X[cur_round/3][2] = X_r[2][cur_round + 1];
			IN_L_X[cur_round/3][3] = X_r[3][cur_round + 1];

			L_L = X_r[2][cur_round + 1] ^ X_r[3][cur_round + 1];
			L_L_tmp = ((L_L >> 8) |	(L_L << (8))) & Bit_Align;//rol right blocksize_len=16

			X0_L = X_r[2][cur_round + 1];
			X1_L = X_r[3][cur_round + 1]; //注意L函数的线性传播
			X2_L = X_r[2][cur_round + 1] ^ X_r[0][cur_round + 1] ^ L_L_tmp;  //注意三叉口分支
			X3_L = X_r[3][cur_round + 1] ^ X_r[1][cur_round + 1] ^ L_L_tmp;   //

			X_r[0][cur_round + 1] = X0_L;
			X_r[1][cur_round + 1] = X1_L; //
			X_r[2][cur_round + 1] = X2_L;
			X_r[3][cur_round + 1] = X3_L;
		}

		//跳转 下一轮
		best = SPARX64_linear_Hull_round_r(search_round,cur_round + 1,
				X_r[0][cur_round + 1],X_r[1][cur_round + 1],
				X_r[2][cur_round + 1],X_r[3][cur_round + 1]);
	}}}}
	}}}}

	return best;
}

u16 SPARX64_linear_Hull_round_N(u16 search_round, u64 X0, u64 X1, u64 X2, u64 X3)
{
	u16 best = 0;

	u64 Input_v_L = 0;  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_L = 0;  //模加输入右侧掩码
	u64 Input_u_L = 0;  //模加输出掩码
	u64 Input_tmp_right_L = 0;  //
	u64 Input_v_R = 0;  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_R = 0;  //模加输入右侧掩码
	u64 Input_u_R = 0;  //模加输出掩码
	u64 Input_tmp_right_R = 0;  //

	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;

	u64 v_block_L[2] = {0}; //按照8比特进行切片
	u64 w_block_L[2] = {0};
	u64 u_block_L[2] = {0};
	u64 v_block_R[2] = {0}; //按照8比特进行切片
	u64 w_block_R[2] = {0};
	u64 u_block_R[2] = {0};

	u64 L_L = 0, L_L_tmp = 0;    //用于线性变换L后的线性掩码变量
	u64 X0_L =0, X1_L=0, X2_L=0, X3_L=0;

	u64 e_Mxor_L = 0; //用于记录M向量的高比特的异或和
	u64 e_Mxor_R = 0; //用于记录M向量的高比特的异或和
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0,i2=0,i3=0;
	u64 j0=0,j1=0,j2=0,j3=0;

//	printf(" search_round N \n");

	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r;

	if((X0==0) && (X1==0) && (X2==0) && (X3==0))
	{
		return 0;
	}

	Input_v_L = ((X0 >> rol_a) |
			(X0 << (blocksize_len - rol_a))) & Bit_Align;//rol right
	//m1 //从MSB向LSB的方向进行分块
	v_block_L[0] =  (Input_v_L >> 8) & 0xFF; //MSB 8 bit
	//m0
	v_block_L[1] =  (Input_v_L) & 0xFF; //LSB 8 bit

	Input_v_R = ((X2 >> rol_a) |
			(X2 << (blocksize_len - rol_a))) & Bit_Align;//rol right
	//m1 //从MSB向LSB的方向进行分块
	v_block_R[0] =  (Input_v_R >> 8) & 0xFF; //MSB 8 bit
	//m0
	v_block_R[1] =  (Input_v_R) & 0xFF; //LSB 8 bit


	//bound wt
	wt_cor_bound = cLAT_wtcor_min[v_block_L[0]][0] +
			cLAT_wtcor_min[v_block_L[1]][0] +
			cLAT_wtcor_min[v_block_R[0]][0] +
			cLAT_wtcor_min[v_block_R[1]][0];
//	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
//		return 0;
	}


	for(i0 = cLAT_wtcor_min[v_block_L[0]][0]; i0 < 8; i0++)
	{
		if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
	for(j0=0; j0 < cLAT_WU_numb[v_block_L[0]][0][i0]; j0++)
	{
		w_block_L[0] = cLAT_W[v_block_L[0]][0][i0][j0];
		u_block_L[0] = cLAT_U[v_block_L[0]][0][i0][j0];

		//e_Mxor[1] = HM_weight(u_block[0] ^ w_block[0] ^ v_block[0]) % 2; // 0 or 1.
		e_Mxor_L = cLAT_UVW_bro[u_block_L[0]][v_block_L[0]][w_block_L[0]][0];
		//if(e_Mxor[1] >1 ){continue;}

	for(i1 = cLAT_wtcor_min[v_block_L[1]][e_Mxor_L]; i1 <= 8; i1++)
	{
		if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cLAT_WU_numb[v_block_L[1]][e_Mxor_L][i1]; j1++)
	{
		w_block_L[1] = cLAT_W[v_block_L[1]][e_Mxor_L][i1][j1];
		u_block_L[1] = cLAT_U[v_block_L[1]][e_Mxor_L][i1][j1];
		//e_Mxor[2] = (HM_weight(u_block[1] ^ w_block[1] ^ v_block[1]) + e_Mxor[1]) % 2; // 0 or 1.

//		Input_w_L = (w_block_L[0] << 8) | w_block_L[1];  //模加输入右侧掩码
//		Input_u_L = (u_block_L[0] << 8) | u_block_L[1];  //模加输入右侧掩码

///
		for(i2 = cLAT_wtcor_min[v_block_R[0]][0]; i2 < 8; i2++)
		{
			if(i0 + i1 + i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j2=0; j2 < cLAT_WU_numb[v_block_R[0]][0][i2]; j2++)
		{
			w_block_R[0] = cLAT_W[v_block_R[0]][0][i2][j2];
			u_block_R[0] = cLAT_U[v_block_R[0]][0][i2][j2];
			e_Mxor_R = cLAT_UVW_bro[u_block_R[0]][v_block_R[0]][w_block_R[0]][0];

		for(i3 = cLAT_wtcor_min[v_block_R[1]][e_Mxor_R]; i3 <= 8; i3++)
		{
			if(i0 + i1 + i2 + i3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < cLAT_WU_numb[v_block_R[1]][e_Mxor_R][i3]; j3++)
		{
			w_block_R[1] = cLAT_W[v_block_R[1]][e_Mxor_R][i3][j3];
			u_block_R[1] = cLAT_U[v_block_R[1]][e_Mxor_R][i3][j3];
			//e_Mxor[2] = (HM_weight(u_block[1] ^ w_block[1] ^ v_block[1]) + e_Mxor[1]) % 2; // 0 or 1.

			Input_w_L = (w_block_L[0] << 8) | w_block_L[1];  //模加输入右侧掩码
			Input_u_L = (u_block_L[0] << 8) | u_block_L[1];  //模加输入右侧掩码

			Input_w_R = (w_block_R[0] << 8) | w_block_R[1];  //模加输入右侧掩码
			Input_u_R = (u_block_R[0] << 8) | u_block_R[1];  //模加输入右侧掩码


			//处理本来的输出掩码 左
			Input_tmp_right_L = X1 ^ Input_w_L;
			X_r[1][search_round + 1] = ((Input_tmp_right_L << rol_b) |
					(Input_tmp_right_L >> (blocksize_len-rol_b))) & Bit_Align; //rol left
			X_r[0][search_round + 1] = X_r[1][search_round + 1] ^ Input_u_L;

			//处理本来的输出掩码 右
			Input_tmp_right_R = X3 ^ Input_w_R;
			X_r[3][search_round + 1] = ((Input_tmp_right_R << rol_b) |
					(Input_tmp_right_R >> (blocksize_len-rol_b))) & Bit_Align; //rol left
			X_r[2][search_round + 1] = X_r[3][search_round + 1] ^ Input_u_R;

		wt_l[search_round] = i0 + i1;
		wt_r[search_round] = i2 + i3;
		P_w[search_round] = wt_l[search_round] + wt_r[search_round];  //当前轮的线性相关性重量


		if(((search_round ) % 3) == 0) //4,7,10,13,16,...
		{
			//L前的输出掩码需要输出
			IN_L_X[search_round/3][0] = X_r[0][search_round + 1];  //记录的是L变换前的值
			IN_L_X[search_round/3][1] = X_r[1][search_round + 1];
			IN_L_X[search_round/3][2] = X_r[2][search_round + 1];
			IN_L_X[search_round/3][3] = X_r[3][search_round + 1];

			L_L = X_r[2][search_round + 1] ^ X_r[3][search_round + 1];
			L_L_tmp = ((L_L >> 8) |
					(L_L << (blocksize_len - 8))) & Bit_Align;//rol right

			X0_L = X_r[2][search_round + 1];
			X1_L = X_r[3][search_round + 1];
			X2_L = X_r[0][search_round + 1] ^ X_r[2][search_round + 1] ^ L_L_tmp;   //注意三叉口分支
			X3_L = X_r[1][search_round + 1] ^ X_r[3][search_round + 1] ^ L_L_tmp;   //

			X_r[0][search_round +1] = X0_L;
			X_r[1][search_round +1] = X1_L;
			X_r[2][search_round +1] = X2_L;
			X_r[3][search_round +1] = X3_L;

			//printf("0x%04x 0x%04x 0x%04x 0x%04x \n",X0_L,X1_L,X2_L,X3_L);
		}

//		printf("YYY: 0x%04x 0x%04x 0x%04x 0x%04x  Bn:w %d \n",
//				X_r[0][search_round + 1],X_r[1][search_round + 1],X_r[2][search_round + 1],X_r[3][search_round + 1],
//				p_sumof_r + P_w[search_round]);

		if(X_r[0][search_round +1]  !=  Y_out_0 )
		{
			continue;
		}
		if(X_r[1][search_round +1]  !=  Y_out_1 )
		{
			continue;
		}
		if(X_r[2][search_round +1]  !=  Y_out_2 )
		{
			continue;
		}
		if(X_r[3][search_round +1]  !=  Y_out_3 )
		{
			continue;
		}

		count++;
		Bn_w = p_sumof_r + P_w[search_round] ;
		printf("count: %d    weight: %d \n",count,Bn_w);
		wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;

	}}}}
	}}}}

	return best;
}





u16 SPARX128_linear_trail_search_entry (u16 search_round)
{
	u16 best = 0;
	u16 i = 0;
	FILE* SPARX128_linear_best_Bn;


	SPARX128_linear_best_Bn = fopen ("../tmp/sparx128_linear_Bn_wt.xlsx", "a+"); //  "w+"); //
	if((sc_blocksize != 64) && (sc_blocksize != 128))
	{
		printf("The block size of SPARX should be 64 or 128 bits. \n");
		return 0;
	}

	rol_a = 7;	/* a */
	rol_b = 2;   /* b */

	// For SPARX64 and SPARX128 both the S-BOX is 16bits.
	blocksize_len = 16;
	Bit_Align = 0xFFFF;
	ValueMax_Align = 0x7FFF;
	V_MSB = 0x8000;

	printf("Constructing SPARX-128 cLAT Tables... \n");
	//构造部分的线性相关性近似表cLAT
	ARX_cLAT_construct();
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct SPARX-128 cLAT: %.2f seconds.  \n", run_time);


	Bn_w = 0;
	if(search_round > 3)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(SPARX128_linear_best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		Bn_w = n_P_bestofR_w[search_round -1] - 1;
	}

		Bn_w = 23;  //直接设定开始的概率重量,快速达到期望的概率重量
		do
		{
			Bn_w = Bn_w + 1;
			printf("Searching SPARX-128 Bn_w: %d \n", Bn_w);

			// Search Entry.
			//best = SPARX128_linear_R1_wt(search_round);  //效率低
			best = SPARX128_linear_trail_R1(search_round, 0);  //效率稍微高点

/*
			//向前扩展1轮
			IN_X_Mask[0] = 0x0000;
			IN_X_Mask[1] = 0x0000;
			IN_X_Mask[2] = 0x2c10;
			IN_X_Mask[3] = 0x2010;
			IN_X_Mask[4] = 0x2c00;
			IN_X_Mask[5] = 0x2000;
			IN_X_Mask[6] = 0x0010;
			IN_X_Mask[7] = 0x0010;
			best = SPARX128_linear_trail_N(1, IN_X_Mask);
*/

			//给第3轮的输入掩码
			u16 mask_3_Xr[8] ={0};
			mask_3_Xr[0] = 0x0000;
			mask_3_Xr[1] = 0x0000;
			mask_3_Xr[2] = 0x2070;
			mask_3_Xr[3] = 0x2060;
			mask_3_Xr[4] = 0x0000;
			mask_3_Xr[5] = 0x0000;
			mask_3_Xr[6] = 0x0000;
			mask_3_Xr[7] = 0x0000;
			P_w[1] = 0;
			P_w[2] = 1;
			best = SPARX128_linear_trail_r(search_round, 3, mask_3_Xr);




			time_Round = clock();
			run_time =  (time_Round - time_ARX_cLAT) / CLOCKS_PER_SEC;
			printf("Time: %.2f seconds.  \n", run_time);
		}while(Bn_w !=  n_P_bestofR_w[search_round]);   //end conditions.

		print_SPARX_128_resoult(search_round);

		time_finish = clock();
		run_time = (double)(time_finish - time_ARX_cLAT) / CLOCKS_PER_SEC;
		printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours == %.2f days. \n", run_time,run_time/60.0,run_time/3600.0,run_time/86400.0 );
		printf("Auto-search END! \n");
		printf("|************************************************************************|\n");
		fclose(SPARX128_linear_best_Bn);

	return best;
}

u16 SPARX128_linear_R1_wt(u16 search_round)
{
	u16 best = 0;
	u16 wt_round_1 = 0;
	u16 wt_Block_0 = 0,wt_Block_1 = 0,wt_Block_2 = 0,wt_Block_3 = 0;
	u16 i = 0;

	///////////////////round 1 entry////////////////////
	if( search_round < 3)
	{
		return 0;
	}
/*
	R1_wt_part[0] = 1;
	R1_wt_part[1] = 0;
	R1_wt_part[2] = 0;
	R1_wt_part[3] = 0;

	P_w[1] = 1;
	best = SPARX128_linear_trail_R1(search_round,0);
*/
              // 限定SPARX-128的首轮的概率重量
	for(wt_round_1 = 0; wt_round_1 < 16; wt_round_1++)  //0::n-1  //各个分块最多15比特的概率重量:61
	{
		// thr_d : the bits number of alpha/beta/gamma that the position not equal at the same time.
		if ((wt_round_1 + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::
		}
		P_w[1] = wt_round_1;

		for(wt_Block_0=0; wt_Block_0 <= wt_round_1; wt_Block_0++) //15
		{
			for(wt_Block_1=0; wt_Block_1 <= wt_round_1; wt_Block_1++) //15
			{
				for(wt_Block_2=0; wt_Block_2 <= wt_round_1; wt_Block_2++) //15
				{
					for(wt_Block_3=0; wt_Block_3 <= wt_round_1; wt_Block_3++)//15
					{
						if((wt_Block_0 + wt_Block_1 + wt_Block_2 + wt_Block_3) == wt_round_1)
						{
							//printf("wt_round_1 1 \n");
							R1_wt_part[0] = wt_Block_0;
							R1_wt_part[1] = wt_Block_1;
							R1_wt_part[2] = wt_Block_2;
							R1_wt_part[3] = wt_Block_3;

							//best = SPARX128_linear_trail_R1(search_round,0);
							best = SPARX128_linear_R2_wt( search_round );
							if(best== 1 )
							{
								for(i=0; i<4; i++)
								{
									wt_block[i][1] = R1_wt_part[i];
								}
								return 1;
							}
						}
					}
				}
			}
		}
	}
	return best;
}

u16 SPARX128_linear_R2_wt(u16 search_round)
{
	u16 best = 0;
	u16 wt_round_2 = 0;
	u16 wt_Block_0 = 0,wt_Block_1 = 1,wt_Block_2 = 0,wt_Block_3 = 0;
	u16 i = 0;

	///////////////////round 1 entry////////////////////
	if( search_round < 3)
	{
		return 0;
	}

/*
	R2_wt_part[0] = 2;
	R2_wt_part[1] = 0;
	R2_wt_part[2] = 0;
	R2_wt_part[3] = 0;

	P_w[2] = 2;
	best = SPARX128_linear_trail_R2( search_round, 0 );
*/
	// 限定SPARX-128的首轮的概率重量
	for(wt_round_2 = 0; wt_round_2 < 16; wt_round_2++)  //0::n-1  //各个分块最多15比特的概率重量:61
	{
		// thr_d : the bits number of alpha/beta/gamma that the position not equal at the same time.
		if ((P_w[1] + wt_round_2 + n_P_bestofR_w[search_round - 2]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::
		}
		P_w[2] = wt_round_2;

		for(wt_Block_0=0; wt_Block_0 <= wt_round_2; wt_Block_0++) //15
		{
			for(wt_Block_1=0; wt_Block_1 <= wt_round_2; wt_Block_1++) //15
			{
				for(wt_Block_2=0; wt_Block_2 <= wt_round_2; wt_Block_2++) //15
				{
					for(wt_Block_3=0; wt_Block_3 <= wt_round_2; wt_Block_3++)//15
					{
						if((wt_Block_0 + wt_Block_1 + wt_Block_2 + wt_Block_3) == wt_round_2)
						{
							//printf("TTTTTTEST 1 \n");
							R2_wt_part[0] = wt_Block_0;
							R2_wt_part[1] = wt_Block_1;
							R2_wt_part[2] = wt_Block_2;
							R2_wt_part[3] = wt_Block_3;

							//best = SPARX128_linear_trail_R2( search_round, 0 );
							best = SPARX128_linear_trail_R1(search_round,0);
							if(best== 1)
							{
								for(i=0; i<4; i++)
								{
									wt_block[i][2] = R2_wt_part[i];
								}
								return 1;
							}
						}
					}
				}
			}
		}
	}
	return best;
}



u16 SPARX128_linear_trail_R1 (u16 search_round, u16 part)
{
	u16 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 part_wt = 0;
	u16 sum_part_wt =0;
	u16 part_i = 0;

	u64 M0 = 0;
	u64 N0 = blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;

	//printf(" L1 \n");
	///////////////////round 1 entry/////////////////////
	if( search_round < 3)
	{
		return best;
	}
/*
	if(part >= 4)
	{
		best = SPARX128_linear_trail_R2(search_round, 0);
		return best;
	}
*/

	if(part >= 4)
	{
		for(part_i=0; part_i< 4; part_i++)
		{
			sum_part_wt += R1_mask_UVW_wt[part_i];
		}
		P_w[1] = sum_part_wt;
		best = SPARX128_linear_trail_R2(search_round, 0);
		return best;
	}
	else
	{
		if(part>4)
		{
			return 0;
		}
		else
		{
			for(part_i=0; part_i< part; part_i++)
			{
				sum_part_wt += R1_mask_UVW_wt[part_i];
			}
		}
	}



//	part_wt = R1_wt_part[part];
	for(part_wt = 0; part_wt < 1 ;part_wt++)  //0::n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if( (sum_part_wt + part_wt + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}

		M0 = part_wt;  //
		R1_mask_UVW_wt[part] = M0;
		//P_w[1] = M0; //相关性重量的记录数组

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			R1_mask_UVW[part*3]    = Input_u;
			R1_mask_UVW[part*3 +1] = Input_v;
			R1_mask_UVW[part*3 +2] = Input_w;

			//直接跳转到第1轮各个部分的内部构造
			best = SPARX128_linear_trail_R1(search_round,part+1);

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;

			R1_mask_UVW[part*3]    = Input_u;
			R1_mask_UVW[part*3 +1] = Input_v;
			R1_mask_UVW[part*3 +2] = Input_w;

			//直接跳转到第1轮各个部分的内部构造
			best = SPARX128_linear_trail_R1(search_round,part+1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			//直接跳转到第1轮各个部分的内部构造
			best = SPARX128_R1_mask_Last(search_round,
					part, part_wt,
					C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif
////////////////////产生后续的模式////////////////////
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if(A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHANGE_SPARX128R1;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHANGE_SPARX128R1;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHANGE_SPARX128R1;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHANGE_SPARX128R1;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHANGE_SPARX128R1;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHANGE_SPARX128R1;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHANGE_SPARX128R1;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
CHANGE_SPARX128R1:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}

///////////////输出其它的分布模式/////////////////
				//直接跳转到第1轮各个部分的内部构造
				best = SPARX128_R1_mask_Last(search_round,
						part, part_wt,
						C0);

#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}

	return best;
}



u16 SPARX128_R1_mask_Last(u16 search_round,
		u16 part, u16 part_wt,
		char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

		//跳转到高比特分析
		best = SPARX128_R1_mask_Middle(search_round,
				Input_u, Input_v, Input_w,
				part,part_wt, Corr_inc, posi,
				1,Fwt );;
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = SPARX128_R1_mask_Middle(search_round,
				Input_u, Input_v, Input_w,
				part, part_wt, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = SPARX128_R1_mask_Middle(search_round,
					Input_u, Input_v, Input_w,
					part,part_wt, Corr_inc, posi,
					1,Fwt );

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}



u16 SPARX128_R1_mask_Middle(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 part, u16 part_wt, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= part_wt ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = SPARX128_R1_mask_MSB(search_round,
				tmp_U,tmp_V,tmp_W,
				part, part_wt, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

				if(current_index < blocksize_len -2)
				{
					//跳转到高比特分析
					best = SPARX128_R1_mask_Middle(search_round,
							tmp_U, tmp_V, tmp_W,
							part, part_wt, Corr_tmp_inc, posi,
							current_index + 1, Fwt);
				}
				else
				{
					best = SPARX128_R1_mask_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							part, part_wt, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//跳转到高比特分析
				best = SPARX128_R1_mask_Middle(search_round,
						Input_u, Input_v, Input_w,
						part, part_wt, Corr_tmp_inc, posi,
						current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = SPARX128_R1_mask_Middle(search_round,
							Input_u, Input_v, Input_w,
							part, part_wt, Corr_inc, posi,
							current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = SPARX128_R1_mask_Middle(search_round,
							Input_u, Input_v, Input_w,
							part, part_wt, Corr_tmp_inc +1, posi,
							current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 SPARX128_R1_mask_MSB(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 part, u16 part_wt, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;

/*
	if(Corr_tmp_inc > part_wt)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
	{
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			R1_mask_UVW[part*3]    = tmp_U;
			R1_mask_UVW[part*3 +1] = tmp_V;
			R1_mask_UVW[part*3 +2] = tmp_W;
			//跳转 第1轮的下一个块
			best = SPARX128_linear_trail_R1(search_round, part+1);
		}
		else
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			R1_mask_UVW[part*3]    = Input_u;
			R1_mask_UVW[part*3 +1] = Input_v;
			R1_mask_UVW[part*3 +2] = Input_w;
			//跳转 第1轮的下一个块
			best = SPARX128_linear_trail_R1(search_round, part+1);
		}
	}
	else  // Corr_tmp_inc == part_wt 搜索的当前wt与期望的相关性重量相等
	{
		if( (posi[part_wt]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0; //!= >
		{
			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
				best = SPARX128_R1_mask_MSB(search_round,
						tmp_U,tmp_V,tmp_W,
						part, part_wt, Corr_tmp_inc,posi,
						current_index +1, Fwt);
			}
			else
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
				best = SPARX128_R1_mask_MSB(search_round,
						Input_u, Input_v, Input_w,
						part, part_wt, Corr_tmp_inc, posi,
						current_index +1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
	}
		}
		else  //(posi[part_wt]-1) == current_index
		{

		if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_B_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_B_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_B_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW[i+1]位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				R1_mask_UVW[part*3]    = Input_u;
				R1_mask_UVW[part*3 +1] = Input_v;
				R1_mask_UVW[part*3 +2] = Input_w;

				//跳转 第1轮的下一个块
				best = SPARX128_linear_trail_R1(search_round,part+1);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
			}
		}
		else
		{
			// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_A_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_A_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_A_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				R1_mask_UVW[part*3]    = Input_u;
				R1_mask_UVW[part*3 +1] = Input_v;
				R1_mask_UVW[part*3 +2] = Input_w;

	//			printf(" SPARX128_R1_mask_MSB 3:%d   \n", current_index);
				//跳转 第1轮的下一个块
				best = SPARX128_linear_trail_R1(search_round,part+1);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return best;
}
#endif
	}}
		}}
	return best;
*/


	if( (posi[part_wt]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
	{
		//Fwt = 0;//当前M向量该比特位无相关性重量
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
			//Input_u = tmp_U | (0 << current_index); //该位置置0
			//Input_v = tmp_V | (0 << current_index); //该位置置0
			//Input_w = tmp_W | (0 << current_index); //该位置置0

			if(current_index <= blocksize_len-2)
			{
				//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
				best = SPARX128_R1_mask_MSB(search_round,
						tmp_U,tmp_V,tmp_W,
						part, part_wt, Corr_tmp_inc,posi,
						current_index +1, Fwt);
			}
			else //直接跳转到第1轮的右侧
			{
				R1_mask_UVW[part*3]    = tmp_U;
				R1_mask_UVW[part*3 +1] = tmp_V;
				R1_mask_UVW[part*3 +2] = tmp_W;

				//跳转 第1轮的下一个块
				best = SPARX128_linear_trail_R1(search_round, part+1);
			}
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
			best = SPARX128_R1_mask_MSB(search_round,
					Input_u, Input_v, Input_w,
					part, part_wt, Corr_tmp_inc,posi,
					current_index +1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
	}
	else //////当前M向量该比特位you相关性重量, M_i = 1; (posi[Corr_1]-1) == current_index .
	{
		//Fwt = 1;//当前M向量该比特位you相关性重量
		//Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

		if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_B_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_B_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_B_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				R1_mask_UVW[part*3]    = Input_u;
				R1_mask_UVW[part*3 +1] = Input_v;
				R1_mask_UVW[part*3 +2] = Input_w;

				//跳转 第1轮的下一个块
				best = SPARX128_linear_trail_R1(search_round,part+1);

#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
			}
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_A_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_A_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_A_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				R1_mask_UVW[part*3]    = Input_u;
				R1_mask_UVW[part*3 +1] = Input_v;
				R1_mask_UVW[part*3 +2] = Input_w;

				//跳转 第1轮的下一个块
				best = SPARX128_linear_trail_R1(search_round,part+1);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return best;
}
#endif
			}
		}
	}
	return best;

}


u16 SPARX128_linear_trail_R2 (u16 search_round, u16 part)
{
	u16 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 part_wt = 0;
	u16 sum_part_wt =0;
	u16 part_i = 0;

	//给第3轮的输入掩码
	u16 mask_3_Xr[8] ={0};
	u16 tmp_right_L[4] = {0};

	u64 M0 = 0;
	u64 N0 = blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;


	///////////////////round 2 entry/////////////////////
	if( search_round < 3)
	{
		return best;
	}


	if(part >= 4)
	{
		for(part_i=0; part_i< 4; part_i++)
		{
			sum_part_wt += R2_mask_UVW_wt[part_i];
		}
		P_w[2] = sum_part_wt;


		//处理sparx128的前两轮的输入输出掩码
		//part 0
		X_128_r[0][2] = ((R2_mask_UVW[1] << rol_a)
					| (R2_mask_UVW[1] >> (blocksize_len-rol_a))) & Bit_Align;//rol left
		X_128_r[1][2] = R1_mask_UVW[0] ^ X_128_r[0][2];
		tmp_right_L[0] = R2_mask_UVW[2] ^ X_128_r[1][2];
		X_128_r[1][3] = ((tmp_right_L[0] << rol_b)
					| (tmp_right_L[0] >> (blocksize_len-rol_b))) & Bit_Align;//rol left
		X_128_r[0][3] = X_128_r[1][3] ^ R2_mask_UVW[0];

		//part 1
		X_128_r[2][2] = ((R2_mask_UVW[4] << rol_a)
					| (R2_mask_UVW[4] >> (blocksize_len-rol_a))) & Bit_Align;//rol left
		X_128_r[3][2] = R1_mask_UVW[3] ^ X_128_r[2][2];
		tmp_right_L[1] = R2_mask_UVW[5] ^ X_128_r[3][2];
		X_128_r[3][3] = ((tmp_right_L[1] << rol_b)
					| (tmp_right_L[1] >> (blocksize_len-rol_b))) & Bit_Align;//rol left
		X_128_r[2][3] = X_128_r[3][3] ^ R2_mask_UVW[3];

		//part 2
		X_128_r[4][2] = ((R2_mask_UVW[7] << rol_a)
					| (R2_mask_UVW[7] >> (blocksize_len-rol_a))) & Bit_Align;//rol left
		X_128_r[5][2] = R1_mask_UVW[6] ^ X_128_r[4][2];
		tmp_right_L[2] = R2_mask_UVW[8] ^ X_128_r[5][2];
		X_128_r[5][3] = ((tmp_right_L[2] << rol_b)
					| (tmp_right_L[2] >> (blocksize_len-rol_b))) & Bit_Align;//rol left
		X_128_r[4][3] = X_128_r[5][3] ^ R2_mask_UVW[6];

		//part 3
		X_128_r[6][2] = ((R2_mask_UVW[10] << rol_a)
					| (R2_mask_UVW[10] >> (blocksize_len-rol_a))) & Bit_Align;//rol left
		X_128_r[7][2] = R1_mask_UVW[9] ^ X_128_r[6][2];
		tmp_right_L[3] = R2_mask_UVW[11] ^ X_128_r[7][2];
		X_128_r[7][3] = ((tmp_right_L[3] << rol_b)
					| (tmp_right_L[3] >> (blocksize_len-rol_b))) & Bit_Align;//rol left
		X_128_r[6][3] = X_128_r[7][3] ^ R2_mask_UVW[9];

		for(i=0;i<8;i++)
		{
			mask_3_Xr[i] = X_128_r[i][3];
		}
		best = SPARX128_linear_trail_r(search_round, 3, mask_3_Xr);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW,以及SPARX128的前两轮的输入输出掩码和各个分块的相关性重量
	//第1轮的X0
	X_128_r[0][1] = ((R1_mask_UVW[1] << rol_a)  |
			(R1_mask_UVW[1] >> (blocksize_len-rol_a))) & Bit_Align;//rol left
	//第1轮的X1
	X_128_r[1][1] = ((X_128_r[1][2] >> rol_b) |
			(X_128_r[1][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
	X_128_r[1][1] = R1_mask_UVW[2] ^ X_128_r[1][1];

	//第1轮的X2
	X_128_r[2][1] = ((R1_mask_UVW[4] << rol_a)  |
			(R1_mask_UVW[4] >> (blocksize_len-rol_a))) & Bit_Align;//rol left
	//第1轮的X3
	X_128_r[3][1] = ((X_128_r[3][2] >> rol_b) |
			(X_128_r[3][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
	X_128_r[3][1] = R1_mask_UVW[5] ^ X_128_r[3][1];


	//第1轮的X4
	X_128_r[4][1] = ((R1_mask_UVW[7] << rol_a)  |
			(R1_mask_UVW[7] >> (blocksize_len-rol_a))) & Bit_Align;//rol left
	//第1轮的X5
	X_128_r[5][1] = ((X_128_r[5][2] >> rol_b) |
			(X_128_r[5][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
	X_128_r[5][1] = R1_mask_UVW[8] ^ X_128_r[5][1];

	//第1轮的X6
	X_128_r[6][1] = ((R1_mask_UVW[10] << rol_a)  |
			(R1_mask_UVW[10] >> (blocksize_len-rol_a))) & Bit_Align;//rol left
	//第1轮的X7
	X_128_r[7][1] = ((X_128_r[7][2] >> rol_b) |
			(X_128_r[7][2] << (blocksize_len - rol_b))) & Bit_Align;//rol right
	X_128_r[7][1] = R1_mask_UVW[11] ^ X_128_r[7][1];

	for(i=0; i<4; i++)
	{
		wt_block[i][1] = R1_mask_UVW_wt[i];
		wt_block[i][2] = R2_mask_UVW_wt[i];
	}

	return best;
}
else
{
	return 0;
}
#endif
	}
	else
	{
		if(part>4)
		{
			return 0;
		}
		else
		{
			for(part_i=0; part_i< part; part_i++)
			{
				sum_part_wt += R2_mask_UVW_wt[part_i];
			}
		}
	}

//	part_wt = R2_wt_part[part];
	for(part_wt = 0; part_wt < 2; part_wt++)  //0::n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if( (P_w[1] + sum_part_wt + part_wt + n_P_bestofR_w[search_round - 2]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}

		M0 = part_wt;  //
		R2_mask_UVW_wt[part] = M0;
		//P_w[1] = M0; //相关性重量的记录数组

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			R2_mask_UVW[part*3]    = Input_u;
			R2_mask_UVW[part*3 +1] = Input_v;
			R2_mask_UVW[part*3 +2] = Input_w;

			//直接跳转到第1轮各个部分的内部构造
			best = SPARX128_linear_trail_R2(search_round,part+1);

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;

			R2_mask_UVW[part*3]    = Input_u;
			R2_mask_UVW[part*3 +1] = Input_v;
			R2_mask_UVW[part*3 +2] = Input_w;

			//直接跳转到第1轮各个部分的内部构造
			best = SPARX128_linear_trail_R2(search_round, part+1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

//			printf(" SPARX128_linear_trail_R2  Mode 1 \n");
			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			//直接跳转到第2轮各个部分的内部构造
			best = SPARX128_R2_mask_Last(search_round,
					part, part_wt,
					C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHANGE_SPARX128R2;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHANGE_SPARX128R2;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHANGE_SPARX128R2;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHANGE_SPARX128R2;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHANGE_SPARX128R2;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHANGE_SPARX128R2;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHANGE_SPARX128R2;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
	CHANGE_SPARX128R2:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}

//				printf(" SPARX128_linear_trail_R2  Mode n \n");
///////////////输出其它的分布模式/////////////////
				//直接跳转到第2轮各个部分的内部构造
				best = SPARX128_R2_mask_Last(search_round,
						part, part_wt,
						C0);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}

	return best;
}


u16 SPARX128_R2_mask_Last(u16 search_round,
		u16 part, u16 part_wt,
		char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

//	printf(" SPARX128_R2_mask_Last   OK \n");


	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

		//跳转到高比特分析
		best = SPARX128_R2_mask_Middle(search_round,
				Input_u, Input_v, Input_w,
				part, part_wt, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = SPARX128_R2_mask_Middle(search_round,
				Input_u, Input_v, Input_w,
				part, part_wt, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = SPARX128_R2_mask_Middle(search_round,
					Input_u, Input_v, Input_w,
					part, part_wt, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}

u16 SPARX128_R2_mask_Middle(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 part, u16 part_wt, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= part_wt ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = SPARX128_R2_mask_MSB(search_round,
				tmp_U,tmp_V,tmp_W,
				part, part_wt, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

				if(current_index < blocksize_len -2)
				{
					//跳转到高比特分析
					best = SPARX128_R2_mask_Middle(search_round,
							tmp_U, tmp_V, tmp_W,
							part, part_wt, Corr_tmp_inc, posi,
							current_index + 1, Fwt);
				}
				else
				{
					best = SPARX128_R2_mask_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							part, part_wt, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//跳转到高比特分析
				best = SPARX128_R2_mask_Middle(search_round,
						Input_u, Input_v, Input_w,
						part, part_wt, Corr_tmp_inc, posi,
						current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = SPARX128_R2_mask_Middle(search_round,
							Input_u, Input_v, Input_w,
							part, part_wt, Corr_inc, posi,
							current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = SPARX128_R2_mask_Middle(search_round,
							Input_u, Input_v, Input_w,
							part, part_wt, Corr_tmp_inc +1, posi,
							current_index + 1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}


u16 SPARX128_R2_mask_MSB(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 part, u16 part_wt, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


/*
	if(Corr_tmp_inc > part_wt)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
	{
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			R1_mask_UVW[part*3]    = tmp_U;
			R1_mask_UVW[part*3 +1] = tmp_V;
			R1_mask_UVW[part*3 +2] = tmp_W;
			//跳转 第1轮的下一个块
			best = SPARX128_linear_trail_R2(search_round, part+1);
		}
		else
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			R1_mask_UVW[part*3]    = Input_u;
			R1_mask_UVW[part*3 +1] = Input_v;
			R1_mask_UVW[part*3 +2] = Input_w;
			//跳转 第1轮的下一个块
			best = SPARX128_linear_trail_R2(search_round, part+1);
		}
	}
	else  // Corr_tmp_inc == part_wt 搜索的当前wt与期望的相关性重量相等
	{
		if( (posi[part_wt]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0; //!= >
		{
			//Fwt = 0;//当前M向量该比特位无相关性重量
			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				//printf(" SPARX128_R2_mask_MSB 1  \n");
				//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
				best = SPARX128_R2_mask_MSB(search_round,
						tmp_U,tmp_V,tmp_W,
						part, part_wt, Corr_tmp_inc,posi,
						current_index +1, Fwt);
			}
			else // 上一个更低比特的M位置的相关性重量为 1. // pre_cor_0or1 =1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//printf(" SPARX128_R2_mask_MSB 3 \n");
				//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
				best = SPARX128_R2_mask_MSB(search_round,
						Input_u, Input_v, Input_w,
						part, part_wt, Corr_tmp_inc,posi,
						current_index +1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
			}
		}
		else  //(posi[part_wt]-1) == current_index
		{

		if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_B_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_B_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_B_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				R2_mask_UVW[part*3]    = Input_u;
				R2_mask_UVW[part*3 +1] = Input_v;
				R2_mask_UVW[part*3 +2] = Input_w;

				//跳转 第1轮的下一个块
				best = SPARX128_linear_trail_R2(search_round,part+1);

#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
			}
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_A_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_A_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_A_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				R2_mask_UVW[part*3]    = Input_u;
				R2_mask_UVW[part*3 +1] = Input_v;
				R2_mask_UVW[part*3 +2] = Input_w;

				//跳转 第1轮的下一个块
				best = SPARX128_linear_trail_R2(search_round,part+1);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return best;
}
#endif
			}
		}}}
	return best;
*/


	if( (posi[part_wt]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
	{
		//Fwt = 0;//当前M向量该比特位无相关性重量
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
			//Input_u = tmp_U | (0 << current_index); //该位置置0
			//Input_v = tmp_V | (0 << current_index); //该位置置0
			//Input_w = tmp_W | (0 << current_index); //该位置置0

			if(current_index <= blocksize_len-2)
			{
				//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
				best = SPARX128_R2_mask_MSB(search_round,
						tmp_U,tmp_V,tmp_W,
						part, part_wt, Corr_tmp_inc,posi,
						current_index +1, Fwt);
			}
			else //直接跳转到第1轮的右侧
			{
				R2_mask_UVW[part*3]    = tmp_U;
				R2_mask_UVW[part*3 +1] = tmp_V;
				R2_mask_UVW[part*3 +2] = tmp_W;

				//跳转 第1轮的下一个块
				best = SPARX128_linear_trail_R2(search_round, part+1);
			}
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
			best = SPARX128_R2_mask_MSB(search_round,
					Input_u, Input_v, Input_w,
					part, part_wt, Corr_tmp_inc,posi,
					current_index +1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
	}
	else //////当前M向量该比特位you相关性重量, M_i = 1; (posi[Corr_1]-1) == current_index .
	{
		//Fwt = 1;//当前M向量该比特位you相关性重量
		//Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

		if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_B_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_B_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_B_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				R2_mask_UVW[part*3]    = Input_u;
				R2_mask_UVW[part*3 +1] = Input_v;
				R2_mask_UVW[part*3 +2] = Input_w;

				//跳转 第1轮的下一个块
				best = SPARX128_linear_trail_R2(search_round,part+1);

#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
			}
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_A_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_A_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_A_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				R2_mask_UVW[part*3]    = Input_u;
				R2_mask_UVW[part*3 +1] = Input_v;
				R2_mask_UVW[part*3 +2] = Input_w;

				//跳转 第1轮的下一个块
				best = SPARX128_linear_trail_R2(search_round,part+1);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return best;
}
#endif
			}
		}
	}
	return best;

}




u16 SPARX128_linear_trail_r (u16 search_round, u16 cur_round, u16 *mask_Xr )
{
	u16 best = 0;
	u16 round_L = 0;
	u16 r_mask_Xr[8] ={0};
	u16 r_mask_Xr_L[8] ={0};

	u64 Input_v_part[4] = {0};  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_part[4] = {0};  //模加输入右侧掩码
	u64 Input_u_part[4] = {0};  //模加输出掩码
	u16 tmp_right_L[4] = {0};

	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;

	u64 v_block_part[4][2] = {0}; //按照8比特进行切片
	u64 w_block_part[4][2] = {0};
	u64 u_block_part[4][2] = {0};

	u64 L_L = 0, L_L_tmp = 0;    //用于线性变换L后的线性掩码变量
	u64 X_L_tmp[4] = {0};
	u64 e_Mxor_part[4] = {0}; //用于记录M向量的高比特的异或和

	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;



//	printf(" search_round r: %d \n", cur_round);

	if(search_round == cur_round)
	{
		best = SPARX128_linear_trail_N(search_round, mask_Xr);
		return best;
	}

	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = Bn_w - p_sumof_r - n_P_bestofR_w[search_round - cur_round];

	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	for(i=0; i<4; i++)
	{
		Input_v_part[i] = ((mask_Xr[2*i] >> rol_a) |
				(mask_Xr[2*i] << (blocksize_len - rol_a))) & Bit_Align;//rol right

		//m1 //从MSB向LSB的方向进行分块
		v_block_part[i][0] = (Input_v_part[i] >> 8) & 0xFF; //MSB 8 bit
		wt_cor_bound += cLAT_wtcor_min[v_block_part[i][0]][0]; 	//bound wt
		//m0
		v_block_part[i][1] =  Input_v_part[i] & 0xFF; //LSB 8 bit
		wt_cor_bound += cLAT_wtcor_min[v_block_part[i][1]][0]; 	//bound wt
	}

	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}



/////////part 0
	for(i0 = cLAT_wtcor_min[v_block_part[0][0]][0]; i0 < 8; i0++)
	{
		if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
	for(j0=0; j0 < cLAT_WU_numb[v_block_part[0][0]][0][i0]; j0++)
	{
		w_block_part[0][0] = cLAT_W[v_block_part[0][0]][0][i0][j0];
		u_block_part[0][0] = cLAT_U[v_block_part[0][0]][0][i0][j0];

		e_Mxor_part[0] = cLAT_UVW_bro[u_block_part[0][0]][v_block_part[0][0]][w_block_part[0][0]][0];

	for(i1 = cLAT_wtcor_min[v_block_part[0][1]][e_Mxor_part[0]]; i1 <= 8; i1++)
	{
		if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cLAT_WU_numb[v_block_part[0][1]][e_Mxor_part[0]][i1]; j1++)
	{
		w_block_part[0][1] = cLAT_W[v_block_part[0][1]][e_Mxor_part[0]][i1][j1];
		u_block_part[0][1] = cLAT_U[v_block_part[0][1]][e_Mxor_part[0]][i1][j1];

		Input_w_part[0] = (w_block_part[0][0] << 8) | w_block_part[0][1];  //模加输入右侧掩码
		Input_u_part[0] = (u_block_part[0][0] << 8) | u_block_part[0][1];  //模加输入右侧掩码


/////////part 1
	for(i2 = cLAT_wtcor_min[v_block_part[1][0]][0]; i2 < 8; i2++)
	{
		if(i0+i1+i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
	for(j2=0; j2 < cLAT_WU_numb[v_block_part[1][0]][0][i2]; j2++)
	{
		w_block_part[1][0] = cLAT_W[v_block_part[1][0]][0][i2][j2];
		u_block_part[1][0] = cLAT_U[v_block_part[1][0]][0][i2][j2];

		e_Mxor_part[1] = cLAT_UVW_bro[u_block_part[1][0]][v_block_part[1][0]][w_block_part[1][0]][0];

	for(i3 = cLAT_wtcor_min[v_block_part[1][1]][e_Mxor_part[1]]; i3 <= 8; i3++)
	{
		if(i0 + i1 +i2+i3> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j3=0; j3 < cLAT_WU_numb[v_block_part[1][1]][e_Mxor_part[1]][i3]; j3++)
	{
		w_block_part[1][1] = cLAT_W[v_block_part[1][1]][e_Mxor_part[1]][i3][j3];
		u_block_part[1][1] = cLAT_U[v_block_part[1][1]][e_Mxor_part[1]][i3][j3];

		Input_w_part[1] = (w_block_part[1][0] << 8) | w_block_part[1][1];  //模加输入右侧掩码
		Input_u_part[1] = (u_block_part[1][0] << 8) | u_block_part[1][1];  //模加输入右侧掩码


/////////part 2
	for(i4 = cLAT_wtcor_min[v_block_part[2][0]][0]; i4 < 8; i4++)
	{
		if(i0+i1+i2+i3+i4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
	for(j4=0; j4 < cLAT_WU_numb[v_block_part[2][0]][0][i4]; j4++)
	{
		w_block_part[2][0] = cLAT_W[v_block_part[2][0]][0][i4][j4];
		u_block_part[2][0] = cLAT_U[v_block_part[2][0]][0][i4][j4];

		e_Mxor_part[2] = cLAT_UVW_bro[u_block_part[2][0]][v_block_part[2][0]][w_block_part[2][0]][0];

	for(i5 = cLAT_wtcor_min[v_block_part[2][1]][e_Mxor_part[2]]; i5 <= 8; i5++)
	{
		if(i0 + i1 +i2+i3+i4+i5> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j5=0; j5 < cLAT_WU_numb[v_block_part[2][1]][e_Mxor_part[2]][i5]; j5++)
	{
		w_block_part[2][1] = cLAT_W[v_block_part[2][1]][e_Mxor_part[2]][i5][j5];
		u_block_part[2][1] = cLAT_U[v_block_part[2][1]][e_Mxor_part[2]][i5][j5];

		Input_w_part[2] = (w_block_part[2][0] << 8) | w_block_part[2][1];  //模加输入右侧掩码
		Input_u_part[2] = (u_block_part[2][0] << 8) | u_block_part[2][1];  //模加输入右侧掩码


/////////part 3
	for(i6 = cLAT_wtcor_min[v_block_part[3][0]][0]; i6 < 8; i6++)
	{
		if(i0+i1+i2+i3+i4+i5+i6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
	for(j6=0; j6 < cLAT_WU_numb[v_block_part[3][0]][0][i6]; j6++)
	{
		w_block_part[3][0] = cLAT_W[v_block_part[3][0]][0][i6][j6];
		u_block_part[3][0] = cLAT_U[v_block_part[3][0]][0][i6][j6];

		e_Mxor_part[3] = cLAT_UVW_bro[u_block_part[3][0]][v_block_part[3][0]][w_block_part[3][0]][0];

	for(i7 = cLAT_wtcor_min[v_block_part[3][1]][e_Mxor_part[3]]; i7 <= 8; i7++)
	{
		if(i0 + i1 +i2+i3+i4+i5+i6+i7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j7=0; j7 < cLAT_WU_numb[v_block_part[3][1]][e_Mxor_part[3]][i7]; j7++)
	{
		w_block_part[3][1] = cLAT_W[v_block_part[3][1]][e_Mxor_part[3]][i7][j7];
		u_block_part[3][1] = cLAT_U[v_block_part[3][1]][e_Mxor_part[3]][i7][j7];

		Input_w_part[3] = (w_block_part[3][0] << 8) | w_block_part[3][1];  //模加输入右侧掩码
		Input_u_part[3] = (u_block_part[3][0] << 8) | u_block_part[3][1];  //模加输入右侧掩码


/////////处理本轮的输出掩码
		//part 0
		tmp_right_L[0] = mask_Xr[1] ^ Input_w_part[0];
		X_128_r[1][cur_round + 1] = ((tmp_right_L[0] << rol_b) |
				(tmp_right_L[0] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[0][cur_round + 1] = X_128_r[1][cur_round + 1] ^ Input_u_part[0];
		r_mask_Xr[0] = X_128_r[0][cur_round + 1];
		r_mask_Xr[1] = X_128_r[1][cur_round + 1];

		//part 1
		tmp_right_L[1] = mask_Xr[3] ^ Input_w_part[1];
		X_128_r[3][cur_round + 1] = ((tmp_right_L[1] << rol_b) |
				(tmp_right_L[1] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[2][cur_round + 1] = X_128_r[3][cur_round + 1] ^ Input_u_part[1];
		r_mask_Xr[2] = X_128_r[2][cur_round + 1];
		r_mask_Xr[3] = X_128_r[3][cur_round + 1];

		//part 2
		tmp_right_L[2] = mask_Xr[5] ^ Input_w_part[2];
		X_128_r[5][cur_round + 1] = ((tmp_right_L[2] << rol_b) |
				(tmp_right_L[2] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[4][cur_round + 1] = X_128_r[5][cur_round + 1] ^ Input_u_part[2];
		r_mask_Xr[4] = X_128_r[4][cur_round + 1];
		r_mask_Xr[5] = X_128_r[5][cur_round + 1];

		//part 3
		tmp_right_L[3] = mask_Xr[7] ^ Input_w_part[3];
		X_128_r[7][cur_round + 1] = ((tmp_right_L[3] << rol_b) |
				(tmp_right_L[3] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[6][cur_round + 1] = X_128_r[7][cur_round + 1] ^ Input_u_part[3];
		r_mask_Xr[6] = X_128_r[6][cur_round + 1];
		r_mask_Xr[7] = X_128_r[7][cur_round + 1];


		wt_block[0][cur_round] = i0 + i1;
		wt_block[1][cur_round] = i2 + i3;  //R2_mask_UVW_wt[part] = M0;
		wt_block[2][cur_round] = i4 + i5;
		wt_block[3][cur_round] = i6 + i7;

		P_w[cur_round] = wt_block[0][cur_round] +
				wt_block[1][cur_round] +
				wt_block[2][cur_round] +
				wt_block[3][cur_round];  //当前轮的线性相关性重量

		if(((cur_round) % 4) == 0) //下一轮为 5,9,13...
		{
			round_L = cur_round/4;
			//L前的输出掩码需要输出
			for(j=0;j<8;j++)
			{
				IN128_L_X[round_L][j] = r_mask_Xr[j];  //记录的是L变换前的值
			}

			L_L = r_mask_Xr[4] ^ r_mask_Xr[5] ^ r_mask_Xr[6] ^ r_mask_Xr[7];
			L_L_tmp = ((L_L >> 8) |	(L_L << (blocksize_len - 8))) & Bit_Align;//rol right

			r_mask_Xr_L[0] = r_mask_Xr[4];
			r_mask_Xr_L[1] = r_mask_Xr[5];
			r_mask_Xr_L[2] = r_mask_Xr[6];
			r_mask_Xr_L[3] = r_mask_Xr[7];
			r_mask_Xr_L[4] = r_mask_Xr[0] ^ r_mask_Xr[6] ^ L_L_tmp;
			r_mask_Xr_L[5] = r_mask_Xr[1] ^ r_mask_Xr[5] ^ L_L_tmp;
			r_mask_Xr_L[6] = r_mask_Xr[2] ^ r_mask_Xr[4] ^ L_L_tmp;
			r_mask_Xr_L[7] = r_mask_Xr[3] ^ r_mask_Xr[7] ^ L_L_tmp;

			for(j=0;j<8;j++)
			{
				X_128_r[j][cur_round + 1] = r_mask_Xr_L[j];
				r_mask_Xr[j] = r_mask_Xr_L[j];
			}
		}

//		printf(" Next  search_round r: %d \n", cur_round);
		//跳转 下一轮
		best = SPARX128_linear_trail_r(search_round, cur_round+1, r_mask_Xr);
#if 1   //是否找到第一条最优路径就返回？
if( best == 1 )
	return 1;
#endif
	}}}}
	}}}}
	}}}}
	}}}}
	return best;
}


u16 SPARX128_linear_trail_N(u16 search_round, u16 *mask_Xr )
{
	u16 best = 0;
	u16 round_L = 0;
	u16 r_mask_Xr[8] ={0};
	u16 r_mask_Xr_L[8] ={0};

	u64 Input_v_part[4] = {0};  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_part[4] = {0};  //模加输入右侧掩码
	u64 Input_u_part[4] = {0};  //模加输出掩码
	u16 tmp_right_L[4] = {0};

	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;

	u64 v_block_part[4][2] = {0}; //按照8比特进行切片
	u64 w_block_part[4][2] = {0};
	u64 u_block_part[4][2] = {0};

	u64 L_L = 0, L_L_tmp = 0;    //用于线性变换L后的线性掩码变量
	u64 X_L_tmp[4] = {0};
	u64 e_Mxor_part[4] = {0}; //用于记录M向量的高比特的异或和

	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;




//	printf(" search_round N \n");

	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = Bn_w - p_sumof_r;

	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	for(i=0; i<4; i++)
	{
		Input_v_part[i] = ((mask_Xr[2*i] >> rol_a) |
				(mask_Xr[2*i] << (blocksize_len - rol_a))) & Bit_Align;//rol right

		//m1 //从MSB向LSB的方向进行分块
		v_block_part[i][0] = (Input_v_part[i] >> 8) & 0xFF; //MSB 8 bit
		wt_cor_bound += cLAT_wtcor_min[v_block_part[i][0]][0]; 	//bound wt
		//m0
		v_block_part[i][1] =  Input_v_part[i] & 0xFF; //LSB 8 bit
		wt_cor_bound += cLAT_wtcor_min[v_block_part[i][1]][0]; 	//bound wt
	}

	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

//	printf(" search_round N-1 \n");

/////////part 0
	for(i0 = cLAT_wtcor_min[v_block_part[0][0]][0]; i0 < 8; i0++)
	{
		if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
	for(j0=0; j0 < cLAT_WU_numb[v_block_part[0][0]][0][i0]; j0++)
	{
		w_block_part[0][0] = cLAT_W[v_block_part[0][0]][0][i0][j0];
		u_block_part[0][0] = cLAT_U[v_block_part[0][0]][0][i0][j0];

		e_Mxor_part[0] = cLAT_UVW_bro[u_block_part[0][0]][v_block_part[0][0]][w_block_part[0][0]][0];

	for(i1 = cLAT_wtcor_min[v_block_part[0][1]][e_Mxor_part[0]]; i1 <= 8; i1++)
	{
		if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cLAT_WU_numb[v_block_part[0][1]][e_Mxor_part[0]][i1]; j1++)
	{
		w_block_part[0][1] = cLAT_W[v_block_part[0][1]][e_Mxor_part[0]][i1][j1];
		u_block_part[0][1] = cLAT_U[v_block_part[0][1]][e_Mxor_part[0]][i1][j1];

		Input_w_part[0] = (w_block_part[0][0] << 8) | w_block_part[0][1];  //模加输入右侧掩码
		Input_u_part[0] = (u_block_part[0][0] << 8) | u_block_part[0][1];  //模加输入右侧掩码


/////////part 1
	for(i2 = cLAT_wtcor_min[v_block_part[1][0]][0]; i2 < 8; i2++)
	{
		if(i0+i1+i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
	for(j2=0; j2 < cLAT_WU_numb[v_block_part[1][0]][0][i2]; j2++)
	{
		w_block_part[1][0] = cLAT_W[v_block_part[1][0]][0][i2][j2];
		u_block_part[1][0] = cLAT_U[v_block_part[1][0]][0][i2][j2];

		e_Mxor_part[1] = cLAT_UVW_bro[u_block_part[1][0]][v_block_part[1][0]][w_block_part[1][0]][0];

	for(i3 = cLAT_wtcor_min[v_block_part[1][1]][e_Mxor_part[1]]; i3 <= 8; i3++)
	{
		if(i0 + i1 +i2+i3> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j3=0; j3 < cLAT_WU_numb[v_block_part[1][1]][e_Mxor_part[1]][i3]; j3++)
	{
		w_block_part[1][1] = cLAT_W[v_block_part[1][1]][e_Mxor_part[1]][i3][j3];
		u_block_part[1][1] = cLAT_U[v_block_part[1][1]][e_Mxor_part[1]][i3][j3];

		Input_w_part[1] = (w_block_part[1][0] << 8) | w_block_part[1][1];  //模加输入右侧掩码
		Input_u_part[1] = (u_block_part[1][0] << 8) | u_block_part[1][1];  //模加输入右侧掩码


/////////part 2
	for(i4 = cLAT_wtcor_min[v_block_part[2][0]][0]; i4 < 8; i4++)
	{
		if(i0+i1+i2+i3+i4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
	for(j4=0; j4 < cLAT_WU_numb[v_block_part[2][0]][0][i4]; j4++)
	{
		w_block_part[2][0] = cLAT_W[v_block_part[2][0]][0][i4][j4];
		u_block_part[2][0] = cLAT_U[v_block_part[2][0]][0][i4][j4];

		e_Mxor_part[2] = cLAT_UVW_bro[u_block_part[2][0]][v_block_part[2][0]][w_block_part[2][0]][0];

	for(i5 = cLAT_wtcor_min[v_block_part[2][1]][e_Mxor_part[2]]; i5 <= 8; i5++)
	{
		if(i0 + i1 +i2+i3+i4+i5> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j5=0; j5 < cLAT_WU_numb[v_block_part[2][1]][e_Mxor_part[2]][i5]; j5++)
	{
		w_block_part[2][1] = cLAT_W[v_block_part[2][1]][e_Mxor_part[2]][i5][j5];
		u_block_part[2][1] = cLAT_U[v_block_part[2][1]][e_Mxor_part[2]][i5][j5];

		Input_w_part[2] = (w_block_part[2][0] << 8) | w_block_part[2][1];  //模加输入右侧掩码
		Input_u_part[2] = (u_block_part[2][0] << 8) | u_block_part[2][1];  //模加输入右侧掩码


/////////part 3
	for(i6 = cLAT_wtcor_min[v_block_part[3][0]][0]; i6 < 8; i6++)
	{
		if(i0+i1+i2+i3+i4+i5+i6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
	for(j6=0; j6 < cLAT_WU_numb[v_block_part[3][0]][0][i6]; j6++)
	{
		w_block_part[3][0] = cLAT_W[v_block_part[3][0]][0][i6][j6];
		u_block_part[3][0] = cLAT_U[v_block_part[3][0]][0][i6][j6];

		e_Mxor_part[3] = cLAT_UVW_bro[u_block_part[3][0]][v_block_part[3][0]][w_block_part[3][0]][0];

	for(i7 = cLAT_wtcor_min[v_block_part[3][1]][e_Mxor_part[3]]; i7 <= 8; i7++)
	{
		if(i0 + i1 +i2+i3+i4+i5+i6+i7 == w_cmp ){
//			printf(" search_round N i7:%d w_cmp:%d e_Mxor_part[3]:%d  Numb:%d \n",
//					i7,w_cmp,e_Mxor_part[3],
//					cLAT_WU_numb[v_block_part[3][1]][e_Mxor_part[3]][i7]);
		//if(i0 + i1 +i2+i3+i4+i5+i6+i7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j7=0; j7 < cLAT_WU_numb[v_block_part[3][1]][e_Mxor_part[3]][i7]; j7++)
	{
//		printf(" search_round N--1 \n");
		w_block_part[3][1] = cLAT_W[v_block_part[3][1]][e_Mxor_part[3]][i7][j7];
		u_block_part[3][1] = cLAT_U[v_block_part[3][1]][e_Mxor_part[3]][i7][j7];

		Input_w_part[3] = (w_block_part[3][0] << 8) | w_block_part[3][1];  //模加输入右侧掩码
		Input_u_part[3] = (u_block_part[3][0] << 8) | u_block_part[3][1];  //模加输入右侧掩码


/////////处理本轮的输出掩码
		//part 0
		tmp_right_L[0] = mask_Xr[1] ^ Input_w_part[0];
		X_128_r[1][search_round + 1] = ((tmp_right_L[0] << rol_b) |
				(tmp_right_L[0] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[0][search_round + 1] = X_128_r[1][search_round + 1] ^ Input_u_part[0];
		r_mask_Xr[0] = X_128_r[0][search_round + 1];
		r_mask_Xr[1] = X_128_r[1][search_round + 1];

		//part 1
		tmp_right_L[1] = mask_Xr[3] ^ Input_w_part[1];
		X_128_r[3][search_round + 1] = ((tmp_right_L[1] << rol_b) |
				(tmp_right_L[1] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[2][search_round + 1] = X_128_r[3][search_round + 1] ^ Input_u_part[1];
		r_mask_Xr[2] = X_128_r[2][search_round + 1];
		r_mask_Xr[3] = X_128_r[3][search_round + 1];

		//part 2
		tmp_right_L[2] = mask_Xr[5] ^ Input_w_part[2];
		X_128_r[5][search_round + 1] = ((tmp_right_L[2] << rol_b) |
				(tmp_right_L[2] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[4][search_round + 1] = X_128_r[5][search_round + 1] ^ Input_u_part[2];
		r_mask_Xr[4] = X_128_r[4][search_round + 1];
		r_mask_Xr[5] = X_128_r[5][search_round + 1];

		//part 3
		tmp_right_L[3] = mask_Xr[7] ^ Input_w_part[3];
		X_128_r[7][search_round + 1] = ((tmp_right_L[3] << rol_b) |
				(tmp_right_L[3] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[6][search_round + 1] = X_128_r[7][search_round + 1] ^ Input_u_part[3];
		r_mask_Xr[6] = X_128_r[6][search_round + 1];
		r_mask_Xr[7] = X_128_r[7][search_round + 1];


		wt_block[0][search_round] = i0 + i1;
		wt_block[1][search_round] = i2 + i3;
		wt_block[2][search_round] = i4 + i5;
		wt_block[3][search_round] = i6 + i7;

		P_w[search_round] = wt_block[0][search_round] +
				wt_block[1][search_round] +
				wt_block[2][search_round] +
				wt_block[3][search_round];  //当前轮的线性相关性重量

//		if(P_w[search_round] == w_cmp )
		{
			best = 1;
			n_P_bestofR_w[search_round] = Bn_w;

		if(((search_round) % 4) == 0) //下一轮为 5,9,13...
		{
			round_L = search_round/4;
			//L前的输出掩码需要输出
			for(j=0;j<8;j++)
			{
				IN128_L_X[round_L][j] = r_mask_Xr[j];  //记录的是L变换前的值
			}

			L_L = r_mask_Xr[4] ^ r_mask_Xr[5] ^ r_mask_Xr[6] ^ r_mask_Xr[7];
			L_L_tmp = ((L_L >> 8) |	(L_L << (blocksize_len - 8))) & Bit_Align;//rol right

			r_mask_Xr_L[0] = r_mask_Xr[4];
			r_mask_Xr_L[1] = r_mask_Xr[5];
			r_mask_Xr_L[2] = r_mask_Xr[6];
			r_mask_Xr_L[3] = r_mask_Xr[7];
			r_mask_Xr_L[4] = r_mask_Xr[0] ^ r_mask_Xr[6] ^ L_L_tmp;
			r_mask_Xr_L[5] = r_mask_Xr[1] ^ r_mask_Xr[5] ^ L_L_tmp;
			r_mask_Xr_L[6] = r_mask_Xr[2] ^ r_mask_Xr[4] ^ L_L_tmp;
			r_mask_Xr_L[7] = r_mask_Xr[3] ^ r_mask_Xr[7] ^ L_L_tmp;

			for(j=0;j<8;j++)
			{
				X_128_r[j][search_round + 1] = r_mask_Xr_L[j];
				r_mask_Xr[j] = r_mask_Xr_L[j];
			}
		}
		}

#if 1   //是否找到第一条最优路径就返回？
if( best == 1 )
	return best;
#endif
	}}}}  }
	}}}}
	}}}}
	}}}}
	return best;
}


u16 SPARX128_linear_Hull_search_entry (u16 search_round)
{
	u16 best = 0;
	u16 i =0;
	FILE* SPARX128_linear_best_Bn;


	SPARX128_linear_best_Bn = fopen ("../tmp/sparx128_linear_Bn_wt.xlsx", "a+"); //  "w+"); //
	if((sc_blocksize != 64) && (sc_blocksize != 128))
	{
		printf("The block size of SPARX should be 64 or 128 bits. \n");
		return 0;
	}
	for(i=1; i <= search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
	{
		fscanf(SPARX128_linear_best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
		//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
	}

	rol_a = 7;	/* a */
	rol_b = 2;   /* b */

	// For SPARX64 and SPARX128 both the S-BOX is 16bits.
	blocksize_len = 16;
	Bit_Align = 0xFFFF;
	ValueMax_Align = 0x7FFF;
	V_MSB = 0x8000;

	printf("Constructing SPARX-128 cLAT Tables... \n");
	//构造部分的线性相关性近似表cLAT
	ARX_cLAT_construct();
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct SPARX-128 cLAT: %.2f seconds.  \n", run_time);


		//10 round cor sparx-128
		IN_X_Mask[0] = 0x0000;
		IN_X_Mask[1] = 0x0000;
		IN_X_Mask[2] = 0x0000;
		IN_X_Mask[3] = 0x4020;
		IN_X_Mask[4] = 0x0000;
		IN_X_Mask[5] = 0x0000;
		IN_X_Mask[6] = 0x0000;
		IN_X_Mask[7] = 0x0000;

		OUT_Y_Mask[0] = 0x0000;
		OUT_Y_Mask[1] = 0x0000;
		OUT_Y_Mask[2] = 0x0215;
		OUT_Y_Mask[3] = 0x0012;
		OUT_Y_Mask[4] = 0x0813;
		OUT_Y_Mask[5] = 0x0814;
		OUT_Y_Mask[6] = 0x0A06;
		OUT_Y_Mask[6] = 0x0806;

		wt_max = 23;
		n_P_bestofR_w[search_round] = 23;

	Bn_w = n_P_bestofR_w[search_round];
	//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
	printf("wt_min(:%d)--->wt_max: %d \n", n_P_bestofR_w[search_round], wt_max);
	printf("-----------------------Search SPARX-128 Linear Hulls---------------------------\n");
	SPARX128_linear_Hull_r(search_round, 1, IN_X_Mask); //
	printf("-----------------------Record SPARX-128 Linear Hulls---------------------\n");

	for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
	{
		prob = prob + (wt_nmu[i] * pow(2,-2*i));
		prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
		printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
	}
	printf("++++++++++++++++++\n ");
	printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
	//printf("input:0x%012x %012x ======>> output:0x%012x %012x \n",input_diff_L,input_diff_R,output_diff_L,output_diff_R);
	printf( "0x%04x %04x %04x %04x %04x %04x %04x %04x \n"
			"==================>>\n"
		    "0x%04x %04x %04x %04x %04x %04x %04x %04x \n",
			IN_X_Mask[0],IN_X_Mask[1],IN_X_Mask[2],IN_X_Mask[3],
			IN_X_Mask[4],IN_X_Mask[5],IN_X_Mask[6],IN_X_Mask[7],
			OUT_Y_Mask[0],OUT_Y_Mask[1],OUT_Y_Mask[2],OUT_Y_Mask[3],
			OUT_Y_Mask[4],OUT_Y_Mask[5],OUT_Y_Mask[6],OUT_Y_Mask[7]);

	printf(" wt_min: -%d ===>> wt_max: -%d \n",n_P_bestofR_w[search_round],wt_max);
	printf(" %d Rounds Linear Hull with total %d trails.\n",search_round,count);
	printf(" Correlation potential is: %.2Lf \n",prob_w);
	printf("++++++++++++++++++\n ");


	time_finish = clock();
	run_time =  (double)(time_finish - time_start) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours. \n", run_time,run_time/60.0,run_time/3600.0 );
	printf("Auto-search END! \n");
	printf("|************************************************************************|\n");

	fclose(SPARX128_linear_best_Bn);

	return best;
}




u16 SPARX128_linear_Hull_r (u16 search_round, u16 cur_round, u16 *mask_Xr )
{
	u16 best = 0;
	u16 round_L = 0;
	u16 r_mask_Xr[8] ={0};
	u16 r_mask_Xr_L[8] ={0};

	u64 Input_v_part[4] = {0};  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_part[4] = {0};  //模加输入右侧掩码
	u64 Input_u_part[4] = {0};  //模加输出掩码
	u16 tmp_right_L[4] = {0};

	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;

	u64 v_block_part[4][2] = {0}; //按照8比特进行切片
	u64 w_block_part[4][2] = {0};
	u64 u_block_part[4][2] = {0};

	u64 L_L = 0, L_L_tmp = 0;    //用于线性变换L后的线性掩码变量
	u64 X_L_tmp[4] = {0};
	u64 e_Mxor_part[4] = {0}; //用于记录M向量的高比特的异或和

	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;




//	printf(" search_round r: %d \n", cur_round);

	if(search_round <= cur_round)
	{
		best = SPARX128_linear_Hull_N(search_round, mask_Xr);
		return best;
	}


	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r - n_P_bestofR_w[search_round - cur_round];

	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	for(i=0; i<4; i++)
	{
		Input_v_part[i] = ((mask_Xr[2*i] >> rol_a) |
				(mask_Xr[2*i] << (blocksize_len - rol_a))) & Bit_Align;//rol right

		//m1 //从MSB向LSB的方向进行分块
		v_block_part[i][0] = (Input_v_part[i] >> 8) & 0xFF; //MSB 8 bit
		wt_cor_bound += cLAT_wtcor_min[v_block_part[i][0]][0]; 	//bound wt
		//m0
		v_block_part[i][1] =  Input_v_part[i] & 0xFF; //LSB 8 bit
		wt_cor_bound += cLAT_wtcor_min[v_block_part[i][1]][0]; 	//bound wt
	}

	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}


/////////part 0
	for(i0 = cLAT_wtcor_min[v_block_part[0][0]][0]; i0 < 8; i0++)
	{
		if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
	for(j0=0; j0 < cLAT_WU_numb[v_block_part[0][0]][0][i0]; j0++)
	{
		w_block_part[0][0] = cLAT_W[v_block_part[0][0]][0][i0][j0];
		u_block_part[0][0] = cLAT_U[v_block_part[0][0]][0][i0][j0];
		e_Mxor_part[0] = cLAT_UVW_bro[u_block_part[0][0]][v_block_part[0][0]][w_block_part[0][0]][0];

	for(i1 = cLAT_wtcor_min[v_block_part[0][1]][e_Mxor_part[0]]; i1 <= 8; i1++)
	{
		if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cLAT_WU_numb[v_block_part[0][1]][e_Mxor_part[0]][i1]; j1++)
	{
		w_block_part[0][1] = cLAT_W[v_block_part[0][1]][e_Mxor_part[0]][i1][j1];
		u_block_part[0][1] = cLAT_U[v_block_part[0][1]][e_Mxor_part[0]][i1][j1];

		Input_w_part[0] = (w_block_part[0][0] << 8) | w_block_part[0][1];  //模加输入右侧掩码
		Input_u_part[0] = (u_block_part[0][0] << 8) | u_block_part[0][1];  //模加输入右侧掩码


/////////part 1
	for(i2 = cLAT_wtcor_min[v_block_part[1][0]][0]; i2 < 8; i2++)
	{
		if(i0+i1+i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
	for(j2=0; j2 < cLAT_WU_numb[v_block_part[1][0]][0][i2]; j2++)
	{
		w_block_part[1][0] = cLAT_W[v_block_part[1][0]][0][i2][j2];
		u_block_part[1][0] = cLAT_U[v_block_part[1][0]][0][i2][j2];
		e_Mxor_part[1] = cLAT_UVW_bro[u_block_part[1][0]][v_block_part[1][0]][w_block_part[1][0]][0];

	for(i3 = cLAT_wtcor_min[v_block_part[1][1]][e_Mxor_part[1]]; i3 <= 8; i3++)
	{
		if(i0 + i1 +i2+i3> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j3=0; j3 < cLAT_WU_numb[v_block_part[1][1]][e_Mxor_part[1]][i3]; j3++)
	{
		w_block_part[1][1] = cLAT_W[v_block_part[1][1]][e_Mxor_part[1]][i3][j3];
		u_block_part[1][1] = cLAT_U[v_block_part[1][1]][e_Mxor_part[1]][i3][j3];

		Input_w_part[1] = (w_block_part[1][0] << 8) | w_block_part[1][1];  //模加输入右侧掩码
		Input_u_part[1] = (u_block_part[1][0] << 8) | u_block_part[1][1];  //模加输入右侧掩码


/////////part 2
	for(i4 = cLAT_wtcor_min[v_block_part[2][0]][0]; i4 < 8; i4++)
	{
		if(i0+i1+i2+i3+i4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
	for(j4=0; j4 < cLAT_WU_numb[v_block_part[2][0]][0][i4]; j4++)
	{
		w_block_part[2][0] = cLAT_W[v_block_part[2][0]][0][i4][j4];
		u_block_part[2][0] = cLAT_U[v_block_part[2][0]][0][i4][j4];
		e_Mxor_part[2] = cLAT_UVW_bro[u_block_part[2][0]][v_block_part[2][0]][w_block_part[2][0]][0];

	for(i5 = cLAT_wtcor_min[v_block_part[2][1]][e_Mxor_part[2]]; i5 <= 8; i5++)
	{
		if(i0 + i1 +i2+i3+i4+i5> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j5=0; j5 < cLAT_WU_numb[v_block_part[2][1]][e_Mxor_part[2]][i5]; j5++)
	{
		w_block_part[2][1] = cLAT_W[v_block_part[2][1]][e_Mxor_part[2]][i5][j5];
		u_block_part[2][1] = cLAT_U[v_block_part[2][1]][e_Mxor_part[2]][i5][j5];

		Input_w_part[2] = (w_block_part[2][0] << 8) | w_block_part[2][1];  //模加输入右侧掩码
		Input_u_part[2] = (u_block_part[2][0] << 8) | u_block_part[2][1];  //模加输入右侧掩码


/////////part 3
	for(i6 = cLAT_wtcor_min[v_block_part[3][0]][0]; i6 < 8; i6++)
	{
		if(i0+i1+i2+i3+i4+i5+i6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
	for(j6=0; j6 < cLAT_WU_numb[v_block_part[3][0]][0][i6]; j6++)
	{
		w_block_part[3][0] = cLAT_W[v_block_part[3][0]][0][i6][j6];
		u_block_part[3][0] = cLAT_U[v_block_part[3][0]][0][i6][j6];
		e_Mxor_part[3] = cLAT_UVW_bro[u_block_part[3][0]][v_block_part[3][0]][w_block_part[3][0]][0];

	for(i7 = cLAT_wtcor_min[v_block_part[3][1]][e_Mxor_part[3]]; i7 <= 8; i7++)
	{
		if(i0 + i1 +i2+i3+i4+i5+i6+i7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j7=0; j7 < cLAT_WU_numb[v_block_part[3][1]][e_Mxor_part[3]][i7]; j7++)
	{
		w_block_part[3][1] = cLAT_W[v_block_part[3][1]][e_Mxor_part[3]][i7][j7];
		u_block_part[3][1] = cLAT_U[v_block_part[3][1]][e_Mxor_part[3]][i7][j7];

		Input_w_part[3] = (w_block_part[3][0] << 8) | w_block_part[3][1];  //模加输入右侧掩码
		Input_u_part[3] = (u_block_part[3][0] << 8) | u_block_part[3][1];  //模加输入右侧掩码


/////////处理本轮的输出掩码
		//part 0
		tmp_right_L[0] = mask_Xr[1] ^ Input_w_part[0];
		X_128_r[1][cur_round + 1] = ((tmp_right_L[0] << rol_b) |
				(tmp_right_L[0] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[0][cur_round + 1] = X_128_r[1][cur_round + 1] ^ Input_u_part[0];
		r_mask_Xr[0] = X_128_r[0][cur_round + 1];
		r_mask_Xr[1] = X_128_r[1][cur_round + 1];

		//part 1
		tmp_right_L[1] = mask_Xr[3] ^ Input_w_part[1];
		X_128_r[3][cur_round + 1] = ((tmp_right_L[1] << rol_b) |
				(tmp_right_L[1] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[2][cur_round + 1] = X_128_r[3][cur_round + 1] ^ Input_u_part[1];
		r_mask_Xr[2] = X_128_r[2][cur_round + 1];
		r_mask_Xr[3] = X_128_r[3][cur_round + 1];

		//part 2
		tmp_right_L[2] = mask_Xr[5] ^ Input_w_part[2];
		X_128_r[5][cur_round + 1] = ((tmp_right_L[2] << rol_b) |
				(tmp_right_L[2] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[4][cur_round + 1] = X_128_r[5][cur_round + 1] ^ Input_u_part[2];
		r_mask_Xr[4] = X_128_r[4][cur_round + 1];
		r_mask_Xr[5] = X_128_r[5][cur_round + 1];

		//part 3
		tmp_right_L[3] = mask_Xr[7] ^ Input_w_part[3];
		X_128_r[7][cur_round + 1] = ((tmp_right_L[3] << rol_b) |
				(tmp_right_L[3] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[6][cur_round + 1] = X_128_r[7][cur_round + 1] ^ Input_u_part[3];
		r_mask_Xr[6] = X_128_r[6][cur_round + 1];
		r_mask_Xr[7] = X_128_r[7][cur_round + 1];


		wt_block[0][cur_round] = i0 + i1;
		wt_block[1][cur_round] = i2 + i3;
		wt_block[2][cur_round] = i4 + i5;
		wt_block[3][cur_round] = i6 + i7;

		P_w[cur_round] = wt_block[0][cur_round] +
				wt_block[1][cur_round] +
				wt_block[2][cur_round] +
				wt_block[3][cur_round];  //当前轮的线性相关性重量

		if((cur_round % 4) == 0) //下一轮为 5,9,13...
		{
			round_L = cur_round/4;
			//L前的输出掩码需要输出
			for(j=0;j<8;j++)
			{
				IN128_L_X[round_L][j] = r_mask_Xr[j];  //记录的是L变换前的值
			}

			L_L = r_mask_Xr[4] ^ r_mask_Xr[5] ^ r_mask_Xr[6] ^ r_mask_Xr[7];
			L_L_tmp = ((L_L >> 8) |	(L_L << 8)) & Bit_Align;//rol right

			r_mask_Xr_L[0] = r_mask_Xr[4];
			r_mask_Xr_L[1] = r_mask_Xr[5];
			r_mask_Xr_L[2] = r_mask_Xr[6];
			r_mask_Xr_L[3] = r_mask_Xr[7];
			r_mask_Xr_L[4] = r_mask_Xr[0] ^ r_mask_Xr[6] ^ L_L_tmp;
			r_mask_Xr_L[5] = r_mask_Xr[1] ^ r_mask_Xr[5] ^ L_L_tmp;
			r_mask_Xr_L[6] = r_mask_Xr[2] ^ r_mask_Xr[4] ^ L_L_tmp;
			r_mask_Xr_L[7] = r_mask_Xr[3] ^ r_mask_Xr[7] ^ L_L_tmp;

			for(j=0;j<8;j++)
			{
				X_128_r[j][cur_round + 1] = r_mask_Xr_L[j];
				r_mask_Xr[j] = r_mask_Xr_L[j];
			}
		}
/*
		printf(" search_round cur_round :%d \n", cur_round);
		for(j=0;j<8;j++)
		{
			printf("%x ",X_128_r[j][cur_round + 1]);
		}
		printf("\n " );  */

//		printf(" Next  search_round r: %d \n", cur_round);		//跳转 下一轮
		best = SPARX128_linear_Hull_r(search_round, cur_round+1, r_mask_Xr);
	}}}}
	}}}}
	}}}}
	}}}}
	return best;
}


u16 SPARX128_linear_Hull_N(u16 search_round, u16 *mask_Xr )
{
	u16 best = 0;
	u16 round_L = 0;
	u16 r_mask_Xr[8] ={0};
	u16 r_mask_Xr_L[8] ={0};

	u64 Input_v_part[4] = {0};  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_part[4] = {0};  //模加输入右侧掩码
	u64 Input_u_part[4] = {0};  //模加输出掩码
	u16 tmp_right_L[4] = {0};

	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;

	u64 v_block_part[4][2] = {0}; //按照8比特进行切片
	u64 w_block_part[4][2] = {0};
	u64 u_block_part[4][2] = {0};

	u64 L_L = 0, L_L_tmp = 0;    //用于线性变换L后的线性掩码变量
	u64 X_L_tmp[4] = {0};
	u64 e_Mxor_part[4] = {0}; //用于记录M向量的高比特的异或和

	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;

	u16 Not_eq = 0;


//	printf(" search_round r: %d \n", cur_round);

	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r;

	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	for(i=0; i<4; i++)
	{
		Input_v_part[i] = ((mask_Xr[2*i] >> rol_a) |
				(mask_Xr[2*i] << (blocksize_len - rol_a))) & Bit_Align;// 8 BIT

		//m1 //从MSB向LSB的方向进行分块
		v_block_part[i][0] = (Input_v_part[i] >> 8) & 0xFF; //MSB 8 bit
		wt_cor_bound += cLAT_wtcor_min[v_block_part[i][0]][0]; 	//bound wt
		//m0
		v_block_part[i][1] =  Input_v_part[i] & 0xFF; //LSB 8 bit
		wt_cor_bound += cLAT_wtcor_min[v_block_part[i][1]][0]; 	//bound wt
	}

	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}



/////////part 0
	for(i0 = cLAT_wtcor_min[v_block_part[0][0]][0]; i0 < 8; i0++)
	{
		if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
	for(j0=0; j0 < cLAT_WU_numb[v_block_part[0][0]][0][i0]; j0++)
	{
		w_block_part[0][0] = cLAT_W[v_block_part[0][0]][0][i0][j0];
		u_block_part[0][0] = cLAT_U[v_block_part[0][0]][0][i0][j0];
		e_Mxor_part[0] = cLAT_UVW_bro[u_block_part[0][0]][v_block_part[0][0]][w_block_part[0][0]][0];

	for(i1 = cLAT_wtcor_min[v_block_part[0][1]][e_Mxor_part[0]]; i1 <= 8; i1++)
	{
		if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cLAT_WU_numb[v_block_part[0][1]][e_Mxor_part[0]][i1]; j1++)
	{
		w_block_part[0][1] = cLAT_W[v_block_part[0][1]][e_Mxor_part[0]][i1][j1];
		u_block_part[0][1] = cLAT_U[v_block_part[0][1]][e_Mxor_part[0]][i1][j1];

		Input_w_part[0] = (w_block_part[0][0] << 8) | w_block_part[0][1];  //模加输入右侧掩码
		Input_u_part[0] = (u_block_part[0][0] << 8) | u_block_part[0][1];  //模加输入右侧掩码


/////////part 1
	for(i2 = cLAT_wtcor_min[v_block_part[1][0]][0]; i2 < 8; i2++)
	{
		if(i0+i1+i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
	for(j2=0; j2 < cLAT_WU_numb[v_block_part[1][0]][0][i2]; j2++)
	{
		w_block_part[1][0] = cLAT_W[v_block_part[1][0]][0][i2][j2];
		u_block_part[1][0] = cLAT_U[v_block_part[1][0]][0][i2][j2];
		e_Mxor_part[1] = cLAT_UVW_bro[u_block_part[1][0]][v_block_part[1][0]][w_block_part[1][0]][0];

	for(i3 = cLAT_wtcor_min[v_block_part[1][1]][e_Mxor_part[1]]; i3 <= 8; i3++)
	{
		if(i0 + i1 +i2+i3> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j3=0; j3 < cLAT_WU_numb[v_block_part[1][1]][e_Mxor_part[1]][i3]; j3++)
	{
		w_block_part[1][1] = cLAT_W[v_block_part[1][1]][e_Mxor_part[1]][i3][j3];
		u_block_part[1][1] = cLAT_U[v_block_part[1][1]][e_Mxor_part[1]][i3][j3];

		Input_w_part[1] = (w_block_part[1][0] << 8) | w_block_part[1][1];  //模加输入右侧掩码
		Input_u_part[1] = (u_block_part[1][0] << 8) | u_block_part[1][1];  //模加输入右侧掩码


/////////part 2
	for(i4 = cLAT_wtcor_min[v_block_part[2][0]][0]; i4 < 8; i4++)
	{
		if(i0+i1+i2+i3+i4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
	for(j4=0; j4 < cLAT_WU_numb[v_block_part[2][0]][0][i4]; j4++)
	{
		w_block_part[2][0] = cLAT_W[v_block_part[2][0]][0][i4][j4];
		u_block_part[2][0] = cLAT_U[v_block_part[2][0]][0][i4][j4];
		e_Mxor_part[2] = cLAT_UVW_bro[u_block_part[2][0]][v_block_part[2][0]][w_block_part[2][0]][0];

	for(i5 = cLAT_wtcor_min[v_block_part[2][1]][e_Mxor_part[2]]; i5 <= 8; i5++)
	{
		if(i0 + i1 +i2+i3+i4+i5> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j5=0; j5 < cLAT_WU_numb[v_block_part[2][1]][e_Mxor_part[2]][i5]; j5++)
	{
		w_block_part[2][1] = cLAT_W[v_block_part[2][1]][e_Mxor_part[2]][i5][j5];
		u_block_part[2][1] = cLAT_U[v_block_part[2][1]][e_Mxor_part[2]][i5][j5];

		Input_w_part[2] = (w_block_part[2][0] << 8) | w_block_part[2][1];  //模加输入右侧掩码
		Input_u_part[2] = (u_block_part[2][0] << 8) | u_block_part[2][1];  //模加输入右侧掩码


/////////part 3
	for(i6 = cLAT_wtcor_min[v_block_part[3][0]][0]; i6 < 8; i6++)
	{
		if(i0+i1+i2+i3+i4+i5+i6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
	for(j6=0; j6 < cLAT_WU_numb[v_block_part[3][0]][0][i6]; j6++)
	{
		w_block_part[3][0] = cLAT_W[v_block_part[3][0]][0][i6][j6];
		u_block_part[3][0] = cLAT_U[v_block_part[3][0]][0][i6][j6];
		e_Mxor_part[3] = cLAT_UVW_bro[u_block_part[3][0]][v_block_part[3][0]][w_block_part[3][0]][0];

	for(i7 = cLAT_wtcor_min[v_block_part[3][1]][e_Mxor_part[3]]; i7 <= 8; i7++)
	{
		if(i0 + i1 +i2+i3+i4+i5+i6+i7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j7=0; j7 < cLAT_WU_numb[v_block_part[3][1]][e_Mxor_part[3]][i7]; j7++)
	{
		w_block_part[3][1] = cLAT_W[v_block_part[3][1]][e_Mxor_part[3]][i7][j7];
		u_block_part[3][1] = cLAT_U[v_block_part[3][1]][e_Mxor_part[3]][i7][j7];

		Input_w_part[3] = (w_block_part[3][0] << 8) | w_block_part[3][1];  //模加输入右侧掩码
		Input_u_part[3] = (u_block_part[3][0] << 8) | u_block_part[3][1];  //模加输入右侧掩码


/////////处理本轮的输出掩码
		//part 0
		tmp_right_L[0] = mask_Xr[1] ^ Input_w_part[0];
		X_128_r[1][search_round + 1] = ((tmp_right_L[0] << rol_b) |
				(tmp_right_L[0] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[0][search_round + 1] = X_128_r[1][search_round + 1] ^ Input_u_part[0];
		r_mask_Xr[0] = X_128_r[0][search_round + 1];
		r_mask_Xr[1] = X_128_r[1][search_round + 1];

		//part 1
		tmp_right_L[1] = mask_Xr[3] ^ Input_w_part[1];
		X_128_r[3][search_round + 1] = ((tmp_right_L[1] << rol_b) |
				(tmp_right_L[1] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[2][search_round + 1] = X_128_r[3][search_round + 1] ^ Input_u_part[1];
		r_mask_Xr[2] = X_128_r[2][search_round + 1];
		r_mask_Xr[3] = X_128_r[3][search_round + 1];

		//part 2
		tmp_right_L[2] = mask_Xr[5] ^ Input_w_part[2];
		X_128_r[5][search_round + 1] = ((tmp_right_L[2] << rol_b) |
				(tmp_right_L[2] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[4][search_round + 1] = X_128_r[5][search_round + 1] ^ Input_u_part[2];
		r_mask_Xr[4] = X_128_r[4][search_round + 1];
		r_mask_Xr[5] = X_128_r[5][search_round + 1];

		//part 3
		tmp_right_L[3] = mask_Xr[7] ^ Input_w_part[3];
		X_128_r[7][search_round + 1] = ((tmp_right_L[3] << rol_b) |
				(tmp_right_L[3] >> (blocksize_len-rol_b))) & Bit_Align; //rol left
		X_128_r[6][search_round + 1] = X_128_r[7][search_round + 1] ^ Input_u_part[3];
		r_mask_Xr[6] = X_128_r[6][search_round + 1];
		r_mask_Xr[7] = X_128_r[7][search_round + 1];


		wt_block[0][search_round] = i0 + i1;
		wt_block[1][search_round] = i2 + i3;
		wt_block[2][search_round] = i4 + i5;
		wt_block[3][search_round] = i6 + i7;

		P_w[search_round] = wt_block[0][search_round] +
				wt_block[1][search_round] +
				wt_block[2][search_round] +
				wt_block[3][search_round];  //当前轮的线性相关性重量

//		if(P_w[search_round] == w_cmp )
		{
			//best = 1;
			//n_P_bestofR_w[search_round] = Bn_w;

		if((search_round % 4) == 0) //下一轮为 5,9,13...
		{
			round_L = search_round/4;
			//L前的输出掩码需要输出
			for(j=0;j<8;j++)
			{
				IN128_L_X[round_L][j] = r_mask_Xr[j];  //记录的是L变换前的值
			}

			L_L = r_mask_Xr[4] ^ r_mask_Xr[5] ^ r_mask_Xr[6] ^ r_mask_Xr[7];
			L_L_tmp = ((L_L >> 8) |	(L_L << (blocksize_len - 8))) & Bit_Align;//rol right

			r_mask_Xr_L[0] = r_mask_Xr[4];
			r_mask_Xr_L[1] = r_mask_Xr[5];
			r_mask_Xr_L[2] = r_mask_Xr[6];
			r_mask_Xr_L[3] = r_mask_Xr[7];
			r_mask_Xr_L[4] = r_mask_Xr[0] ^ r_mask_Xr[6] ^ L_L_tmp;
			r_mask_Xr_L[5] = r_mask_Xr[1] ^ r_mask_Xr[5] ^ L_L_tmp;
			r_mask_Xr_L[6] = r_mask_Xr[2] ^ r_mask_Xr[4] ^ L_L_tmp;
			r_mask_Xr_L[7] = r_mask_Xr[3] ^ r_mask_Xr[7] ^ L_L_tmp;

			for(j=0;j<8;j++)
			{
				X_128_r[j][search_round + 1] = r_mask_Xr_L[j];
				r_mask_Xr[j] = r_mask_Xr_L[j];
			}
		}
		}
/*
		printf(" search_round N :%d \n", search_round);
		for(j=0;j<8;j++)
		{
			//printf("%x ", X_128_r[j][search_round +1]);
			printf("%x ", r_mask_Xr[j]);
		}
		printf("\n " );
*/

		Not_eq = 0;
		for(j=0;j<8;j++)
		{
			if(X_128_r[j][search_round +1]  !=  OUT_Y_Mask[j] ) //u16 OUT_Y_Mask[8] = {0};
			{
				Not_eq = 1;
				//break;
			}
		}

		if( Not_eq == 1)
		{
			continue;
		}

		count++;
		Bn_w = p_sumof_r + P_w[search_round] ;
		printf("count: %d    weight: %d \n",count,Bn_w);
		wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;

	}}}}
	}}}}
	}}}}
	}}}}
	return best;
}



////////////////////////////////搜索Chaskey的最优线性特征的代码//////////////////////////////
u32 Chaskey_Linear_trail_search_entry(u16 search_round)
{
	u32 best = 0;
	u16 i = 0;
	FILE* CHASKEY_linear_Bn;

	CHASKEY_linear_Bn = fopen ("../tmp/Chaskey_linear_Bn_wt.xlsx", "a+"); //  "w+"); //
	if(sc_blocksize != 128)
	{
		printf("The block size of CHASKEY should be 128 bits. \n");
		return 0;
	}

	// For chaskey modular additon is 32 bits.
	blocksize_len = 32;
	Bit_Align = 0xFFFFFFFF;
	ValueMax_Align = 0x7FFFFFFF;
	V_MSB = 0x80000000;


	printf("Constructing CHASKEY-128 cLAT Tables... \n");
	//构造部分的线性相关性近似表cLAT
	ARX_cLAT_construct();
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct CHASKEY-128 cLAT: %.2f seconds.  \n", run_time);

	Bn_w = 0;
	if(search_round > 1)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(CHASKEY_linear_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		Bn_w = n_P_bestofR_w[search_round -1] - 1;
	}


		Bn_w = 59;  //直接设定开始的概率重量,快速达到期望的概率重量
			do
			{
				Bn_w = Bn_w + 1;
				printf("Searching SPARX-128 Bn_w: %d \n", Bn_w);

				// Search Entry.
				//best = Chaskey_R1_ADD_wt_inc(search_round);  //效率低
				best = Chaskey_R1_ADD_i_tuples(search_round, 0); //效率高
/*
				u32 XV_out[4] = {0}; //对应输出的v0--v3
				XV_out[0] = 0x50e73286;
				XV_out[1] = 0x008241a0;
				XV_out[2] = 0x5161469b;
				XV_out[3] = 0x40d436a6;
				best = Chaskey_Middle_Rounds_UperHalf(1,1, XV_out);
*/


				time_Round = clock();
				run_time =  (time_Round - time_ARX_cLAT) / CLOCKS_PER_SEC;
				printf("Time: %.2f seconds.  \n", run_time);
			}while(Bn_w !=  n_P_bestofR_w[search_round]);   //end conditions.

			print_Chaskey_resoult(search_round);  //打印CHASKEY的输入输出掩码

			time_finish = clock();
			run_time = (double)(time_finish - time_ARX_cLAT) / CLOCKS_PER_SEC;
			printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours == %.2f days. \n", run_time,run_time/60.0,run_time/3600.0,run_time/86400.0 );
			printf("Auto-search CHASKEY optimal linear trails END! \n");
			printf("|************************************************************************|\n");
			fclose(CHASKEY_linear_Bn);

	return best;
}

u32 Chaskey_R1_ADD_wt_inc(u16 search_round)
{
	u32 best = 0;
	u16 wt_round_1 = 0;
	u16 wt_Block_0 = 0,wt_Block_1 = 1,wt_Block_2 = 0,wt_Block_3 = 0;
	u16 i = 0;

	// 限定SPARX-128的首轮的概率重量
	for(wt_round_1 = 0; wt_round_1 < 16; wt_round_1++)  //0::n-1  //各个分块最多15比特的概率重量:61
	{
		// thr_d : the bits number of alpha/beta/gamma that the position not equal at the same time.
		if ((wt_round_1 + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::
		}
		P_w[1] = wt_round_1;

		for(wt_Block_0=0; wt_Block_0 <= wt_round_1; wt_Block_0++) //15
		{
			for(wt_Block_1=0; wt_Block_1 <= wt_round_1; wt_Block_1++) //15
			{
				for(wt_Block_2=0; wt_Block_2 <= wt_round_1; wt_Block_2++) //15
				{
					for(wt_Block_3=0; wt_Block_3 <= wt_round_1; wt_Block_3++)//15
					{
						if((wt_Block_0 + wt_Block_1 + wt_Block_2 + wt_Block_3) == wt_round_1)
						{
							//printf("TTTTTTEST 1 \n");
							Chaskey_Round_ADD_wt[1][0] = wt_Block_0;
							Chaskey_Round_ADD_wt[1][1] = wt_Block_1;
							Chaskey_Round_ADD_wt[1][2] = wt_Block_2;
							Chaskey_Round_ADD_wt[1][3] = wt_Block_3;

							//根据每个模加的相关性重量构造对应的输入输出掩码元祖
							best = Chaskey_R1_ADD_i_tuples(search_round,0);

							if(best== 1)
							{
								for(i=0; i<4; i++)
								{
									wt_block[i][2] = R2_wt_part[i];
								}
								return 1;
							}
	}}}}}}

	return best;
}


u32 Chaskey_R1_ADD_i_tuples(u16 search_round, u16 ADD_part)
{
	u32 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 part_wt = 0;
	u16 sum_part_wt =0;
	u16 part_i = 0;

	u64 M0 = 0;
	u64 N0 = 31; //blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;

	//printf(" L1 \n");
	///////////////////round 1 entry/////////////////////
	if(ADD_part >= 4)
	{
		for(part_i=0; part_i< 4; part_i++)
		{
			sum_part_wt += Chaskey_Round_ADD_wt[1][part_i];
		}
		P_w[1] = sum_part_wt;
		best = Chaskey_R1_comb_MASKs(search_round);
		return best;
	}
	else
	{
		for(part_i=0; part_i< ADD_part; part_i++)
		{
			sum_part_wt += Chaskey_Round_ADD_wt[1][part_i];
		}
	}



//	part_wt = Chaskey_R1_ADD_wt[ADD_part];
	for(part_wt = 0; part_wt < 2; part_wt++)  //0::n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if( (sum_part_wt + part_wt + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}

		M0 = part_wt;  //
		Chaskey_Round_ADD_wt[1][ADD_part] = M0;
		//P_w[1] = M0; //相关性重量的记录数组

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			Chaskey_R1_ADD_i_UVW[ADD_part][0] = Input_u;
			Chaskey_R1_ADD_i_UVW[ADD_part][1] = Input_v;
			Chaskey_R1_ADD_i_UVW[ADD_part][2] = Input_w;

			//直接跳转到第1轮各个部分的内部构造
			best = Chaskey_R1_ADD_i_tuples(search_round,ADD_part+1);

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;

			Chaskey_R1_ADD_i_UVW[ADD_part][0] = Input_u;
			Chaskey_R1_ADD_i_UVW[ADD_part][1] = Input_v;
			Chaskey_R1_ADD_i_UVW[ADD_part][2] = Input_w;

			//直接跳转到第1轮各个部分加法的内部构造
			best = Chaskey_R1_ADD_i_tuples(search_round,ADD_part+1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			//直接跳转到第1轮各个部分的内部构造
//			printf("1111  ADD_part: %d  C0[1]:%d \n", ADD_part,C0[1]);
			best = Chaskey_R1_ADD_Last(search_round,
					ADD_part,part_wt,
					C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHASKEY_Linear;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHASKEY_Linear;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHASKEY_Linear;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHASKEY_Linear;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHASKEY_Linear;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
	CHASKEY_Linear:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}
///////////////输出其它的分布模式/////////////////
//				printf("222 ADD_part: %d  \n", ADD_part);
				//直接跳转到第1轮各个部分的内部构造
				best = Chaskey_R1_ADD_Last(search_round,
						ADD_part,part_wt,
						C0);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}

	return best;
}


u16 Chaskey_R1_ADD_Last(u16 search_round,
		u16 part, u16 Corr_1, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

		//跳转到高比特分析
		best = Chaskey_R1_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				part,Corr_1, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = Chaskey_R1_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				part,Corr_1, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = Chaskey_R1_ADD_Middle(search_round,
					Input_u, Input_v, Input_w,
					part,Corr_1, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}

u16 Chaskey_R1_ADD_Middle(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 part, u16 Corr_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= Corr_1 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = Chaskey_R1_ADD_MSB(search_round,
				tmp_U,tmp_V,tmp_W,
				part,Corr_1, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

				if(current_index <= blocksize_len -2)
				{
				//跳转到高比特分析
				best = Chaskey_R1_ADD_Middle(search_round,
						tmp_U, tmp_V, tmp_W,
						part,Corr_1, Corr_tmp_inc, posi,
						current_index + 1, Fwt);
				}
				else
				{
					best = Chaskey_R1_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							part,Corr_1, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//跳转到高比特分析
				best = Chaskey_R1_ADD_Middle(search_round,
						Input_u, Input_v, Input_w,
						part,Corr_1, Corr_tmp_inc, posi,
						current_index +1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = Chaskey_R1_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							part,Corr_1, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = Chaskey_R1_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							part,Corr_1, Corr_tmp_inc +1, posi,
							current_index +1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 Chaskey_R1_ADD_MSB(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 part, u16 Corr_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;



		if(Corr_tmp_inc > Corr_1)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
		{
			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				Chaskey_R1_ADD_i_UVW[part][0] = tmp_U;
				Chaskey_R1_ADD_i_UVW[part][1] = tmp_V;
				Chaskey_R1_ADD_i_UVW[part][2] = tmp_W;

				//跳转 第1轮的下一个块
				best = Chaskey_R1_ADD_i_tuples(search_round,part+1);
			}
			else
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				Chaskey_R1_ADD_i_UVW[part][0] = Input_u;
				Chaskey_R1_ADD_i_UVW[part][1] = Input_v;
				Chaskey_R1_ADD_i_UVW[part][2] = Input_w;

				//跳转 第1轮的下一个块
				best = Chaskey_R1_ADD_i_tuples(search_round,part+1);
			}
		}
		else  // Corr_tmp_inc == part_wt 搜索的当前wt与期望的相关性重量相等
		{
			if( (posi[Corr_1]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0; //!= >
			{
				if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
				{
					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = Chaskey_R1_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							part, Corr_1, Corr_tmp_inc,posi,
							current_index +1, Fwt);
				}
				else
				{
					// UVW_i 为7
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
					Input_w = tmp_W | (bit_i << current_index); //该位置置1

					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = Chaskey_R1_ADD_MSB(search_round,
							Input_u, Input_v, Input_w,
							part, Corr_1, Corr_tmp_inc, posi,
							current_index +1, Fwt);
	#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
	#endif
		}
			}
			else  //(posi[part_wt]-1) == current_index
			{

			if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW[i+1]位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					Chaskey_R1_ADD_i_UVW[part][0] = Input_u;
					Chaskey_R1_ADD_i_UVW[part][1] = Input_v;
					Chaskey_R1_ADD_i_UVW[part][2] = Input_w;
/*
					printf("Input_u: 0x%08llx Input_v: 0x%08llx Input_w: 0x%08llx ",Input_u,Input_v,Input_w);
					u16 j=0;
					for(j=0;j<3;j++)
					{
						printf("Chaskey_R1_ADD_i_UVW[3][%d]: 0x%08llx ",j,Chaskey_R1_ADD_i_UVW[part][j]);
					}
					printf("\n");
*/
					//跳转 第1轮的下一个块
					best = Chaskey_R1_ADD_i_tuples(search_round,part+1);
	#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
	#endif
				}
			}
			else
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW的最高位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					Chaskey_R1_ADD_i_UVW[part][0] = Input_u;
					Chaskey_R1_ADD_i_UVW[part][1] = Input_v;
					Chaskey_R1_ADD_i_UVW[part][2] = Input_w;

					//跳转 第1轮的下一个块
					best = Chaskey_R1_ADD_i_tuples(search_round,part+1);
	#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return best;
	}
	#endif
		}}
			}}
		return best;



/*
	if( (posi[Corr_1]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
	{
		//Fwt = 0;//当前M向量该比特位无相关性重量
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
			//Input_u = tmp_U | (0 << current_index); //该位置置0
			//Input_v = tmp_V | (0 << current_index); //该位置置0
			//Input_w = tmp_W | (0 << current_index); //该位置置0

			if(current_index <= blocksize_len-2)
			{
				//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
				best = Chaskey_R1_ADD_MSB(search_round,
						tmp_U,tmp_V,tmp_W,
						part,Corr_1, Corr_tmp_inc,posi,
						current_index + 1,Fwt);
			}
			else //直接跳转到第1轮的右侧
			{
				Chaskey_R1_ADD_i_UVW[part][0] = tmp_U;
				Chaskey_R1_ADD_i_UVW[part][1] = tmp_V;
				Chaskey_R1_ADD_i_UVW[part][2] = tmp_W;
				//跳转 第1轮的下一个块
				best = Chaskey_R1_ADD_i_tuples(search_round, part+1);
			}
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
			best = Chaskey_R1_ADD_MSB(search_round,
					Input_u, Input_v, Input_w,
					part,Corr_1, Corr_tmp_inc,posi,
					current_index + 1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
	}
	else //////当前M向量该比特位you相关性重量, M_i = 1; (posi[Corr_1]-1) == current_index .
	{
		//Fwt = 1;//当前M向量该比特位you相关性重量
		//Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

		if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_B_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_B_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_B_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				Chaskey_R1_ADD_i_UVW[part][0] = Input_u;
				Chaskey_R1_ADD_i_UVW[part][1] = Input_v;
				Chaskey_R1_ADD_i_UVW[part][2] = Input_w;

				//跳转 第1轮的下一个块
				best = Chaskey_R1_ADD_i_tuples(search_round,part+1);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
			}
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_A_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_A_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_A_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				Chaskey_R1_ADD_i_UVW[part][0] = Input_u;
				Chaskey_R1_ADD_i_UVW[part][1] = Input_v;
				Chaskey_R1_ADD_i_UVW[part][2] = Input_w;

				//跳转 第1轮的下一个块
				best = Chaskey_R1_ADD_i_tuples(search_round,part+1);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return best;
}
#endif
			}
		}
	}
	return best;
	*/
}



u32 Chaskey_R1_comb_MASKs(u16 search_round)
{
	u32 best=0;

//	u32 XV_in[4] = {0}; //对应输入的v0--v3
	u32 XV_tmp[4] = {0};   //对应中间半轮的 tmp_V0---tmp_V3,需要注意下
	u32 XV_out[4] = {0}; //对应输出的v0--v3

    XV[0][1] = Chaskey_R1_ADD_i_UVW[0][1];
    XV[2][1] = Chaskey_R1_ADD_i_UVW[1][1];

	XV_tmp[1] = Chaskey_R1_ADD_i_UVW[2][1];
	XV_tmp[2] = Chaskey_R1_ADD_i_UVW[3][1];
	XV_tmp[0] = (Chaskey_R1_ADD_i_UVW[0][0] ^
			ROTATE_RIGHT(XV_tmp[2],16,blocksize_len)) & Bit_Align;
	XV_tmp[3] = Chaskey_R1_ADD_i_UVW[2][1] ^ Chaskey_R1_ADD_i_UVW[1][0] ;

	XV[1][1] = (Chaskey_R1_ADD_i_UVW[0][2] ^
			ROTATE_RIGHT(XV_tmp[0],5,blocksize_len)) & Bit_Align;
	XV[3][1] = (Chaskey_R1_ADD_i_UVW[1][2] ^
			ROTATE_RIGHT(XV_tmp[3],8,blocksize_len)) & Bit_Align;


	XV_out[3] = Chaskey_R1_ADD_i_UVW[3][2] ^ XV_tmp[3];
	XV_out[3] = ROTATE_LEFT(XV_out[3],13,blocksize_len) & Bit_Align;
	XV_out[0] = XV_out[3] ^ Chaskey_R1_ADD_i_UVW[3][0];

	XV_out[1] = Chaskey_R1_ADD_i_UVW[2][2] ^ XV_tmp[0];
	XV_out[1] = ROTATE_LEFT(XV_out[1],7,blocksize_len) & Bit_Align;
	XV_out[2] = XV_out[1] ^ Chaskey_R1_ADD_i_UVW[2][0];
	XV_out[2] = ROTATE_LEFT(XV_out[2],16,blocksize_len) & Bit_Align;


	if(search_round > 1)
	{
		best = Chaskey_Middle_Rounds_UperHalf(search_round,2, XV_out);
#if 1   //是否找到第一条最优路径就返回？
if( best == 1 )
{
//	XV[0][1] = XV_in[0];
//	XV[1][1] = XV_in[1];
//	XV[2][1] = XV_in[2];
//	XV[3][1] = XV_in[3];

	XV[0][2] = XV_out[0];
	XV[1][2] = XV_out[1];
	XV[2][2] = XV_out[2];
	XV[3][2] = XV_out[3];

	//记录第1轮的中间态
	XV_M[0][1] = XV_tmp[0];
	XV_M[1][1] = XV_tmp[1];
	XV_M[2][1] = XV_tmp[2];
	XV_M[3][1] = XV_tmp[3];
	return 1;
}
#endif
	}
	else
	{
		//若搜索的是第1轮，则直接打印

//		XV[0][1] = XV_in[0];
//		XV[1][1] = XV_in[1];
//		XV[2][1] = XV_in[2];
//		XV[3][1] = XV_in[3];

		XV[0][2] = XV_out[0];
		XV[1][2] = XV_out[1];
		XV[2][2] = XV_out[2];
		XV[3][2] = XV_out[3];

		//记录第1轮的中间态
		XV_M[0][1] = XV_tmp[0];
		XV_M[1][1] = XV_tmp[1];
		XV_M[2][1] = XV_tmp[2];
		XV_M[3][1] = XV_tmp[3];

		if(XV[0][1] != 0)
		{
			n_P_bestofR_w[1] = P_w[1];
			return 1;
		}
	}

	return best;
}



u32 Chaskey_Middle_Rounds_UperHalf(u16 search_round, u16 current_round, u32 *mask_Xr)
{
	u32 best=0;

	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u16 wt_upper_half_round = 0;


	u64 Input_v_L_part[4] = {0};  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_L_part[4] = {0};  //模加输入右侧掩码
	u64 Input_u_L_part[4] = {0};  //模加输出掩码
	u64 Input_w_L = 0;  //模加输入右侧掩码
	u64 Input_u_L = 0;  //模加输出掩码

	u64 Input_v_R_part[4] = {0};  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_R_part[4] = {0};  //模加输入右侧掩码
	u64 Input_u_R_part[4] = {0};  //模加输出掩码
	u64 Input_w_R = 0;  //模加输入右侧掩码
	u64 Input_u_R = 0;  //模加输出掩码


	u64 e_Mxor_L_part[4] = {0}; //用于记录M向量的高比特的异或和
	u64 e_Mxor_R_part[4] = {0}; //用于记录M向量的高比特的异或和

	u32 tmp_VX[4] = {0};

	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;


//	printf(" enter Chaskey_Middle_Rounds_UperHalf \n ");
	if(search_round <= current_round)
	{
		best = Chaskey_N_Rounds_UperHalf(search_round, mask_Xr);
		return best;
	}

	for(i=1;i<current_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = Bn_w - p_sumof_r - n_P_bestofR_w[search_round - current_round];

	//对于每个分块都将32比特的分组分别分成4个8比特的块，并记录可能的最小相关性重量
	for(i=0; i<4; i++)
	{
		Input_v_L_part[i] = (mask_Xr[0] >> 8*(3-i)) & 0xFF;//rol right
		wt_cor_bound += cLAT_wtcor_min[Input_v_L_part[i]][0]; 	//bound wt
		Input_v_R_part[i] = (mask_Xr[2] >> 8*(3-i)) & 0xFF;//rol right
		wt_cor_bound += cLAT_wtcor_min[Input_v_R_part[i]][0]; 	//bound wt
	}

	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}


/////////part L-0
		for(i0 = cLAT_wtcor_min[Input_v_L_part[0]][0]; i0 < 8; i0++)
		{
			if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
		for(j0=0; j0 < cLAT_WU_numb[Input_v_L_part[0]][0][i0]; j0++)
		{
			Input_w_L_part[0] = cLAT_W[Input_v_L_part[0]][0][i0][j0];
			Input_u_L_part[0] = cLAT_U[Input_v_L_part[0]][0][i0][j0];

			e_Mxor_L_part[0] = cLAT_UVW_bro[Input_u_L_part[0]][Input_v_L_part[0]][Input_w_L_part[0]][0];

/////////part L-1
		for(i1 = cLAT_wtcor_min[Input_v_L_part[1]][e_Mxor_L_part[0]]; i1 <= 8; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cLAT_WU_numb[Input_v_L_part[1]][e_Mxor_L_part[0]][i1]; j1++)
		{
			Input_w_L_part[1] = cLAT_W[Input_v_L_part[1]][e_Mxor_L_part[0]][i1][j1];
			Input_u_L_part[1] = cLAT_U[Input_v_L_part[1]][e_Mxor_L_part[0]][i1][j1];

			e_Mxor_L_part[1] = cLAT_UVW_bro[Input_u_L_part[1]][Input_v_L_part[1]][Input_w_L_part[1]][e_Mxor_L_part[0]];

/////////part L-2
		for(i2 = cLAT_wtcor_min[Input_v_L_part[2]][e_Mxor_L_part[1]]; i2 <= 8; i2++)
		{
			if(i0+i1+i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j2=0; j2 < cLAT_WU_numb[Input_v_L_part[2]][e_Mxor_L_part[1]][i2]; j2++)
		{
			Input_w_L_part[2] = cLAT_W[Input_v_L_part[2]][e_Mxor_L_part[1]][i2][j2];
			Input_u_L_part[2] = cLAT_U[Input_v_L_part[2]][e_Mxor_L_part[1]][i2][j2];

			e_Mxor_L_part[2] = cLAT_UVW_bro[Input_u_L_part[2]][Input_v_L_part[2]][Input_w_L_part[2]][e_Mxor_L_part[1]];

/////////part L-3
		for(i3 = cLAT_wtcor_min[Input_v_L_part[3]][e_Mxor_L_part[2]]; i3 <= 8; i3++)
		{
			if(i0 + i1 +i2+i3> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < cLAT_WU_numb[Input_v_L_part[3]][e_Mxor_L_part[2]][i3]; j3++)
		{
			Input_w_L_part[3] = cLAT_W[Input_v_L_part[3]][e_Mxor_L_part[2]][i3][j3];
			Input_u_L_part[3] = cLAT_U[Input_v_L_part[3]][e_Mxor_L_part[2]][i3][j3];

			Input_w_L = (Input_w_L_part[0] << 24) | (Input_w_L_part[1] << 16) |
					(Input_w_L_part[2] << 8) | Input_w_L_part[3];  //模加输入右侧掩码
			Input_u_L = (Input_u_L_part[0] << 24) | (Input_u_L_part[1] << 16) |
					(Input_u_L_part[2] << 8) | Input_u_L_part[3];  //模加输入右侧掩码


/////////part R-0
		for(i4 = cLAT_wtcor_min[Input_v_R_part[0]][0]; i4 < 8; i4++)
		{
			if(i0+i1+i2+i3+i4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j4=0; j4 < cLAT_WU_numb[Input_v_R_part[0]][0][i4]; j4++)
		{
			Input_w_R_part[0] = cLAT_W[Input_v_R_part[0]][0][i4][j4];
			Input_u_R_part[0] = cLAT_U[Input_v_R_part[0]][0][i4][j4];

			e_Mxor_R_part[0] = cLAT_UVW_bro[Input_u_R_part[0]][Input_v_R_part[0]][Input_w_R_part[0]][0];

/////////part R-1
		for(i5 = cLAT_wtcor_min[Input_v_R_part[1]][e_Mxor_R_part[0]]; i5 <= 8; i5++)
		{
			if(i0 + i1 +i2+i3+i4+i5> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j5=0; j5 < cLAT_WU_numb[Input_v_R_part[1]][e_Mxor_R_part[0]][i5]; j5++)
		{
			Input_w_R_part[1] = cLAT_W[Input_v_R_part[1]][e_Mxor_R_part[0]][i5][j5];
			Input_u_R_part[1] = cLAT_U[Input_v_R_part[1]][e_Mxor_R_part[0]][i5][j5];

			e_Mxor_R_part[1] = cLAT_UVW_bro[Input_u_R_part[1]][Input_v_R_part[1]][Input_w_R_part[1]][e_Mxor_R_part[0]];

/////////part R-2
		for(i6 = cLAT_wtcor_min[Input_v_R_part[2]][e_Mxor_R_part[1]]; i6 <= 8; i6++)
		{
			if(i0+i1+i2+i3+i4+i5+i6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j6=0; j6 < cLAT_WU_numb[Input_v_R_part[2]][e_Mxor_R_part[1]][i6]; j6++)
		{
			Input_w_R_part[2] = cLAT_W[Input_v_R_part[2]][e_Mxor_R_part[1]][i6][j6];
			Input_u_R_part[2] = cLAT_U[Input_v_R_part[2]][e_Mxor_R_part[1]][i6][j6];

			e_Mxor_R_part[2] = cLAT_UVW_bro[Input_u_R_part[2]][Input_v_R_part[2]][Input_w_R_part[2]][e_Mxor_R_part[1]];

/////////part R-3
		for(i7 = cLAT_wtcor_min[Input_v_R_part[3]][e_Mxor_R_part[2]]; i7 <= 8; i7++)
		{
			if(i0 + i1 +i2+i3+i4+i5+i6+i7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j7=0; j7 < cLAT_WU_numb[Input_v_R_part[3]][e_Mxor_R_part[2]][i7]; j7++)
		{
			Input_w_R_part[3] = cLAT_W[Input_v_R_part[3]][e_Mxor_R_part[2]][i7][j7];
			Input_u_R_part[3] = cLAT_U[Input_v_R_part[3]][e_Mxor_R_part[2]][i7][j7];

			Input_w_R = (Input_w_R_part[0] << 24) | (Input_w_R_part[1] << 16) |
					(Input_w_R_part[2] << 8) | Input_w_R_part[3];  //模加输入右侧掩码
			Input_u_R = (Input_u_R_part[0] << 24) | (Input_u_R_part[1] << 16) |
					(Input_u_R_part[2] << 8) | Input_u_R_part[3];  //模加输入右侧掩码


/////////处理本 半个 轮的输出掩码
			tmp_VX[0] = Input_w_L ^ mask_Xr[0];
			tmp_VX[0] = ROTATE_LEFT(tmp_VX[0],5,blocksize_len) & Bit_Align;

			tmp_VX[2] = tmp_VX[0] ^ Input_u_L;
			tmp_VX[2] = ROTATE_LEFT(tmp_VX[2],16,blocksize_len) & Bit_Align;

			tmp_VX[3] = Input_w_R ^ mask_Xr[3];
			tmp_VX[3] = ROTATE_LEFT(tmp_VX[3],8,blocksize_len) & Bit_Align;

			tmp_VX[1] = Input_u_R ^ tmp_VX[3];

			//记录每一个ADD的相关性重量
			Chaskey_Round_ADD_wt[current_round][0] = i0 + i1 + i2 + i3;
			Chaskey_Round_ADD_wt[current_round][1] = i4 + i5 + i6 + i7;
			//Chaskey_Round_ADD_wt[current_round][2] = i4 + i5;
			//Chaskey_Round_ADD_wt[current_round][3] = i6 + i7;
			//当前轮的线性相关性重量
			wt_upper_half_round = i0 + i1 + i2 + i3 + i4 + i5 + i6 + i7;


	//		printf(" Next  search_round r: %d \n", cur_round);
			//跳转 本轮的下半部分 current_round
			best = Chaskey_Middle_Rounds_DownHalf(search_round, current_round,
					w_cmp, wt_upper_half_round, tmp_VX);
	#if 1   //是否找到第一条最优路径就返回？
	if( best == 1 )
		return 1;
	#endif
		}}}}
		}}}}
		}}}}
		}}}}

	return best;
}


u32 Chaskey_Middle_Rounds_DownHalf(u16 search_round, u16 current_round,
		u16 wt_cmpr, u16 uper_wt, u32 *mask_Xr)
{
	u32 best=0;

	u16 i = 0;
//	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u16 wt_down_half_round = 0;

	u64 Input_v_L_part[4] = {0};  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_L_part[4] = {0};  //模加输入右侧掩码
	u64 Input_u_L_part[4] = {0};  //模加输出掩码
	u64 Input_w_L = 0;  //模加输入右侧掩码
	u64 Input_u_L = 0;  //模加输出掩码

	u64 Input_v_R_part[4] = {0};  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_R_part[4] = {0};  //模加输入右侧掩码
	u64 Input_u_R_part[4] = {0};  //模加输出掩码
	u64 Input_w_R = 0;  //模加输入右侧掩码
	u64 Input_u_R = 0;  //模加输出掩码


	u64 e_Mxor_L_part[4] = {0}; //用于记录M向量的高比特的异或和
	u64 e_Mxor_R_part[4] = {0}; //用于记录M向量的高比特的异或和

	u32 tmp_VX[4] = {0};

	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;



	//对于每个分块都将32比特的分组分别分成4个8比特的块，并记录可能的最小相关性重量
	for(i=0; i<4; i++)
	{
		Input_v_L_part[i] = (mask_Xr[1] >> 8*(3-i)) & 0xFF;//注意为tmp_V1的值为加法的V,与上半不同
		wt_cor_bound += cLAT_wtcor_min[Input_v_L_part[i]][0]; 	//bound wt
		Input_v_R_part[i] = (mask_Xr[2] >> 8*(3-i)) & 0xFF;//rol right
		wt_cor_bound += cLAT_wtcor_min[Input_v_R_part[i]][0]; 	//bound wt
	}

	if( wt_cor_bound + uper_wt > wt_cmpr)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}
	w_cmp = wt_cmpr - uper_wt;


/////////part L-0
		for(i0 = cLAT_wtcor_min[Input_v_L_part[0]][0]; i0 < 8; i0++)
		{
			if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
		for(j0=0; j0 < cLAT_WU_numb[Input_v_L_part[0]][0][i0]; j0++)
		{
			Input_w_L_part[0] = cLAT_W[Input_v_L_part[0]][0][i0][j0];
			Input_u_L_part[0] = cLAT_U[Input_v_L_part[0]][0][i0][j0];
			e_Mxor_L_part[0] = cLAT_UVW_bro[Input_u_L_part[0]][Input_v_L_part[0]][Input_w_L_part[0]][0];

/////////part L-1
		for(i1 = cLAT_wtcor_min[Input_v_L_part[1]][e_Mxor_L_part[0]]; i1 <= 8; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cLAT_WU_numb[Input_v_L_part[1]][e_Mxor_L_part[0]][i1]; j1++)
		{
			Input_w_L_part[1] = cLAT_W[Input_v_L_part[1]][e_Mxor_L_part[0]][i1][j1];
			Input_u_L_part[1] = cLAT_U[Input_v_L_part[1]][e_Mxor_L_part[0]][i1][j1];
			e_Mxor_L_part[1] = cLAT_UVW_bro[Input_u_L_part[1]][Input_v_L_part[1]][Input_w_L_part[1]][e_Mxor_L_part[0]];

/////////part L-2
		for(i2 = cLAT_wtcor_min[Input_v_L_part[2]][e_Mxor_L_part[1]]; i2 <= 8; i2++)
		{
			if(i0+i1+i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j2=0; j2 < cLAT_WU_numb[Input_v_L_part[2]][e_Mxor_L_part[1]][i2]; j2++)
		{
			Input_w_L_part[2] = cLAT_W[Input_v_L_part[2]][e_Mxor_L_part[1]][i2][j2];
			Input_u_L_part[2] = cLAT_U[Input_v_L_part[2]][e_Mxor_L_part[1]][i2][j2];
			e_Mxor_L_part[2] = cLAT_UVW_bro[Input_u_L_part[2]][Input_v_L_part[2]][Input_w_L_part[2]][e_Mxor_L_part[1]];

/////////part L-3
		for(i3 = cLAT_wtcor_min[Input_v_L_part[3]][e_Mxor_L_part[2]]; i3 <= 8; i3++)
		{
			if(i0 + i1 +i2+i3> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < cLAT_WU_numb[Input_v_L_part[3]][e_Mxor_L_part[2]][i3]; j3++)
		{
			Input_w_L_part[3] = cLAT_W[Input_v_L_part[3]][e_Mxor_L_part[2]][i3][j3];
			Input_u_L_part[3] = cLAT_U[Input_v_L_part[3]][e_Mxor_L_part[2]][i3][j3];

			Input_w_L = (Input_w_L_part[0] << 24) | (Input_w_L_part[1] << 16) |
					(Input_w_L_part[2] << 8) | Input_w_L_part[3];  //模加输入右侧掩码
			Input_u_L = (Input_u_L_part[0] << 24) | (Input_u_L_part[1] << 16) |
					(Input_u_L_part[2] << 8) | Input_u_L_part[3];  //模加输入右侧掩码


/////////part R-0
		for(i4 = cLAT_wtcor_min[Input_v_R_part[0]][0]; i4 < 8; i4++)
		{
			if(i0+i1+i2+i3+i4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j4=0; j4 < cLAT_WU_numb[Input_v_R_part[0]][0][i4]; j4++)
		{
			Input_w_R_part[0] = cLAT_W[Input_v_R_part[0]][0][i4][j4];
			Input_u_R_part[0] = cLAT_U[Input_v_R_part[0]][0][i4][j4];
			e_Mxor_R_part[0] = cLAT_UVW_bro[Input_u_R_part[0]][Input_v_R_part[0]][Input_w_R_part[0]][0];

/////////part R-1
		for(i5 = cLAT_wtcor_min[Input_v_R_part[1]][e_Mxor_R_part[0]]; i5 <= 8; i5++)
		{
			if(i0 + i1 +i2+i3+i4+i5> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j5=0; j5 < cLAT_WU_numb[Input_v_R_part[1]][e_Mxor_R_part[0]][i5]; j5++)
		{
			Input_w_R_part[1] = cLAT_W[Input_v_R_part[1]][e_Mxor_R_part[0]][i5][j5];
			Input_u_R_part[1] = cLAT_U[Input_v_R_part[1]][e_Mxor_R_part[0]][i5][j5];
			e_Mxor_R_part[1] = cLAT_UVW_bro[Input_u_R_part[1]][Input_v_R_part[1]][Input_w_R_part[1]][e_Mxor_R_part[0]];

/////////part R-2
		for(i6 = cLAT_wtcor_min[Input_v_R_part[2]][e_Mxor_R_part[1]]; i6 <= 8; i6++)
		{
			if(i0+i1+i2+i3+i4+i5+i6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j6=0; j6 < cLAT_WU_numb[Input_v_R_part[2]][e_Mxor_R_part[1]][i6]; j6++)
		{
			Input_w_R_part[2] = cLAT_W[Input_v_R_part[2]][e_Mxor_R_part[1]][i6][j6];
			Input_u_R_part[2] = cLAT_U[Input_v_R_part[2]][e_Mxor_R_part[1]][i6][j6];
			e_Mxor_R_part[2] = cLAT_UVW_bro[Input_u_R_part[2]][Input_v_R_part[2]][Input_w_R_part[2]][e_Mxor_R_part[1]];

/////////part R-3
		for(i7 = cLAT_wtcor_min[Input_v_R_part[3]][e_Mxor_R_part[2]]; i7 <= 8; i7++)
		{
			if(i0 + i1 +i2+i3+i4+i5+i6+i7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j7=0; j7 < cLAT_WU_numb[Input_v_R_part[3]][e_Mxor_R_part[2]][i7]; j7++)
		{
			Input_w_R_part[3] = cLAT_W[Input_v_R_part[3]][e_Mxor_R_part[2]][i7][j7];
			Input_u_R_part[3] = cLAT_U[Input_v_R_part[3]][e_Mxor_R_part[2]][i7][j7];

			Input_w_R = (Input_w_R_part[0] << 24) | (Input_w_R_part[1] << 16) |
					(Input_w_R_part[2] << 8) | Input_w_R_part[3];  //模加输入右侧掩码
			Input_u_R = (Input_u_R_part[0] << 24) | (Input_u_R_part[1] << 16) |
					(Input_u_R_part[2] << 8) | Input_u_R_part[3];  //模加输入右侧掩码


/////////处理本 下半个 轮的输出掩码 //注意和上半部分的旋转参数不一样
			tmp_VX[1] = Input_w_L ^ mask_Xr[0];
			tmp_VX[1] = ROTATE_LEFT(tmp_VX[1],7,blocksize_len) & Bit_Align;

			tmp_VX[2] = tmp_VX[1] ^ Input_u_L;
			tmp_VX[2] = ROTATE_LEFT(tmp_VX[2],16,blocksize_len) & Bit_Align;

			tmp_VX[3] = Input_w_R ^ mask_Xr[3];
			tmp_VX[3] = ROTATE_LEFT(tmp_VX[3],13,blocksize_len) & Bit_Align;

			tmp_VX[0] = Input_u_R ^ tmp_VX[3];


			//记录每一个ADD的相关性重量
			//Chaskey_Round_ADD_wt[current_round][0] = i0 + i1;
			//Chaskey_Round_ADD_wt[current_round][1] = i2 + i3;
			Chaskey_Round_ADD_wt[current_round][2] = i0 + i1 + i2 + i3;
			Chaskey_Round_ADD_wt[current_round][3] = i4 + i5 + i6 + i7;
			//当前轮的线性相关性重量
			wt_down_half_round = i0 + i1 + i2 + i3 + i4 + i5 + i6 + i7;
			P_w[current_round] = wt_down_half_round + uper_wt;

			//跳转 下一轮的上半部分
			best = Chaskey_Middle_Rounds_UperHalf(search_round, current_round + 1,
					tmp_VX);
#if 1   //是否找到第一条最优路径就返回？
if( best == 1 )
{
	//记录第r轮的中间态
	XV_M[0][current_round] = mask_Xr[0];
	XV_M[1][current_round] = mask_Xr[1];
	XV_M[2][current_round] = mask_Xr[2];
	XV_M[3][current_round] = mask_Xr[3];

	XV[0][current_round +1] = tmp_VX[0];
	XV[1][current_round +1] = tmp_VX[1];
	XV[2][current_round +1] = tmp_VX[2];
	XV[3][current_round +1] = tmp_VX[3];

	return 1;
}

#endif
		}}}}
		}}}}
		}}}}
		}}}}

	return best;
}

u32 Chaskey_N_Rounds_UperHalf(u16 search_round, u32 *mask_Xr)
{
	u32 best=0;

	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u16 wt_upper_half_round = 0;


	u64 Input_v_L_part[4] = {0};  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_L_part[4] = {0};  //模加输入右侧掩码
	u64 Input_u_L_part[4] = {0};  //模加输出掩码
	u64 Input_w_L = 0;  //模加输入右侧掩码
	u64 Input_u_L = 0;  //模加输出掩码

	u64 Input_v_R_part[4] = {0};  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_R_part[4] = {0};  //模加输入右侧掩码
	u64 Input_u_R_part[4] = {0};  //模加输出掩码
	u64 Input_w_R = 0;  //模加输入右侧掩码
	u64 Input_u_R = 0;  //模加输出掩码


	u64 e_Mxor_L_part[4] = {0}; //用于记录M向量的高比特的异或和
	u64 e_Mxor_R_part[4] = {0}; //用于记录M向量的高比特的异或和

	u32 tmp_VX[4] = {0};

	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;


//	printf(" enter Chaskey_N_Rounds_UperHalf \n ");

	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = Bn_w - p_sumof_r;

	//对于每个分块都将32比特的分组分别分成4个8比特的块，并记录可能的最小相关性重量
	for(i=0; i<4; i++)
	{
		Input_v_L_part[i] = (mask_Xr[0] >> 8*(3-i)) & 0xFF;//rol right
		wt_cor_bound += cLAT_wtcor_min[Input_v_L_part[i]][0]; 	//bound wt
		Input_v_R_part[i] = (mask_Xr[2] >> 8*(3-i)) & 0xFF;//rol right
		wt_cor_bound += cLAT_wtcor_min[Input_v_R_part[i]][0]; 	//bound wt
	}

	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

//	printf(" enter Chaskey_N_Rounds_UperHalf continue!! \n ");
/////////part L-0
		for(i0 = cLAT_wtcor_min[Input_v_L_part[0]][0]; i0 < 8; i0++)
		{
			if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
		for(j0=0; j0 < cLAT_WU_numb[Input_v_L_part[0]][0][i0]; j0++)
		{
			Input_w_L_part[0] = cLAT_W[Input_v_L_part[0]][0][i0][j0];
			Input_u_L_part[0] = cLAT_U[Input_v_L_part[0]][0][i0][j0];

			e_Mxor_L_part[0] = cLAT_UVW_bro[Input_u_L_part[0]][Input_v_L_part[0]][Input_w_L_part[0]][0];

/////////part L-1
		for(i1 = cLAT_wtcor_min[Input_v_L_part[1]][e_Mxor_L_part[0]]; i1 <= 8; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cLAT_WU_numb[Input_v_L_part[1]][e_Mxor_L_part[0]][i1]; j1++)
		{
			Input_w_L_part[1] = cLAT_W[Input_v_L_part[1]][e_Mxor_L_part[0]][i1][j1];
			Input_u_L_part[1] = cLAT_U[Input_v_L_part[1]][e_Mxor_L_part[0]][i1][j1];

			e_Mxor_L_part[1] = cLAT_UVW_bro[Input_u_L_part[1]][Input_v_L_part[1]][Input_w_L_part[1]][e_Mxor_L_part[0]];

/////////part L-2
		for(i2 = cLAT_wtcor_min[Input_v_L_part[2]][e_Mxor_L_part[1]]; i2 <= 8; i2++)
		{
			if(i0+i1+i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j2=0; j2 < cLAT_WU_numb[Input_v_L_part[2]][e_Mxor_L_part[1]][i2]; j2++)
		{
			Input_w_L_part[2] = cLAT_W[Input_v_L_part[2]][e_Mxor_L_part[1]][i2][j2];
			Input_u_L_part[2] = cLAT_U[Input_v_L_part[2]][e_Mxor_L_part[1]][i2][j2];

			e_Mxor_L_part[2] = cLAT_UVW_bro[Input_u_L_part[2]][Input_v_L_part[2]][Input_w_L_part[2]][e_Mxor_L_part[1]];

/////////part L-3
		for(i3 = cLAT_wtcor_min[Input_v_L_part[3]][e_Mxor_L_part[2]]; i3 <= 8; i3++)
		{
			if(i0 + i1 +i2+i3> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < cLAT_WU_numb[Input_v_L_part[3]][e_Mxor_L_part[2]][i3]; j3++)
		{
			Input_w_L_part[3] = cLAT_W[Input_v_L_part[3]][e_Mxor_L_part[2]][i3][j3];
			Input_u_L_part[3] = cLAT_U[Input_v_L_part[3]][e_Mxor_L_part[2]][i3][j3];

			//构造左边部分的输入掩码w和输出掩码u
			Input_w_L = (Input_w_L_part[0] << 24) | (Input_w_L_part[1] << 16) |
					(Input_w_L_part[2] << 8) | Input_w_L_part[3];  //模加输入右侧掩码
			Input_u_L = (Input_u_L_part[0] << 24) | (Input_u_L_part[1] << 16) |
					(Input_u_L_part[2] << 8) | Input_u_L_part[3];  //模加输入右侧掩码


/////////part R-0
		for(i4 = cLAT_wtcor_min[Input_v_R_part[0]][0]; i4 < 8; i4++)
		{
			if(i0+i1+i2+i3+i4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j4=0; j4 < cLAT_WU_numb[Input_v_R_part[0]][0][i4]; j4++)
		{
			Input_w_R_part[0] = cLAT_W[Input_v_R_part[0]][0][i4][j4];
			Input_u_R_part[0] = cLAT_U[Input_v_R_part[0]][0][i4][j4];

			e_Mxor_R_part[0] = cLAT_UVW_bro[Input_u_R_part[0]][Input_v_R_part[0]][Input_w_R_part[0]][0];

/////////part R-1
		for(i5 = cLAT_wtcor_min[Input_v_R_part[1]][e_Mxor_R_part[0]]; i5 <= 8; i5++)
		{
			if(i0 + i1 +i2+i3+i4+i5> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j5=0; j5 < cLAT_WU_numb[Input_v_R_part[1]][e_Mxor_R_part[0]][i5]; j5++)
		{
			Input_w_R_part[1] = cLAT_W[Input_v_R_part[1]][e_Mxor_R_part[0]][i5][j5];
			Input_u_R_part[1] = cLAT_U[Input_v_R_part[1]][e_Mxor_R_part[0]][i5][j5];

			e_Mxor_R_part[1] = cLAT_UVW_bro[Input_u_R_part[1]][Input_v_R_part[1]][Input_w_R_part[1]][e_Mxor_R_part[0]];

/////////part R-2
		for(i6 = cLAT_wtcor_min[Input_v_R_part[2]][0]; i6 <= 8; i6++)
		{
			if(i0+i1+i2+i3+i4+i5+i6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j6=0; j6 < cLAT_WU_numb[Input_v_R_part[2]][e_Mxor_R_part[1]][i6]; j6++)
		{
			Input_w_R_part[2] = cLAT_W[Input_v_R_part[2]][e_Mxor_R_part[1]][i6][j6];
			Input_u_R_part[2] = cLAT_U[Input_v_R_part[2]][e_Mxor_R_part[1]][i6][j6];

			e_Mxor_R_part[2] = cLAT_UVW_bro[Input_u_R_part[2]][Input_v_R_part[2]][Input_w_R_part[2]][e_Mxor_R_part[1]];

/////////part R-3
		for(i7 = cLAT_wtcor_min[Input_v_R_part[3]][e_Mxor_R_part[2]]; i7 <= 8; i7++)
		{
			if(i0 + i1 +i2+i3+i4+i5+i6+i7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j7=0; j7 < cLAT_WU_numb[Input_v_R_part[3]][e_Mxor_R_part[2]][i7]; j7++)
		{
			Input_w_R_part[3] = cLAT_W[Input_v_R_part[3]][e_Mxor_R_part[2]][i7][j7];
			Input_u_R_part[3] = cLAT_U[Input_v_R_part[3]][e_Mxor_R_part[2]][i7][j7];

			//构造右边部分的输入掩码w和输出掩码u
			Input_w_R = (Input_w_R_part[0] << 24) | (Input_w_R_part[1] << 16) |
					(Input_w_R_part[2] << 8) | Input_w_R_part[3];  //模加输入右侧掩码
			Input_u_R = (Input_u_R_part[0] << 24) | (Input_u_R_part[1] << 16) |
					(Input_u_R_part[2] << 8) | Input_u_R_part[3];  //模加输入右侧掩码

//			printf(" enter Chaskey_N_Rounds_UperHalf fuck!! \n ");
/////////处理本 半个 轮的输出掩码
			tmp_VX[0] = Input_w_L ^ mask_Xr[1];
			tmp_VX[0] = ROTATE_LEFT(tmp_VX[0],5,blocksize_len) & Bit_Align;

			tmp_VX[2] = tmp_VX[0] ^ Input_u_L;
			tmp_VX[2] = ROTATE_LEFT(tmp_VX[2],16,blocksize_len) & Bit_Align;

			tmp_VX[3] = Input_w_R ^ mask_Xr[3];
			tmp_VX[3] = ROTATE_LEFT(tmp_VX[3],8,blocksize_len) & Bit_Align;

			tmp_VX[1] = Input_u_R ^ tmp_VX[3];

			//记录每一个ADD的相关性重量
			Chaskey_Round_ADD_wt[search_round][0] = i0 + i1 + i2 + i3;
			Chaskey_Round_ADD_wt[search_round][1] = i4 + i5 + i6 + i7;
			//Chaskey_Round_ADD_wt[current_round][2] = i4 + i5;
			//Chaskey_Round_ADD_wt[current_round][3] = i6 + i7;
			//当前轮的线性相关性重量
			wt_upper_half_round = i0 + i1 + i2 + i3 + i4 + i5 + i6 + i7;

			//跳转 本轮的下半部分 current_round
			best = Chaskey_N_Rounds_DownHalf(search_round,
					w_cmp, wt_upper_half_round, tmp_VX);
#if 1   //是否找到第一条最优路径就返回？
if( best == 1 )
	return 1;
#endif

		}}}}
		}}}}
		}}}}
		}}}}

	return best;
}



u32 Chaskey_N_Rounds_DownHalf(u16 search_round,
		u16 wt_cmpr, u16 uper_wt, u32 *mask_Xr)
{
	u32 best=0;

	u16 i = 0;
//	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u16 wt_down_half_round = 0;

	u64 Input_v_L_part[4] = {0};  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_L_part[4] = {0};  //模加输入右侧掩码
	u64 Input_u_L_part[4] = {0};  //模加输出掩码
	u64 Input_w_L = 0;  //模加输入右侧掩码
	u64 Input_u_L = 0;  //模加输出掩码

	u64 Input_v_R_part[4] = {0};  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w_R_part[4] = {0};  //模加输入右侧掩码
	u64 Input_u_R_part[4] = {0};  //模加输出掩码
	u64 Input_w_R = 0;  //模加输入右侧掩码
	u64 Input_u_R = 0;  //模加输出掩码


	u64 e_Mxor_L_part[4] = {0}; //用于记录M向量的高比特的异或和
	u64 e_Mxor_R_part[4] = {0}; //用于记录M向量的高比特的异或和

	u32 tmp_VX[4] = {0};

	u64 i0=0,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0;
	u64 j0=0,j1=0,j2=0,j3=0,j4=0,j5=0,j6=0,j7=0;
	u64 j = 0;
	u64 w1=0,w2=0,w3=0,w4=0,w5=0,w6=0,w7=0;

//	printf(" enter Chaskey_N_Rounds_DownHalf \n ");


	//对于每个分块都将32比特的分组分别分成4个8比特的块，并记录可能的最小相关性重量
	for(i=0; i<4; i++)
	{
		Input_v_L_part[i] = (mask_Xr[1] >> 8*(3-i)) & 0xFF;// 注意为tmp_V1的值为加法的V,与上半不同
		wt_cor_bound += cLAT_wtcor_min[Input_v_L_part[i]][0]; 	//bound wt
		Input_v_R_part[i] = (mask_Xr[2] >> 8*(3-i)) & 0xFF;//rol right
		wt_cor_bound += cLAT_wtcor_min[Input_v_R_part[i]][0]; 	//bound wt
	}

	if( wt_cor_bound + uper_wt > wt_cmpr)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}
	w_cmp = wt_cmpr - uper_wt;

//	printf("CHASKEY w_cmp:%d  wt_cmpr:%d  uper_wt:%d \n",w_cmp,wt_cmpr, uper_wt );

/////////part L-0
		for(i0 = cLAT_wtcor_min[Input_v_L_part[0]][0]; i0 < 8; i0++)
		{
			if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
		for(j0=0; j0 < cLAT_WU_numb[Input_v_L_part[0]][0][i0]; j0++)
		{
			Input_w_L_part[0] = cLAT_W[Input_v_L_part[0]][0][i0][j0];
			Input_u_L_part[0] = cLAT_U[Input_v_L_part[0]][0][i0][j0];

			e_Mxor_L_part[0] = cLAT_UVW_bro[Input_u_L_part[0]][Input_v_L_part[0]][Input_w_L_part[0]][0];

/////////part L-1
		for(i1 = cLAT_wtcor_min[Input_v_L_part[1]][e_Mxor_L_part[0]]; i1 <= 8; i1++)
		{
			if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cLAT_WU_numb[Input_v_L_part[1]][e_Mxor_L_part[0]][i1]; j1++)
		{
			Input_w_L_part[1] = cLAT_W[Input_v_L_part[1]][e_Mxor_L_part[0]][i1][j1];
			Input_u_L_part[1] = cLAT_U[Input_v_L_part[1]][e_Mxor_L_part[0]][i1][j1];

			e_Mxor_L_part[1] = cLAT_UVW_bro[Input_u_L_part[1]][Input_v_L_part[1]][Input_w_L_part[1]][e_Mxor_L_part[0]];

/////////part L-2
		for(i2 = cLAT_wtcor_min[Input_v_L_part[2]][e_Mxor_L_part[1]]; i2 <= 8; i2++)
		{
			if(i0+i1+i2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j2=0; j2 < cLAT_WU_numb[Input_v_L_part[2]][e_Mxor_L_part[1]][i2]; j2++)
		{
			Input_w_L_part[2] = cLAT_W[Input_v_L_part[2]][e_Mxor_L_part[1]][i2][j2];
			Input_u_L_part[2] = cLAT_U[Input_v_L_part[2]][e_Mxor_L_part[1]][i2][j2];

			e_Mxor_L_part[2] = cLAT_UVW_bro[Input_u_L_part[2]][Input_v_L_part[2]][Input_w_L_part[2]][e_Mxor_L_part[1]];

/////////part L-3
		for(i3 = cLAT_wtcor_min[Input_v_L_part[3]][e_Mxor_L_part[2]]; i3 <= 8; i3++)
		{
			if(i0 + i1 +i2+i3> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < cLAT_WU_numb[Input_v_L_part[3]][e_Mxor_L_part[2]][i3]; j3++)
		{
			Input_w_L_part[3] = cLAT_W[Input_v_L_part[3]][e_Mxor_L_part[2]][i3][j3];
			Input_u_L_part[3] = cLAT_U[Input_v_L_part[3]][e_Mxor_L_part[2]][i3][j3];

			Input_w_L = (Input_w_L_part[0] << 24) | (Input_w_L_part[1] << 16) |
					(Input_w_L_part[2] << 8) | Input_w_L_part[3];  //模加输入右侧掩码
			Input_u_L = (Input_u_L_part[0] << 24) | (Input_u_L_part[1] << 16) |
					(Input_u_L_part[2] << 8) | Input_u_L_part[3];  //模加输入右侧掩码


/////////part R-0
		for(i4 = cLAT_wtcor_min[Input_v_R_part[0]][0]; i4 < 8; i4++)
		{
			if(i0+i1+i2+i3+i4 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j4=0; j4 < cLAT_WU_numb[Input_v_R_part[0]][0][i4]; j4++)
		{
			Input_w_R_part[0] = cLAT_W[Input_v_R_part[0]][0][i4][j4];
			Input_u_R_part[0] = cLAT_U[Input_v_R_part[0]][0][i4][j4];

			e_Mxor_R_part[0] = cLAT_UVW_bro[Input_u_R_part[0]][Input_v_R_part[0]][Input_w_R_part[0]][0];

/////////part R-1
		for(i5 = cLAT_wtcor_min[Input_v_R_part[1]][e_Mxor_R_part[0]]; i5 <= 8; i5++)
		{
			if(i0 + i1 +i2+i3+i4+i5> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j5=0; j5 < cLAT_WU_numb[Input_v_R_part[1]][e_Mxor_R_part[0]][i5]; j5++)
		{
			Input_w_R_part[1] = cLAT_W[Input_v_R_part[1]][e_Mxor_R_part[0]][i5][j5];
			Input_u_R_part[1] = cLAT_U[Input_v_R_part[1]][e_Mxor_R_part[0]][i5][j5];

			e_Mxor_R_part[1] = cLAT_UVW_bro[Input_u_R_part[1]][Input_v_R_part[1]][Input_w_R_part[1]][e_Mxor_R_part[1]];

/////////part R-2
		for(i6 = cLAT_wtcor_min[Input_v_R_part[2]][0]; i6 <= 8; i6++)
		{
			if(i0+i1+i2+i3+i4+i5+i6 > w_cmp ){break;}  //break 要比 continue 高效,直接结束return.
		for(j6=0; j6 < cLAT_WU_numb[Input_v_R_part[2]][0][i6]; j6++)
		{
			Input_w_R_part[2] = cLAT_W[Input_v_R_part[2]][0][i6][j6];
			Input_u_R_part[2] = cLAT_U[Input_v_R_part[2]][0][i6][j6];

			e_Mxor_R_part[2] = cLAT_UVW_bro[Input_u_R_part[2]][Input_v_R_part[2]][Input_w_R_part[2]][e_Mxor_R_part[1]];

/////////part R-3
		for(i7 = cLAT_wtcor_min[Input_v_R_part[3]][e_Mxor_R_part[2]]; i7 <= 8; i7++)
		{
			if(i0 + i1 +i2+i3+i4+i5+i6+i7 == w_cmp ){
			//if(i0 + i1 +i2+i3+i4+i5+i6+i7 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j7=0; j7 < cLAT_WU_numb[Input_v_R_part[3]][e_Mxor_R_part[2]][i7]; j7++)
		{
			Input_w_R_part[3] = cLAT_W[Input_v_R_part[3]][0][i7][j7];
			Input_u_R_part[3] = cLAT_U[Input_v_R_part[3]][0][i7][j7];

			Input_w_R = (Input_w_R_part[0] << 24) | (Input_w_R_part[1] << 16) |
					(Input_w_R_part[2] << 8) | Input_w_R_part[3];  //模加输入右侧掩码
			Input_u_R = (Input_u_R_part[0] << 24) | (Input_u_R_part[1] << 16) |
					(Input_u_R_part[2] << 8) | Input_u_R_part[3];  //模加输入右侧掩码


/////////处理本 下半个 轮的输出掩码 //注意和上半部分的旋转参数不一样
			tmp_VX[1] = Input_w_L ^ mask_Xr[0];
			tmp_VX[1] = ROTATE_LEFT(tmp_VX[1],7,blocksize_len) & Bit_Align;

			tmp_VX[2] = tmp_VX[1] ^ Input_u_L;
			tmp_VX[2] = ROTATE_LEFT(tmp_VX[2],16,blocksize_len) & Bit_Align;

			tmp_VX[3] = Input_w_R ^ mask_Xr[3];
			tmp_VX[3] = ROTATE_LEFT(tmp_VX[3],13,blocksize_len) & Bit_Align;

			tmp_VX[0] = Input_u_R ^ tmp_VX[3];


			//记录每一个ADD的相关性重量
			//Chaskey_Round_ADD_wt[current_round][0] = i0 + i1;
			//Chaskey_Round_ADD_wt[current_round][1] = i2 + i3;
			Chaskey_Round_ADD_wt[search_round][2] = i0 + i1 + i2 + i3;
			Chaskey_Round_ADD_wt[search_round][3] = i4 + i5 + i6 + i7;
			//当前轮的线性相关性重量
			wt_down_half_round = i0 + i1 + i2 + i3 + i4 + i5 + i6 + i7;
			P_w[search_round] = wt_down_half_round + uper_wt;

			XV[0][search_round +1] = tmp_VX[0];
			XV[1][search_round +1] = tmp_VX[1];
			XV[2][search_round +1] = tmp_VX[2];
			XV[3][search_round +1] = tmp_VX[3];

			//记录第r轮的中间态
			XV_M[0][search_round] = mask_Xr[0];
			XV_M[1][search_round] = mask_Xr[1];
			XV_M[2][search_round] = mask_Xr[2];
			XV_M[3][search_round] = mask_Xr[3];

/*
			if((XV[0][search_round +1] ==0) &&
					(XV[1][search_round +1] ==0) &&
					(XV[2][search_round +1] ==0) &&
					(XV[3][search_round +1] ==0))
			{return 0;}
*/
//			printf("CHASKEY P_w[search_round]:%d \n", P_w[search_round]);
			best = 1;
			n_P_bestofR_w[search_round] = Bn_w;
#if 1   //是否找到第一条最优路径就返回？
if( best == 1 )
	return 1;
#endif
		}}}} }
		}}}}
		}}}}
		}}}}

	return best;
}



////////////////////////////////搜索CHAM的最优 差分 特征的代码//////////////////////////////
u32 CHAM_64_Diff_trail_search_entry(u16 search_round)
{
	u32 best = 0;
	u16 i = 0;
	FILE* CHAM_64_diff_Bn;
	FILE* CHAM_64_diff_Bn_even;
	u16 Bn_wt_expected = 0;


	CHAM_64_diff_Bn = fopen ("../tmp/CHAM_64_diff_Bn_wt.xlsx", "a+"); //  "w+"); //
	CHAM_64_diff_Bn_even = fopen ("../tmp/CHAM_64_diff_Bn_wt_even.xlsx", "a+"); //  "w+"); //

	if(sc_blocksize != 64)
	{
		printf("The block size of CHAM should be 64 bits. \n");
		return 0;
	}
	// For CHAM-64 modular additon is 16 bits.
	blocksize_len = 16;
	nBytes = 2;
	Bit_Align = 0xFFFF;
	ValueMax_Align = 0x7FFF;
	V_MSB = 0x8000;

	printf("Constructing CHAM-64 cDDT Tables... \n");
	//构造cDDT
	ARX_carry_DDTm_construct();  // FOR cDDT
	fixed_Alpha_get_betagamma();   //for 234 round
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct CHAM-64 cDDT: %.2f seconds.  \n", run_time);


	Bn_w = 0;
	if(search_round > 1)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(CHAM_64_diff_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			fscanf(CHAM_64_diff_Bn_even,"%d",&CHAM_Pw_even_wt[i]);  //read.
		}
	}

#if(CHAM_even_round == 0) //结束条件判断是搜索的奇数还是偶数轮开始的路径,=0为奇数轮开始的正常搜索
	{
		printf("===============Search odd-round============= \n");
		Bn_w = n_P_bestofR_w[search_round -1] - 1;
	}
#else
	{
		printf("===============Search even-round============= \n");
		Bn_w = CHAM_Pw_even_wt[search_round -1] - 1;
	}
#endif

	p_sumof_r_P_w[search_round] = 0xFFFF;
//	Bn_w = 63;  //直接设定开始的概率重量,快速达到期望的概率重量
			do
			{
				Bn_w = Bn_w + 1;
				printf("Searching CHAM-64 Bn_w: %d \n", Bn_w);

				// Search Entry.
				best = CHAM_Diff_trail_round_1(search_round); //效率高
/*
				u32 Output_X[4] = {0};
				Output_X[0] = 0x0010;
				Output_X[1] = 0x1020;
				Output_X[2] = 0x2800;
				Output_X[3] = 0x0000;
				P_w[1] = 1;  // P_w[2] = 2; P_w[3] = 3;   //pro;
				p_sumof_r_P_w[1] = P_w[1]; //  p_sumof_r_P_w[2] = 3; p_sumof_r_P_w[3] = 6;
				best = CHAM_Diff_trail_round_23(search_round, 2, Output_X);  //第1轮的输出
	//			best = CHAM_Diff_trail_round_r(search_round, 4, Output_X); //r lun //第3轮的输出
*/

				time_Round = clock();
				run_time =  (time_Round - time_ARX_cLAT) / CLOCKS_PER_SEC;
				printf("Time: %.2f seconds.  \n", run_time);

#if(CHAM_even_round == 0) //结束条件判断是搜索的奇数还是偶数轮开始的路径
				{
					//Bn_wt_expected =  p_sumof_r_P_w[search_round];
					Bn_wt_expected =  n_P_bestofR_w[search_round];
				}
#else
				{
					//Bn_wt_expected =  p_sumof_r_P_w[search_round];
					Bn_wt_expected =  CHAM_Pw_even_wt[search_round];
				}
#endif
			}while(Bn_w != Bn_wt_expected);   //end conditions. // !=

			print_CHAM_64_resoult(search_round);  //打印CHASKEY的输入输出掩码

			time_finish = clock();
			run_time = (double)(time_finish - time_ARX_cLAT) / CLOCKS_PER_SEC;
			printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours == %.2f days. \n", run_time,run_time/60.0,run_time/3600.0,run_time/86400.0 );
			printf("Auto-search CHAM-64 optimal differential trails END! \n");
			printf("|************************************************************************|\n");
			fclose(CHAM_64_diff_Bn);
			fclose(CHAM_64_diff_Bn_even);
	return best;
}

////////////////////////////////
u32 CHAM_128_Diff_trail_search_entry(u16 search_round)
{
	u32 best = 0;
	u16 i = 0;
	FILE* CHAM_128_diff_Bn;
	FILE* CHAM_128_diff_Bn_even;
	u16 Bn_wt_expected = 0;


	CHAM_128_diff_Bn = fopen ("../tmp/CHAM_128_diff_Bn_wt.xlsx", "a+"); //  "w+"); //
	CHAM_128_diff_Bn_even = fopen ("../tmp/CHAM_128_diff_Bn_wt_even.xlsx", "a+"); //  "w+"); //
	if(sc_blocksize != 128)
	{
		printf("The block size of CHAM should be 128 bits. \n");
		return 0;
	}
	// For CHAM-128 modular additon is 32 bits.
	blocksize_len = 32;
	nBytes = 4;
	Bit_Align = 0xFFFFFFFF;
	ValueMax_Align = 0x7FFFFFFF;
	V_MSB = 0x80000000;


	printf("Constructing CHAM-128 cDDT Tables... \n");
	//构造部分的线性相关性近似表cLAT
	ARX_carry_DDTm_construct();  // FOR cDDT
	fixed_Alpha_get_betagamma();   //for 234 round
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct CHAM-128 cDDT: %.2f seconds.  \n", run_time);


	Bn_w = 0;
	if(search_round > 1)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(CHAM_128_diff_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			fscanf(CHAM_128_diff_Bn_even,"%d",&CHAM_Pw_even_wt[i]);  //read.
		}

#if(CHAM_even_round == 0) //结束条件判断是搜索的奇数还是偶数轮开始的路径,=0为奇数轮开始的正常搜索
		{
			printf("===============Search odd-round============= \n");
			Bn_w = n_P_bestofR_w[search_round -1] - 1;
		}
#else
		{
			printf("===============Search even-round============= \n");
			Bn_w = CHAM_Pw_even_wt[search_round -1] - 1;
		}
#endif
	}

		p_sumof_r_P_w[search_round] = 0xFFFF;
//	  	Bn_w = 1;  //直接设定开始的概率重量,快速达到期望的概率重量
			do
			{
				Bn_w = Bn_w + 1;
				printf("Searching CHAM-128 Bn_w: %d \n", Bn_w);

				// Search Entry.
				best = CHAM_Diff_trail_round_1(search_round); //效率高
/*
				u32 Output_X[4] = {0};
				Output_X[0] = 0x10200000;
				Output_X[1] = 0x08002000;
				Output_X[2] = 0x00000000;
				Output_X[3] = 0x40000000;
				P_w[1] = 3;   P_w[2] = 1;  P_w[3] = 2;   //pro;
				p_sumof_r_P_w[1] = P_w[1];   p_sumof_r_P_w[2] = 4;  p_sumof_r_P_w[3] = 6;
	//			best = CHAM_Diff_trail_round_23(search_round, 2, Output_X);  //第1轮的输出
				best = CHAM_Diff_trail_round_r(search_round, 4, Output_X); //r lun //第3轮的输出
*/

				time_Round = clock();
				run_time =  (time_Round - time_ARX_cLAT) / CLOCKS_PER_SEC;
				printf("Time: %.2f seconds.  \n", run_time);

#if(CHAM_even_round == 0) //结束条件判断是搜索的奇数还是偶数轮开始的路径
				{
					Bn_wt_expected = n_P_bestofR_w[search_round];
				}
#else
				{
					Bn_wt_expected = CHAM_Pw_even_wt[search_round];
				}
#endif
			}while(Bn_w !=  Bn_wt_expected);   //end conditions.

			print_CHAM_128_resoult(search_round);  //打印CHASKEY的输入输出掩码

			time_finish = clock();
			run_time = (double)(time_finish - time_ARX_cLAT) / CLOCKS_PER_SEC;
			printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours == %.2f days. \n", run_time,run_time/60.0,run_time/3600.0,run_time/86400.0 );
			printf("Auto-search CHAM-128 optimal differential trails END! \n");
			printf("|************************************************************************|\n");
			fclose(CHAM_128_diff_Bn);
			fclose(CHAM_128_diff_Bn_even);
	return best;
}



u32 CHAM_Diff_trail_round_1(u16 search_round)
{
	u32 best = 0;
	u16 thr_d = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 ROL_a =1, ROL_b = 8;  //当搜索过程中间轮为 奇数 轮，默认旋转参数为1,8
	u32 Output_X[4] = {0};

	u64 M0 = 0;
	u64 N0 = blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;
	u16 j_abc = 0;


#if(CHAM_even_round == 0) //结束条件判断是搜索的奇数还是偶数轮开始的路径
	{
		ROL_a =1; ROL_b = 8;
	}
#else
	{
		ROL_a =8, ROL_b = 1;
	}
#endif
///////////////////round 1 entry/////////////////////
	if( search_round == 1)
	{
		return best;
	}
	else
	{	// 可以选择是否限定第1轮的概率重量
		for(thr_d = 0; thr_d < blocksize_len-1; thr_d++)  //0::n-1 // blocksize_len-1
		{
			// thr_d : the bits number of alpha/beta/gamma that the position not equal to each other at the same time.
#if(CHAM_even_round == 0) //结束条件判断是搜索的奇数还是偶数轮开始的路径
			{	//奇数开始轮，则链接偶数轮
				if ((thr_d + CHAM_Pw_even_wt[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
					{return 0;}
			}
#else
			{	//偶数轮开始，则链接奇数轮
				if ((thr_d + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
					{return 0;}  //Return the upper procedure::sepck_differential_trail_search_entry
			}
#endif


			M0 = thr_d;  //三个alpha,beta和gamma同时考虑
			P_w[1] = M0;  //pro;
			p_sumof_r_P_w[1] = P_w[1];
			if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
			{
				for(j_abc = 0; j_abc < 4;j_abc++)  //*******注意在CHAM中首轮不能为全0的输入输出差分******
				{
					if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
					{
						Input_alpha = V_MSB;
					}
					else
					{
						Input_alpha = 0;  // & Bit_Align;
					}

					if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
					{
						Input_beta = V_MSB;
					}
					else
					{
						Input_beta = 0; // & Bit_Align;
					}

					if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
					{
						Input_gamma = V_MSB;
					}
					else
					{
						Input_gamma = 0;  // & Bit_Align;
					}

					//P_w[1] = M0;  //pro; //Speck_XDP_compute(Input_Alpha,Input_Beta,Input_Gamma );
					//CHAM_Alpha[1] = Input_alpha;
					//CHAM_Beta[1] = Input_beta;
					//CHAM_Gamma[1] = Input_gamma;

					Output_X[0] = ROTATE_RIGHT(Input_beta, ROL_a, blocksize_len) & Bit_Align;
					Output_X[3] = ROTATE_LEFT(Input_gamma, ROL_b, blocksize_len) & Bit_Align;

					best = CHAM_Diff_trail_round_23(search_round, 2, Output_X);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			CHAM_X[0][1] = Input_alpha;
			CHAM_X[1][1] = Output_X[0];
			CHAM_X[2][1] = CHAM_X[1][2];
			CHAM_X[3][1] = CHAM_X[2][2];

			//if((CHAM_X[0][1] !=0) || (CHAM_X[1][1] !=0) ||(CHAM_X[2][1] !=0) ||(CHAM_X[3][1] !=0))
			{return 1; }
		}
#endif
					}
				}
				else  //M0 > 0.
				{
					for ( i=0; i<=(N0-M0); i++) A0[i] = 0;
					for ( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
					for ( i = 1; i<=M0; i++) { C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
					T0[N0-M0] = -1;
					T0[1] = 0;
					F0[N0] = N0 - M0 + 1;
					I0 = N0 - M0; L0 = N0;

					best = CHAM_input_MSB(search_round,Input_alpha, Input_beta, Input_gamma,thr_d,C0);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		return 1;
	}
#endif

////////////////////
				do
				{
					if (I0 == 0)
					{
						break;
					}
					else
					{
						if (T0[I0] < 0)
						{
							if ((-T0[I0]) != (I0-1))
							{
								T0[I0-1] = T0[I0];
							}
							T0[I0] = I0-1;
						}
						if ( A0[I0]==0 )
						{
							X0 = I0;
							Y0 = F0[L0];
							if (A0[I0-1] == 1)
							{
								F0[I0] = F0[I0 - 1];
							}
							else
							{
								F0[I0] = I0;
							}
							if (F0[L0] == L0)
							{
								L0 = I0; I0 = T0[I0];
								goto cham_r1;
							}
							if (L0 == N0)
							{
								T0[F0[N0]] = -I0 - 1;
								T0[I0 + 1] = T0[I0];
								I0 = F0[N0];
								F0[N0] = F0[N0] + 1;
								goto cham_r1;
							}
							T0				[L0] = -I0-1;
							T0[I0+1] = T0[I0];
							F0[L0] = F0[L0] + 1;
							I0 = L0;
							goto cham_r1;
						}
						Y0 = I0;
						if (I0 != L0)
						{
							F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
							if (L0 == N0)
							{
								if (I0 == (F0[N0] - 1))
								{
									I0 = T0[I0];
									goto cham_r1;
								}
								T0[F0[N0]-1] = -I0-1;
								T0[I0+1] = T0[I0];
								I0 = F0[N0] - 1;
								goto cham_r1;
							}
							T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0; goto cham_r1;
						}
						X0 = N0;
						F0[L0 - 1] = F0[L0];
						F0[N0] = N0;
						L0 = N0;
						if (I0 == N0 - 1)
						{
							I0 = T0[N0 - 1];
							goto cham_r1;
						}
						T0[N0 - 1] = -I0 - 1;
						T0[I0 + 1] = T0[I0];
						I0 = N0 - 1;
			cham_r1:
					A0[X0] = 1;
					A0[Y0] = 0;
					H0[X0] = Z0 = H0[Y0];
					C0[Z0] = X0;
					}
/////////////////////////////////
			best = CHAM_input_MSB(search_round,Input_alpha, Input_beta, Input_gamma,thr_d,C0);

#if 1   //是否找到第一条最优路径就返回？
			if(best == 1 )
			{
				return 1;
			}
#endif
///////////////////////////////////////
					} while(1);
				}
		}
	}
	return best;
}


u16 CHAM_input_MSB
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi )
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 j_abc = 0;

/*  //只考虑了set-A
	for(j_abc = 0; j_abc < 4;j_abc++)   // MSB
	{
		if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = V_MSB;
		}
		else
		{
			Input_alpha = 0;  // & Bit_Align;
		}

		if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
		{
			Input_beta = V_MSB;
		}
		else
		{
			Input_beta = 0; // & Bit_Align;
		}

		if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
		{
			Input_gamma = V_MSB;
		}
		else
		{
			Input_gamma = 0;  // & Bit_Align;
		}
*/


	// MSB of of alpha/beta/gamma
	for(j_abc = 0; j_abc < 8;j_abc++)   // MSB
	{
		//set A of MSB.
		if((j_abc==0) || (j_abc==3) || (j_abc==5) || (j_abc==6) )
		{
			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = V_MSB;
			}
			else
			{
				Input_alpha = 0;  // & Bit_Align;
			}

			if((j_abc & 0x2) != 0) // beta bit j.
			{
				Input_beta = V_MSB;
			}
			else
			{
				Input_beta = 0; // & Bit_Align;
			}

			if((j_abc & 0x1) != 0) // gamma bit j.
			{
				Input_gamma = V_MSB;
			}
			else
			{
				Input_gamma = 0;  // & Bit_Align;
			}

			state = CHAM_input_Middle(search_round,Input_alpha,Input_beta, Input_gamma,P_1,posi,P_1);

		}
		else //set B of MSB //if((j_abc==1) || (j_abc==2) || (j_abc==4) || (j_abc==7) )
		{
			//对于speck96和speck128,不考虑导致后续比特全确定情况
			//若为{0,3,5,6}则除MSB外其它后面比特全为0
			//若为{1、2、4,7}则除MSB外其它后面比特全为1
		if((j_abc & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = Bit_Align;
		}
		else
		{
			Input_alpha = ValueMax_Align;  // & Bit_Align;
		}

		if((j_abc & 0x2) != 0) // beta bit j.
		{
			Input_beta = Bit_Align;
		}
		else
		{
			Input_beta = ValueMax_Align; // & Bit_Align;
		}

		if((j_abc & 0x1) != 0) // gamma bit j.
		{
			Input_gamma = ValueMax_Align;
		}
		else
		{
			Input_gamma = Bit_Align;  // & Bit_Align;
		}

		state = CHAM_input_Middle(search_round,Input_alpha,Input_beta, Input_gamma,P_1,posi,P_1);

		}

		//state = sepck_input_Middle(search_round,Input_alpha,Input_beta, Input_gamma,P_1,posi,P_1);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
}
	return state;
}

//由高位到低位逐步判断
u16 CHAM_input_Middle
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi, u16 cur_posi)
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u64 indx_tmp = 0;
	u16 i = 0;
	u64 bit_i = 1;


	indx_tmp = posi[cur_posi] - 1;

	// 考虑到产生概率重量的位置为全部可能的状态{3/5/6,1/2/4}
	// Middle bit positionsof of alpha/beta/gamma
	if( cur_posi > 1)  // Middle bit positionsof of alpha/beta/gamma
	{
		//只有{3/5/6,1/2/4}会导致该位置产生概率重量
		for(j_abc = 1; j_abc < 7; j_abc++)   //概率重量位置的可能取值组合
		{
			//判断该位置对应的alpha、beta、gamma的比特值为0还是1；
			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = alpha | (bit_i << indx_tmp);
			}
			else
			{
				//Input_alpha = alpha; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_alpha = (alpha & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x2) != 0) // alpha bit j.
			{
				Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_beta = beta; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_beta = (beta & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x1) != 0) // alpha bit j.
			{
				Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}


			//判断该位置是属于{3/5/6}，后续比特位置全清0
			if( (j_abc==3) || (j_abc==5) || (j_abc==6) )
			{
				// setA对应到下一个不全同比特位置,全设置为0才满足差分有效性条件.
				for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
				{
					Input_alpha &= ~(bit_i << j_last);
					Input_beta  &= ~(bit_i << j_last);
					Input_gamma &= ~(bit_i << j_last);
				}
			}
			else //判断该位置是属于{1/2/4}，后续比特位置全部置1；
			{
				// setB_3对应到下一个不全同比特位置,全设置为 1 才满足差分有效性条件.
				for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
				{
					Input_alpha ^= (bit_i << j_last);
					Input_beta  ^= (bit_i << j_last);
					Input_gamma ^= (bit_i << j_last);
				}
			}


/*  //只考虑了产生概率重量的比特位置为{3/5/6}的情况，可能会忽略部分组合
	//indx_tmp = 1 << (posi[cur_posi] - 1);
	indx_tmp = posi[cur_posi] - 1;

	// Middle bit positionsof of alpha/beta/gamma
	if( cur_posi > 1)  // Middle bit positionsof of alpha/beta/gamma
	{

		//for(j_abc = 1; j_abc < 7; j_abc++)   // MSB //for speck32/48/64
		for(i = 0; i < 3; i++)   // MSB //for speck96/128
		{
			j_abc = set_A_3[i];  //for speck96/128

			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = alpha | (bit_i << indx_tmp);
			}
			else
			{
				Input_alpha = alpha; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				//Input_alpha = (alpha & ( ~(1 << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x2) != 0) // alpha bit j.
			{
				Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				Input_beta = beta; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				//Input_beta = (beta & ( ~(1 << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x1) != 0) // alpha bit j.
			{
				Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				//Input_gamma = (gamma & ( ~(1 << indx_tmp)) ); // & Bit_Align;
			}
*/

			state = CHAM_input_Middle(search_round,Input_alpha,Input_beta, Input_gamma,P_1,posi,cur_posi-1);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
		}
	}
	else 	//call last position.
	{
		state = CHAM_input_Last(search_round,
				alpha,beta,	gamma,P_1,posi );
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
	}
	return state;
}

u16 CHAM_input_Last
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi )
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u32 Output_X[4] = {0};
	u16 ROL_a =1, ROL_b = 8;  //当搜索过程中间轮为 奇数 轮，默认旋转参数为1,8

	u16 j_abc = 0;
	u16 j_last = 0;
	u64 indx_tmp = 0;
	u64 bit_i = 1;


	indx_tmp = posi[1] - 1;

	// 最后的一个产生概率重量的比特位置只能为{3、5/6}，在该位置之后的更低的比特位置都全部清0；
	for(j_abc = 0; j_abc < 3;j_abc++)// Last bit position.
	{
		if((set_A_3[j_abc] & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = alpha | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_alpha = alpha; // & ( ~(1 << indx_tmp))) & Bit_Align;
			Input_alpha = (alpha & ( ~(bit_i << indx_tmp))) & Bit_Align;
		}

		if((set_A_3[j_abc] & 0x2) != 0) // alpha bit j.
		{
			Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_beta = beta; // & ( ~(1 << indx_tmp))) & Bit_Align;
			Input_beta = (beta & ( ~(bit_i << indx_tmp))) & Bit_Align;
		}

		if((set_A_3[j_abc] & 0x1) != 0) // alpha bit j.
		{
			Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ) & Bit_Align;
			Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ) & Bit_Align;
		}

 	 	 // 需要在此将产生概率重量位置更低的比特位置全部清零
		if(posi[1] > 1)  //若产生概率重量的最后一个位置是LSB，则不用清0
			for(j_last=0; j_last< indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
			{
				Input_alpha &= ~(bit_i << j_last);
				Input_beta  &= ~(bit_i << j_last);
				Input_gamma &= ~(bit_i << j_last);
			}

#if(CHAM_even_round == 0) //结束条件判断是搜索的奇数还是偶数轮开始的路径	 //结束条件判断是搜索的奇数还是偶数轮开始的路径,设定第1轮参数
		{
			ROL_a =1; ROL_b = 8;
		}
#else
		{
			ROL_a =8, ROL_b = 1;
		}
#endif
		Output_X[0] = ROTATE_RIGHT(Input_beta, ROL_a, blocksize_len) & Bit_Align;
		Output_X[3] = ROTATE_LEFT(Input_gamma, ROL_b, blocksize_len) & Bit_Align;

		state = CHAM_Diff_trail_round_23(search_round, 2, Output_X);
#if 1   //是否找到第一条最优路径就返回？
		if(state == 1 )
		{
			CHAM_X[0][1] = Input_alpha;
			CHAM_X[1][1] = Output_X[0];
			CHAM_X[2][1] = CHAM_X[1][2];
			CHAM_X[3][1] = CHAM_X[2][2];
			return 1;
		}
#endif
	}
	return state;
}


u32 CHAM_Diff_trail_round_23(u16 search_round, u16 cur_round, u32 *input_x)
{
	u32 best = 0;
	u16 ROL_a =1, ROL_b = 8;  //当搜索过程中间轮为 奇数 轮，默认旋转参数为1,8
	u32 beta_tmp=0, gamma_tmp=0;
	u32 Output_X[4] = {0};
	u32 beta_block[4] = {0};
	u32 gama_block[4] = {0};
	u8 carry_block[4] = {0};
	u16 X0_block[4] = {0};
	u16 X0_block_msb[4] = {0};
	u8 X0_block_wt_min[4] = {0};
	u16 i=0, j=0;
//	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16 w_cmp = 0;
	u16 i0=0,i1=0,i2=0,i3=0;
	u16 j0=0,j1=0,j2=0,j3=0;


#if (CHAM_even_round == 0 ) //当前搜索参数（1，8）开始的奇数轮的最优路径
	if((cur_round & 0x01) == 0)  //偶数轮%2
	{
		ROL_a = 8; ROL_b = 1;
		w_cmp = Bn_w - p_sumof_r_P_w[cur_round-1] - n_P_bestofR_w[search_round - cur_round];
	}
	else  // 奇数轮
	{
		//ROL_a =1; ROL_b = 8; //默认的值就是1,8
		w_cmp = Bn_w - p_sumof_r_P_w[cur_round-1] - CHAM_Pw_even_wt[search_round - cur_round];
	}
#else  //CHAM_even_round=1, 当前搜索参数（8,1）开始的偶数轮的最优路径
	if((cur_round & 0x01) == 0)  //偶数轮
	{
		//ROL_a = 1; ROL_b = 8;  //默认的值就是1,8
		w_cmp = Bn_w - p_sumof_r_P_w[cur_round-1] - CHAM_Pw_even_wt[search_round - cur_round];
	}
	else  // 奇数轮
	{
		ROL_a =8; ROL_b = 1;
		w_cmp = Bn_w - p_sumof_r_P_w[cur_round-1] - n_P_bestofR_w[search_round - cur_round];
	}
#endif

#if (CHAM_64_or_128 == 64)
		X0_block[0] = input_x[0] & 0xFF;   //取出每个8比特
		X0_block[1] = (input_x[0] >> 8) & 0xFF;   //取出每个8比特

		//确定每个输入差分alpha的每8比特的子块所对应的可能的最小差分概率重量
		X0_block_wt_min[0] = CHAM_a_wt_min[X0_block[0]][0];
		X0_block_wt_min[1] = 0xFF;
		if( (X0_block[0] & 0x80) == 0)
		{
			for(i=0;i<4;i++)  //carry 为 0/1/2/3  carry=alpha||beta||gamma,即alpha的这位为0
			{
				if(X0_block_wt_min[1] > msb_CHAM_a_wt_min[X0_block[1]][i])
				{
					X0_block_wt_min[1] = msb_CHAM_a_wt_min[X0_block[1]][i];
				}
			}
		}
		else
		{
			for(i=4;i<8;i++) //carry 为 4/5/6/7  carry=alpha||beta||gamma,即alpha的这位为1
			{
				if(X0_block_wt_min[1] > msb_CHAM_a_wt_min[X0_block[1]][i])
				{
					X0_block_wt_min[1] = msb_CHAM_a_wt_min[X0_block[1]][i];
				}
			}
		}

		if( X0_block_wt_min[0] + X0_block_wt_min[1] > w_cmp)
		{return 0;}
/*
	if( _mm_popcnt_u64(input_x[0] & 0x7FFF) > w_cmp)
	{return 0;}
	X0_block_wt_min[1] = _mm_popcnt_u64(input_x[0] & 0x7F);
*/

		X0_block_msb[0] = ((X0_block[0] >> 7) << 2);  //alpha 最低8比特的 MSB
		//整理给下一轮的输入差分
		Output_X[1] = input_x[2];
		Output_X[2] = input_x[3];

		//block 0
		for(i0=CHAM_a_wt_min[X0_block[0]][0];
				i0<=CHAM_a_wt_min[X0_block[0]][0] +1; i0++)  //X0_block_wt_min[0] // <=8 //CHAM_a_wt_max[X0_block[0]][0]
		{
			if(i0 + X0_block_wt_min[1] > w_cmp ){break;}
			for(j0=0; j0<CHAM_a_bg_numb[X0_block[0]][0][i0]; j0++)
			{
				beta_block[0] = CHAM_a_beta[X0_block[0]][0][i0][j0];
				gama_block[0] = CHAM_a_gama[X0_block[0]][0][i0][j0];
				carry_block[0] = X0_block_msb[0] +
						((beta_block[0] >> 7) << 1) + (gama_block[0] >> 7);

		//block 1
		for(i1=msb_CHAM_a_wt_min[X0_block[1]][carry_block[0]];
				i1<=msb_CHAM_a_wt_min[X0_block[1]][carry_block[0]] +1; i1++) //X0_block_wt_min[1]  //<8//msb_CHAM_a_wt_max[X0_block[1]][carry_block[0]]
			{
				if(i0 + i1 > w_cmp ){break;}
				for(j1=0; j1<msb_CHAM_a_bg_numb[X0_block[1]][carry_block[0]][i1]; j1++)
				{
					beta_block[1] = msb_CHAM_a_beta[X0_block[1]][carry_block[0]][i1][j1];
					gama_block[1] = msb_CHAM_a_gama[X0_block[1]][carry_block[0]][i1][j1];

					P_w[cur_round] = i0 + i1 ;  //
					p_sumof_r_P_w[cur_round] = p_sumof_r_P_w[cur_round-1] + P_w[cur_round];

					beta_tmp = ((beta_block[1] << 8) | beta_block[0]) & Bit_Align;
					gamma_tmp = ((gama_block[1] << 8) | gama_block[0]) & Bit_Align;

					//整理给下一轮的输入差分
					Output_X[0] = ROTATE_RIGHT(beta_tmp, ROL_a, blocksize_len) & Bit_Align;
					Output_X[3] = ROTATE_LEFT(gamma_tmp, ROL_b, blocksize_len) & Bit_Align;

					if(cur_round >= 3 ) //第4轮之后跳转的CHAM_Diff_trail_round_r进行两个输入差分的查询输出差分的过程
					{
						best = CHAM_Diff_trail_round_r(search_round, cur_round+1, Output_X);
					}
					else
					{
						best = CHAM_Diff_trail_round_23(search_round, cur_round+1, Output_X);
					}
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			if(cur_round == 2 ) //记录第2轮的输入
			{
				CHAM_X[0][cur_round] = input_x[0];
				CHAM_X[1][cur_round] = Output_X[0];
				CHAM_X[2][cur_round] = CHAM_X[1][3];
				CHAM_X[3][cur_round] = input_x[3];
			}

			if(cur_round == 3 ) //记录第3轮的输出
			{
				CHAM_X[0][cur_round] = input_x[0];
				CHAM_X[1][cur_round] = Output_X[0];
				CHAM_X[2][cur_round] = Output_X[1];
				CHAM_X[3][cur_round] = Output_X[2];

				CHAM_X[0][cur_round+1] = Output_X[0];
				CHAM_X[1][cur_round+1] = Output_X[1];
				CHAM_X[2][cur_round+1] = Output_X[2];
				CHAM_X[3][cur_round+1] = Output_X[3];
			}
			return 1;
		}
#endif
		}}}}
///CHAM_64_or_128 == 128
#else
		for(i=0; i< nBytes; i++)
		{
			X0_block[i] = (input_x[0] >> (8*i)) & 0xFF;   //取出每个8比特
		}
		//确定每个输入差分alpha的每8比特的子块所对应的可能的最小差分概率重量
		X0_block_wt_min[0] = CHAM_a_wt_min[X0_block[0]][0];
		X0_block_wt_min[1] = 0xFF;
		X0_block_wt_min[2] = 0xFF;
		X0_block_wt_min[3] = 0xFF;
		for(j=0;j<3;j++)
		{
			if( (X0_block[j] & 0x80) == 0)
			{
				for(i=0;i<4;i++) //carry 为 0/1/2/3
				{
					if(X0_block_wt_min[j+1] > CHAM_a_wt_min[X0_block[j+1]][i])
					{
						X0_block_wt_min[j+1] = CHAM_a_wt_min[X0_block[j+1]][i];
					}
				}
			}
			else
			{
				for(i=4;i<8;i++)  //carry 为 4/5/6/7
				{
					if(X0_block_wt_min[j+1] > CHAM_a_wt_min[X0_block[j+1]][i])
					{
						X0_block_wt_min[j+1] = CHAM_a_wt_min[X0_block[j+1]][i];
					}
				}
			}
		}

		if(X0_block_wt_min[0] + X0_block_wt_min[1]+
				X0_block_wt_min[2] + X0_block_wt_min[3] > w_cmp)
		{return 0;}

		X0_block_msb[0] = ((X0_block[0] >> 7) << 2);  //alpha 最低8比特的 MSB
		X0_block_msb[1] = ((X0_block[1] >> 7) << 2);  //alpha 8-16比特的 MSB
		X0_block_msb[2] = ((X0_block[2] >> 7) << 2);  //alpha 16-24比特的 MSB

		//整理给下一轮的输入差分
		Output_X[1] = input_x[2];
		Output_X[2] = input_x[3];

		//block 0
		for(i0=CHAM_a_wt_min[X0_block[0]][0];
				i0<= CHAM_a_wt_min[X0_block[0]][0] +1; i0++)   //CHAM_a_wt_max[X0_block[0]][0]
		{
			if(i0 + X0_block_wt_min[1] +
					X0_block_wt_min[2] + X0_block_wt_min[3] > w_cmp ){break;}
			for(j0=0; j0<CHAM_a_bg_numb[X0_block[0]][0][i0]; j0++)
			{
				beta_block[0] = CHAM_a_beta[X0_block[0]][0][i0][j0];
				gama_block[0] = CHAM_a_gama[X0_block[0]][0][i0][j0];
				carry_block[0] = X0_block_msb[0] +
						((beta_block[0] >> 7) << 1) + (gama_block[0] >> 7);

		//block 1
		for(i1=CHAM_a_wt_min[X0_block[1]][carry_block[0]];
				i1<=CHAM_a_wt_min[X0_block[1]][carry_block[0]] +1; i1++) // CHAM_a_wt_max[X0_block[1]][carry_block[0]]
			{
				if(i0 + i1 +
						X0_block_wt_min[2] + X0_block_wt_min[3] > w_cmp ){break;}
				for(j1=0; j1<CHAM_a_bg_numb[X0_block[1]][carry_block[0]][i1]; j1++)
				{
					beta_block[1] = CHAM_a_beta[X0_block[1]][carry_block[0]][i1][j1];
					gama_block[1] = CHAM_a_gama[X0_block[1]][carry_block[0]][i1][j1];
					carry_block[1] = X0_block_msb[1] +
							((beta_block[1] >> 7) << 1) + (gama_block[1] >> 7);

		//block 2
		for(i2=CHAM_a_wt_min[X0_block[2]][carry_block[1]];
				i2<=CHAM_a_wt_min[X0_block[2]][carry_block[1]] +1; i2++)  //CHAM_a_wt_max[X0_block[2]][carry_block[1]]
		{
			if(i0 + i1 + i2 +
					X0_block_wt_min[3] > w_cmp ){break;}
			for(j2=0; j2<CHAM_a_bg_numb[X0_block[2]][carry_block[1]][i2]; j2++)
			{
				beta_block[2] = CHAM_a_beta[X0_block[2]][carry_block[1]][i2][j2];
				gama_block[2] = CHAM_a_gama[X0_block[2]][carry_block[1]][i2][j2];
				carry_block[2] = X0_block_msb[2] +
						((beta_block[2] >> 7) << 1) + (gama_block[2] >> 7);

		//block 3
		for(i3=msb_CHAM_a_wt_min[X0_block[3]][carry_block[2]];
				i3<=msb_CHAM_a_wt_min[X0_block[3]][carry_block[2]] +1; i3++)  //<8 //msb_CHAM_a_wt_max[X0_block[3]][carry_block[2]]
		{
			if(i0 + i1 + i2 + i3 > w_cmp ){break;}
			for(j3=0; j3< msb_CHAM_a_bg_numb[X0_block[3]][carry_block[2]][i3]; j3++)
			{
				beta_block[3] = msb_CHAM_a_beta[X0_block[3]][carry_block[2]][i3][j3];
				gama_block[3] = msb_CHAM_a_gama[X0_block[3]][carry_block[2]][i3][j3];

				P_w[cur_round] = i0 + i1 + i2 + i3;  // 当前轮的概率重量
				p_sumof_r_P_w[cur_round] = p_sumof_r_P_w[cur_round-1] + P_w[cur_round];

				beta_tmp = ((beta_block[3] << 24) | (beta_block[2] << 16) |
						(beta_block[1] << 8) | beta_block[0]) & Bit_Align;
				gamma_tmp = ((gama_block[3] << 24) | (gama_block[2] << 16) |
						(gama_block[1] << 8) | gama_block[0]) & Bit_Align;

				//整理给下一轮的输入差分
				Output_X[0] = ROTATE_RIGHT(beta_tmp, ROL_a, blocksize_len) & Bit_Align;
				Output_X[3] = ROTATE_LEFT(gamma_tmp, ROL_b, blocksize_len) & Bit_Align;

				if(cur_round >= 3 ) //第4轮之后跳转的CHAM_Diff_trail_round_r进行两个输入差分的查询输出差分的过程
				{
					best = CHAM_Diff_trail_round_r(search_round, cur_round+1, Output_X);
				}
				else
				{
					best = CHAM_Diff_trail_round_23(search_round, cur_round+1, Output_X);
				}
#if 1   //是否找到第一条最优路径就返回？
				if(best == 1 )
				{
					if(cur_round == 2 ) //记录第2轮的输入
					{
						CHAM_X[0][cur_round] = input_x[0];
						CHAM_X[1][cur_round] = Output_X[0];
						CHAM_X[2][cur_round] = CHAM_X[1][3];
						CHAM_X[3][cur_round] = input_x[3];
					}

					if(cur_round == 3 ) //记录第3轮的输出
					{
						CHAM_X[0][cur_round] = input_x[0];
						CHAM_X[1][cur_round] = Output_X[0];
						CHAM_X[2][cur_round] = Output_X[1];
						CHAM_X[3][cur_round] = Output_X[2];

						CHAM_X[0][cur_round+1] = Output_X[0];
						CHAM_X[1][cur_round+1] = Output_X[1];
						CHAM_X[2][cur_round+1] = Output_X[2];
						CHAM_X[3][cur_round+1] = Output_X[3];
					}
					return 1;
				}
#endif
		}}}}}}}}
#endif
	return best;
}


u32 CHAM_Diff_trail_round_r(u16 search_round, u16 cur_round, u32 *input_x)
{
	u32 best = 0;
	u16 ROL_a = 1, ROL_b = 8;
	u32 gamma_tmp=0;
	u32 Output_X[4] = {0};
	u32 gama_block[4] = {0};
	u8 carry_block[4] = {0};
	u8 X0_block[4] = {0};
	u32 X1_tmp = 0;
	u8 X1_block[4] = {0};
	u8 X0X1_block_msb[4] = {0};
	u32 AB_block[4] = {0};
	u8 AB_block_wt_min[4] = {0};
	u32 xor_alpha_beta = 0;
//	u16 i=0;
//	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16 w_cmp = 0;
	u16 i0=0,i1=0,i2=0,i3=0;
	u16 j0=0,j1=0,j2=0,j3=0;
//	u8 Block_wt_max[4] = {8,8,8,8};


	if( cur_round >= search_round)  //跳转到最后一轮
	{
		best = CHAM_Diff_trail_round_N(search_round, input_x);
		return best;
	}

#if (CHAM_even_round == 0 ) //当前搜索参数（1，8）开始的奇数轮的最优路径
	if((cur_round & 0x01) == 0)  //偶数轮 %2
	{
		ROL_a = 8; ROL_b = 1;
		w_cmp = Bn_w - p_sumof_r_P_w[cur_round-1] - n_P_bestofR_w[search_round - cur_round];
	}
	else  // 奇数轮
	{
		//ROL_a =1; ROL_b = 8; //默认的值就是1,8
		w_cmp = Bn_w - p_sumof_r_P_w[cur_round-1] - CHAM_Pw_even_wt[search_round - cur_round];
	}
#else  //CHAM_even_round=1, 当前搜索参数（8,1）开始的偶数轮的最优路径
	if((cur_round & 0x01) == 0)  //偶数轮 %2
	{
		//ROL_a = 1; ROL_b = 8;  //默认的值就是1,8
		w_cmp = Bn_w - p_sumof_r_P_w[cur_round-1] - CHAM_Pw_even_wt[search_round - cur_round];
	}
	else  // 奇数轮
	{
		ROL_a =8; ROL_b = 1;
		w_cmp = Bn_w - p_sumof_r_P_w[cur_round-1] - n_P_bestofR_w[search_round - cur_round];
	}
#endif


	//处理CHAM-64 或者 CHAM-128
#if (CHAM_64_or_128 == 64)
		X1_tmp = ROTATE_LEFT(input_x[1], ROL_a, blocksize_len); // & Bit_Align;
		//确定每个输入差分alpha||beta的每8比特的子块所对应的可能的最小差分概率重量
		xor_alpha_beta = (X1_tmp ^ input_x[0]); // & 0x7FFF;
		if( _mm_popcnt_u64(xor_alpha_beta & 0x7FFF) > w_cmp)
		{return 0;}

/*		for(i=0; i< nBytes; i++)
		{
			X0_block[i] = (input_x[0] >> (8*i)) & 0xFF;   //取出每个8比特
			X1_block[i] = (X1_tmp >> (8*i)) & 0xFF;   //取出每个8比特
			AB_block[i] = X1_block[i]*256 + X0_block[i];
			AB_block_wt_min[i] = (u8)_mm_popcnt_u64( (xor_alpha_beta >> (i*8)) & 0xFF );
		}
*/
		X0_block[0] = input_x[0] & 0xFF;   //取出每个8比特
		X1_block[0] = X1_tmp & 0xFF;   //取出每个8比特
		AB_block[0] = X1_block[0] *256 + X0_block[0];
		AB_block_wt_min[0] = (u8)_mm_popcnt_u64(xor_alpha_beta & 0xFF);
		X0_block[1] = (input_x[0] >> 8) & 0xFF;   //取出每个8比特
		X1_block[1] = (X1_tmp >> 8) & 0xFF;   //取出每个8比特
		AB_block[1] = X1_block[1] *256 + X0_block[1];
		AB_block_wt_min[1] = (u8)_mm_popcnt_u64(xor_alpha_beta & 0x7F00);

		X0X1_block_msb[0] = ((X0_block[0] >> 7) << 2) + ((X1_block[0] >> 7) << 1);  //alpha 最低8比特的 MSB
		//整理给下一轮的输入差分
		Output_X[0] = input_x[1];
		Output_X[1] = input_x[2];
		Output_X[2] = input_x[3];

		//block 0
		for(i0=cDDT_wt_min[0][AB_block[0]];
				i0<= cDDT_wt_min[0][AB_block[0]] ; i0++)  //<=8  // //cDDT_wt_max[0][AB_block[0]]
		{
			if(i0 + AB_block_wt_min[1] > w_cmp){break;}
			for(j0=0; j0 < cDDT_n[0][AB_block[0]][i0]; j0++)
			{
				gama_block[0] = cDDT_v[0][AB_block[0]][i0][j0];
				carry_block[0] = X0X1_block_msb[0] + (gama_block[0] >> 7);

		//block 1  MSB_cDDT_v
		for(i1=MSB_cDDT_wt_min[carry_block[0]][AB_block[1]];
				i1<=MSB_cDDT_wt_min[carry_block[0]][AB_block[1]] ; i1++)  //<8 //Block_wt_max[1] //MSB_cDDT_wt_max[carry_block[0]][AB_block[1]]
			{
				if(i0 + i1 > w_cmp){break;}
				for(j1=0; j1 < MSB_cDDT_n[carry_block[0]][AB_block[1]][i1]; j1++)
				{
					gama_block[1] = MSB_cDDT_v[carry_block[0]][AB_block[1]][i1][j1];

					P_w[cur_round] = i0 + i1;  //
					p_sumof_r_P_w[cur_round] = p_sumof_r_P_w[cur_round-1] + P_w[cur_round];

					gamma_tmp = ((gama_block[1] << 8) | gama_block[0]) & Bit_Align;
					//整理给下一轮的输入差分
					Output_X[3] = ROTATE_LEFT(gamma_tmp, ROL_b, blocksize_len) & Bit_Align;

					best = CHAM_Diff_trail_round_r(search_round, cur_round+1, Output_X);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			CHAM_X[0][cur_round+1] = Output_X[0];
			CHAM_X[1][cur_round+1] = Output_X[1];
			CHAM_X[2][cur_round+1] = Output_X[2];
			CHAM_X[3][cur_round+1] = Output_X[3];
			return 1;
		}
#endif
		}}}}
#else //CHAM-128
		X1_tmp = ROTATE_LEFT(input_x[1], ROL_a, blocksize_len) & Bit_Align;
		//确定每个输入差分alpha||beta的每8比特的子块所对应的可能的最小差分概率重量
		xor_alpha_beta = (X1_tmp ^ input_x[0]) & Bit_Align;
/*		for(i=0; i< nBytes; i++)
		{
			X0_block[i] = (input_x[0] >> (8*i)) & 0xFF;   //取出每个8比特
			X1_block[i] = (X1_tmp >> (8*i)) & 0xFF;   //取出每个8比特
			AB_block[i] = X1_block[i]*256 + X0_block[i];
			AB_block_wt_min[i] = (u8)_mm_popcnt_u64( (xor_alpha_beta >> (i*8)) & 0xFF );
		}
*/
		X0_block[0] = input_x[0] & 0xFF;   //取出每个8比特
		X1_block[0] = X1_tmp & 0xFF;   //取出每个8比特
		AB_block[0] = X1_block[0]*256 + X0_block[0];
		AB_block_wt_min[0] = (u8)_mm_popcnt_u64(xor_alpha_beta & 0xFF );
		X0_block[1] = (input_x[0] >> 8) & 0xFF;   //取出每个8比特
		X1_block[1] = (X1_tmp >> 8) & 0xFF;   //取出每个8比特
		AB_block[1] = X1_block[1]*256 + X0_block[1];
		AB_block_wt_min[1] = (u8)_mm_popcnt_u64( xor_alpha_beta & 0x0000FF00 );
		X0_block[2] = (input_x[0] >> 16) & 0xFF;   //取出每个8比特
		X1_block[2] = (X1_tmp >> 16) & 0xFF;   //取出每个8比特
		AB_block[2] = X1_block[2]*256 + X0_block[2];
		AB_block_wt_min[2] = (u8)_mm_popcnt_u64( xor_alpha_beta & 0x00FF0000 );
		X0_block[3] = (input_x[0] >> 24) & 0xFF;   //取出每个8比特
		X1_block[3] = (X1_tmp >> 24) & 0xFF;   //取出每个8比特
		AB_block[3] = X1_block[3]*256 + X0_block[3];
		AB_block_wt_min[3] = (u8)_mm_popcnt_u64( xor_alpha_beta & 0x7F000000 );


		//粗略剪枝条件
		if( AB_block_wt_min[0] + AB_block_wt_min[1] +
				AB_block_wt_min[2] + AB_block_wt_min[3] > w_cmp)
		{return 0;}

		X0X1_block_msb[0] = ((X0_block[0] >> 7) << 2) + ((X1_block[0] >> 7) << 1);  //alpha 最低8比特的 MSB
		X0X1_block_msb[1] = ((X0_block[1] >> 7) << 2) + ((X1_block[1] >> 7) << 1);  //alpha 最低8比特的 MSB
		X0X1_block_msb[2] = ((X0_block[1] >> 7) << 2) + ((X1_block[2] >> 7) << 1);  //alpha 最低8比特的 MSB

		//整理给下一轮的输入差分
		Output_X[0] = input_x[1];
		Output_X[1] = input_x[2];
		Output_X[2] = input_x[3];

		//block 0
		for(i0=cDDT_wt_min[0][AB_block[0]];
				i0<=cDDT_wt_min[0][AB_block[0]] ; i0++)
		{
			if(i0 + AB_block_wt_min[1] +
					AB_block_wt_min[2] + AB_block_wt_min[3] > w_cmp ){break;}
			for(j0=0; j0<cDDT_n[0][AB_block[0]][i0]; j0++)
			{
				gama_block[0] = cDDT_v[0][AB_block[0]][i0][j0];
				carry_block[0] = X0X1_block_msb[0] + (gama_block[0] >> 7);

		//block 1
		for(i1=cDDT_wt_min[carry_block[0]][AB_block[1]];
				i1<=cDDT_wt_min[carry_block[0]][AB_block[1]] ; i1++) ///cDDT_wt_max[carry_block[0]][AB_block[1]]
			{
				if(i0 + i1 +
						AB_block_wt_min[2] + AB_block_wt_min[3] > w_cmp ){break;}
				for(j1=0; j1<cDDT_n[carry_block[0]][AB_block[1]][i1]; j1++)
				{
					gama_block[1] = cDDT_v[carry_block[0]][AB_block[1]][i1][j1];
					carry_block[1] = X0X1_block_msb[1] + (gama_block[1] >> 7);

		//block 2
		for(i2=cDDT_wt_min[carry_block[1]][AB_block[2]];
				i2<=cDDT_wt_min[carry_block[1]][AB_block[2]] ; i2++)  ////
		{
			if(i0 + i1 + i2 +
					AB_block_wt_min[3] > w_cmp ){break;}
			for(j2=0; j2<cDDT_n[carry_block[1]][AB_block[2]][i2]; j2++)
			{
				gama_block[2] = cDDT_v[carry_block[1]][AB_block[2]][i2][j2];
				carry_block[2] = X0X1_block_msb[2] + (gama_block[2] >> 7);

		//block 3
		for(i3=MSB_cDDT_wt_min[carry_block[2]][AB_block[3]];
				i3<=MSB_cDDT_wt_min[carry_block[2]][AB_block[3]] ; i3++)  //
		{
			if(i0 + i1 + i2 + i3 > w_cmp ){break;}
			for(j3=0; j3<MSB_cDDT_n[carry_block[2]][AB_block[3]][i3]; j3++)
			{
				gama_block[3] = MSB_cDDT_v[carry_block[2]][AB_block[3]][i3][j3];

				P_w[cur_round] = i0 + i1 + i2 + i3;  // 当前轮的概率重量
				p_sumof_r_P_w[cur_round] = p_sumof_r_P_w[cur_round-1] + P_w[cur_round];

				gamma_tmp = ((gama_block[3] << 24) | (gama_block[2] << 16) |
						(gama_block[1] << 8) | gama_block[0]) & Bit_Align;
				Output_X[3] = ROTATE_LEFT(gamma_tmp, ROL_b, blocksize_len) & Bit_Align;

				best = CHAM_Diff_trail_round_r(search_round, cur_round+1, Output_X);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		CHAM_X[0][cur_round+1] = Output_X[0];
		CHAM_X[1][cur_round+1] = Output_X[1];
		CHAM_X[2][cur_round+1] = Output_X[2];
		CHAM_X[3][cur_round+1] = Output_X[3];
		return 1;
	}
#endif
		}}}}}}}}
#endif
	return best;
}



u32 CHAM_Diff_trail_round_N(u16 search_round, u32 *input_x)
{
	u32 best = 0;
	u16 ROL_a = 8, ROL_b = 1;
	u32 gamma_tmp=0;
//	u32 Output_X[4] = {0};
	u32 gama_block[4] = {0};
	u8 carry_block[4] = {0};
	u8 X0_block[4] = {0};
	u32 X1_tmp = 0;
	u8 X1_block[4] = {0};
	u8 X0X1_block_msb[4] = {0};
	u32 AB_block[4] = {0};
	u8 AB_block_wt_min[4] = {0};
	u32 xor_alpha_beta = 0;
	u16 i=0;
//	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16 w_cmp = 0;
	u16 i0=0,i1=0,i2=0,i3=0;
	u16 j0=0,j1=0,j2=0,j3=0;


#if(CHAM_even_round == 0) //结束条件判断是搜索的奇数还是偶数轮开始的路径
	{
		if((search_round &0x01) == 0)  //偶数轮
		{
			ROL_a = 8; ROL_b = 1;
		}
		else  //奇数轮
		{
			ROL_a =1; ROL_b = 8;
		}
	}
#else // 搜索的路径为从奇数轮开始的
	{
		if((search_round &0x01) == 0)  //偶数轮
		{
			ROL_a = 1; ROL_b = 8;
		}
		else  //奇数轮
		{
			ROL_a =8; ROL_b = 1;
		}
	}
#endif

	w_cmp = Bn_w - p_sumof_r_P_w[search_round-1]; // p_sumof_r is the sum of r-1 rounds weight.
	//if( 0 > w_cmp)	{return 0;}
//处理CHAM-64 或者 CHAM-128
#if (CHAM_64_or_128 == 64)
		X1_tmp = ROTATE_LEFT(input_x[1], ROL_a, blocksize_len); // & Bit_Align;
		//确定每个输入差分alpha||beta的每8比特的子块所对应的可能的最小差分概率重量
		xor_alpha_beta = (X1_tmp ^ input_x[0]); // & 0x7FFF;
		if( _mm_popcnt_u64(xor_alpha_beta & 0x7FFF) > w_cmp)
		{return 0;}

/*		for(i=0; i< nBytes; i++)
		{
			X0_block[i] = (input_x[0] >> (8*i)) & 0xFF;   //取出每个8比特
			X1_block[i] = (X1_tmp >> (8*i)) & 0xFF;   //取出每个8比特
			AB_block[i] = X1_block[i]*256 + X0_block[i];
			AB_block_wt_min[i] = (u8)_mm_popcnt_u64( (xor_alpha_beta >> (i*8)) & 0xFF );
		}
*/
		X0_block[0] = input_x[0] & 0xFF;   //取出每个8比特
		X1_block[0] = X1_tmp & 0xFF;   //取出每个8比特
		AB_block[0] = X1_block[0] *256 + X0_block[0];
		AB_block_wt_min[0] = (u8)_mm_popcnt_u64(xor_alpha_beta & 0xFF);
		X0_block[1] = (input_x[0] >> 8) & 0xFF;   //取出每个8比特
		X1_block[1] = (X1_tmp >> 8) & 0xFF;   //取出每个8比特
		AB_block[1] = X1_block[1] *256 + X0_block[1];
		AB_block_wt_min[1] = (u8)_mm_popcnt_u64(xor_alpha_beta & 0x7F00);

		X0X1_block_msb[0] = ((X0_block[0] >> 7) << 2) + ((X1_block[0] >> 7) << 1);  //alpha 最低8比特的 MSB

		//最后一轮，只用考虑到wt取最小值的情况即可
		for(i0=cDDT_wt_min[0][AB_block[0]];
				i0<= cDDT_wt_min[0][AB_block[0]]; i0++) //8 //Block_wt_max[0]
		{
			if(i0 + AB_block_wt_min[1] > w_cmp ){break;}
			for(j0=0; j0 < cDDT_n[0][AB_block[0]][i0]; j0++)
			{
				gama_block[0] = cDDT_v[0][AB_block[0]][i0][j0];
				carry_block[0] = (X0X1_block_msb[0] + (gama_block[0] >> 7));

		for(i1=MSB_cDDT_wt_min[carry_block[0]][AB_block[1]];
				i1<=MSB_cDDT_wt_min[carry_block[0]][AB_block[1]]; i1++) //8 //Block_wt_max[1]
			{
				//if(i0 + i1 > w_cmp ){break;}
			if(i0 + i1 > 0 )
				if(i0 + i1 <= w_cmp ){   //找到最优差分路径
				for(j1=0; j1 < MSB_cDDT_n[carry_block[0]][AB_block[1]][i1]; j1++)
				{
					gama_block[1] = MSB_cDDT_v[carry_block[0]][AB_block[1]][i1][j1];

					P_w[search_round] = i0 + i1 ;  //
					p_sumof_r_P_w[search_round] = p_sumof_r_P_w[search_round-1] + P_w[search_round];
					printf("++++++++++++++Real weight: %d +++++++++++\n", p_sumof_r_P_w[search_round]);
					gamma_tmp = ((gama_block[1] << 8) | gama_block[0]) & Bit_Align;
					//整理给最后一轮的输输出差分
					CHAM_X[0][search_round+1] = input_x[1];
					CHAM_X[1][search_round+1] = input_x[2];
					CHAM_X[2][search_round+1] = input_x[3];
					CHAM_X[3][search_round+1] = ROTATE_LEFT(gamma_tmp, ROL_b, blocksize_len) & Bit_Align;

					//best  = 1;
#if(CHAM_even_round == 0) //当搜索开始是从 奇数 轮开始的话，搜索结果记录到n_P_bestofR_w
					{
						if(p_sumof_r_P_w[search_round] <=Bn_w)
						{
							n_P_bestofR_w[search_round] = Bn_w;
							//p_sumof_r_P_w[search_round-1] + P_w[search_round];    //
						}

					}
#else  //当搜索开始是从 偶数 轮开始的话，搜索线性结果记录到CHAM_Pw_even_cor
					{
						if(p_sumof_r_P_w[search_round] <=Bn_w)
						{
							//p_sumof_r_P_w[search_round-1] + P_w[search_round];    //
							CHAM_Pw_even_wt[search_round] = Bn_w;
						}
					}
#endif
					return 1;
		}}}}}

#else  //搜索CHAM128
		X1_tmp = ROTATE_LEFT(input_x[1], ROL_a, blocksize_len) & Bit_Align;
		//确定每个输入差分alpha||beta的每8比特的子块所对应的可能的最小差分概率重量
		xor_alpha_beta = (X1_tmp ^ input_x[0]) & Bit_Align;
		for(i=0; i< nBytes; i++)
		{
			X0_block[i] = (input_x[0] >> (8*i)) & 0xFF;   //取出每个8比特
			X1_block[i] = (X1_tmp >> (8*i)) & 0xFF;   //取出每个8比特
			AB_block[i] = X1_block[i]*256 + X0_block[i];
			AB_block_wt_min[i] = (u8)_mm_popcnt_u64( (xor_alpha_beta >> (i*8)) & 0xFF );
		}

		//粗略剪枝条件
		if( AB_block_wt_min[0] + AB_block_wt_min[1] +
				AB_block_wt_min[2] + AB_block_wt_min[3] > w_cmp)
		{return 0;}

		X0X1_block_msb[0] = ((X0_block[0] >> 7) << 2) + ((X1_block[0] >> 7) << 1);  //alpha 最低8比特的 MSB
		X0X1_block_msb[1] = ((X0_block[1] >> 7) << 2) + ((X1_block[1] >> 7) << 1);  //alpha 最低8比特的 MSB
		X0X1_block_msb[2] = ((X0_block[1] >> 7) << 2) + ((X1_block[2] >> 7) << 1);  //alpha 最低8比特的 MSB


		//block 0
		for(i0=cDDT_wt_min[0][AB_block[0]];
				i0<=cDDT_wt_min[0][AB_block[0]]; i0++)
		{
			if(i0 + AB_block_wt_min[1] +
					AB_block_wt_min[2] + AB_block_wt_min[3] > w_cmp ){break;}
			for(j0=0; j0<cDDT_n[0][AB_block[0]][i0]; j0++)
			{
				gama_block[0] = cDDT_v[carry_block[0]][AB_block[0]][i0][j0];
				carry_block[0] = X0X1_block_msb[0] + (gama_block[0] >> 7);

		//block 1
		for(i1=cDDT_wt_min[carry_block[0]][AB_block[1]];
				i1<=cDDT_wt_min[carry_block[0]][AB_block[1]]; i1++)
			{
				if(i0 + i1 +
						AB_block_wt_min[2] + AB_block_wt_min[3]  > w_cmp ){break;}
				for(j1=0; j1<cDDT_n[carry_block[0]][AB_block[1]][i1]; j1++)
				{
					gama_block[1] = cDDT_v[carry_block[0]][AB_block[1]][i1][j1];
					carry_block[1] = X0X1_block_msb[1] + (gama_block[1] >> 7);

		//block 2
		for(i2=cDDT_wt_min[carry_block[1]][AB_block[2]];
				i2<=cDDT_wt_min[carry_block[1]][AB_block[2]]; i2++)
		{
			if(i0 + i1 + i2 +
					AB_block_wt_min[3] > w_cmp ){break;}
			for(j2=0; j2<cDDT_n[carry_block[1]][AB_block[2]][i2]; j2++)
			{
				gama_block[2] = cDDT_v[carry_block[1]][AB_block[2]][i2][j2];
				carry_block[2] = X0X1_block_msb[2] + (gama_block[2] >> 7);

		//block 3
		for(i3=MSB_cDDT_wt_min[carry_block[2]][AB_block[3]];
				i3<=MSB_cDDT_wt_min[carry_block[2]][AB_block[3]]; i3++)
		{
			//if(i0 + i1 + i2 + i3 > w_cmp ){break;}
		if(i0 + i1 + i2 + i3 > 0 )
			if(i0 + i1 + i2 + i3 <= w_cmp ){
			for(j3=0; j3<MSB_cDDT_n[carry_block[2]][AB_block[3]][i3]; j3++)
			{
				gama_block[3] = MSB_cDDT_v[carry_block[2]][AB_block[3]][i3][j3];

				P_w[search_round] = i0 + i1 + i2 + i3;  // 当前轮的概率重量
				p_sumof_r_P_w[search_round] = p_sumof_r_P_w[search_round-1] + P_w[search_round];
				printf("++++++++++++++Real weight: %d +++++++++++\n", p_sumof_r_P_w[search_round]);

				gamma_tmp = ((gama_block[3] << 24) | (gama_block[2] << 16) |
						(gama_block[1] << 8) | gama_block[0]) & Bit_Align;
				//整理给最后一轮的输输出差分
				CHAM_X[0][search_round+1] = input_x[1];
				CHAM_X[1][search_round+1] = input_x[2];
				CHAM_X[2][search_round+1] = input_x[3];
				CHAM_X[3][search_round+1] = ROTATE_LEFT(gamma_tmp, ROL_b, blocksize_len) & Bit_Align;

#if(CHAM_even_round == 0) //当搜索开始是从 奇数 轮开始的话，搜索结果记录到n_P_bestofR_w
					{
						if(p_sumof_r_P_w[search_round] <=Bn_w)
						{
							n_P_bestofR_w[search_round] = Bn_w;
							//p_sumof_r_P_w[search_round-1] + P_w[search_round];    //
						}

					}
#else  //当搜索开始是从 偶数 轮开始的话，搜索线性结果记录到CHAM_Pw_even_cor
					{
						if(p_sumof_r_P_w[search_round] <=Bn_w)
						{
							//p_sumof_r_P_w[search_round-1] + P_w[search_round];    //
							CHAM_Pw_even_wt[search_round] = Bn_w;
						}
					}
#endif
				return 1;
		}}}}}}}}}
#endif
	return best;
}



////////////////////////////////搜索CHAM的最优 线性 特征的代码//////////////////////////////
////////////////////////////////搜索CHAM的最优 线性 特征的代码//////////////////////////////
////////////////////////////////搜索CHAM的最优 线性 特征的代码//////////////////////////////
/**
 * @搜索CHAM的最优线性特征的代码
 * @ MOde_2
 */
u32 CHAM_64_Linear_trail_search_entry(u16 search_round)
{
	u32 best = 0;
	u16 i = 0;
	u16 Bn_expected = 0;
	FILE* CHAM_64_linear_Bn;
	FILE* CHAM_64_linear_Bn_even;


	if(sc_blocksize != 64)
	{
		printf("The block size of CHAM should be 64 bits. \n");
		return 0;
	}
	// For CHAM modular additon is 16 bits.
	blocksize_len = 16;
	Bit_Align = 0xFFFF;
	ValueMax_Align = 0x7FFF;
	V_MSB = 0x8000;

	CHAM_64_linear_Bn = fopen ("../tmp/CHAM_64_linear_Bn_wt.xlsx", "a+"); //  "a+"); //
	CHAM_64_linear_Bn_even = fopen ("../tmp/CHAM_64_linear_Bn_wt_even.xlsx", "a+"); //  "a+"); //
	Bn_w = 0;
	if(search_round > 1)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(CHAM_64_linear_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			fscanf(CHAM_64_linear_Bn_even,"%d",&CHAM_Pw_even_cor[i]);  //read.
		}
#if(CHAM_even_round == 0) //结束条件判断是搜索的奇数还是偶数轮开始的路径,=0为奇数轮开始的正常搜索
		{
			printf("===============Search odd-round============= \n");
			Bn_w = n_P_bestofR_w[search_round -1] - 1;
		}
#else
		{
			printf("===============Search even-round============= \n");
			Bn_w = CHAM_Pw_even_cor[search_round -1] - 1;
		}
#endif
	}

	printf("Constructing CHAM-64 cLAT Tables... \n");
	//构造部分的线性相关性近似表cLAT
	ARX_cLAT_construct();
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct CHAM-64 cLAT: %.2f seconds.  \n", run_time);



//	Bn_w = 0;  //直接设定开始的概率重量,快速达到期望的概率重量
		do
		{
			Bn_w = Bn_w + 1;
			printf("Searching CHAM-64 Bn_w: %d \n", Bn_w);

			//对应CHAM，需要分别搜索奇数和偶数轮开始的截断路径
	//		CHAM_even = 0;  //0 为奇数轮开始的，1为偶数轮开始的
			// Search Entry.
			best = CHAM_R1_tuples(search_round); //效率高

			//u16 Masks_out[4] = {0};  //第5轮的输入掩码

			//Masks_out[2] =  0x0100;
			//跳转到第5轮开始搜索
//			best = CHAM_round_r_odd(search_round, 5, Masks_out);
/*
			P_w[7] = 1; P_w[8] = 1; P_w[9] = 1; P_w[10] = 1; P_w[11] = 1;
			Masks_out[0] =  0x8120;
			Masks_out[1] =  0x0080;
			Masks_out[2] =  0x8000;
			Masks_out[3] =  0x6100;
			best = CHAM_round_r_odd(search_round, 12, Masks_out);
*/



			time_Round = clock();
			run_time =  (time_Round - time_ARX_cLAT) / CLOCKS_PER_SEC;
			printf("Time: %.2f seconds.  \n", run_time);

#if(CHAM_even_round == 0) //结束条件判断是搜索的奇数还是偶数轮开始的路径
			{
				Bn_expected =  n_P_bestofR_w[search_round];
			}
#else
			{
				Bn_expected =  CHAM_Pw_even_cor[search_round];
			}
#endif
		}while(Bn_w != Bn_expected);   //end conditions.

		print_CHAM_64_linear_resoult(search_round);  //打印CHASKEY的输入输出掩码

		time_finish = clock();
		run_time = (double)(time_finish - time_ARX_cLAT) / CLOCKS_PER_SEC;
		printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours == %.2f days. \n", run_time,run_time/60.0,run_time/3600.0,run_time/86400.0 );
		printf("Auto-search CHAM-64 optimal linear trails END! \n");
		printf("|************************************************************************|\n");

#if(CHAM_even_round == 0) //结束条件判断是搜索的奇数还是偶数轮开始的路径
		{
			fprintf(CHAM_64_linear_Bn,"%d \n",n_P_bestofR_w[search_round]);  // write.
		}
#else
		{
			fprintf(CHAM_64_linear_Bn_even,"%d \n",CHAM_Pw_even_cor[search_round]);  // write.
		}
#endif
		fclose(CHAM_64_linear_Bn);
		fclose(CHAM_64_linear_Bn_even);

	return best;
}



u32 CHAM_R1_tuples(u16 search_round)
{
	u32 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 cor_wt = 0;

	u64 M0 = 0;
	u64 N0 = blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;


	///////////////////round 1 entry/////////////////////
	for(cor_wt = 0; cor_wt < blocksize_len-1; cor_wt++)  //0-->n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if( (cor_wt + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}

		M0 = cor_wt;  //
		P_w[1] = M0; //相关性重量的记录数组

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			CHAM_64_u[1] = Input_u;
			CHAM_64_v[1] = Input_v;
			CHAM_64_w[1] = Input_w;

			//直接跳转到第2轮
			best = CHAM_R2_tuples(search_round);

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;

			CHAM_64_u[1] = Input_u;
			CHAM_64_v[1] = Input_v;
			CHAM_64_w[1] = Input_w;

			//直接跳转到第2轮
			best = CHAM_R2_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			//直接跳转到第1轮各个部分的内部构造
			best = CHAM_R1_tuples_ADD_Last(search_round,P_w[1],C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHASKEY_Linear;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHASKEY_Linear;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHASKEY_Linear;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHASKEY_Linear;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHASKEY_Linear;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
	CHASKEY_Linear:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}
///////////////输出其它的分布模式/////////////////
				//直接跳转到第1轮各个部分的内部构造
				best = CHAM_R1_tuples_ADD_Last(search_round,P_w[1],C0);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}

	return best;
}


u16 CHAM_R1_tuples_ADD_Last(u16 search_round, u16 Cw_1, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

		//跳转到高比特分析
		best = CHAM_R1_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_1, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = CHAM_R1_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_1, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = CHAM_R1_tuples_ADD_Middle(search_round,
					Input_u, Input_v, Input_w,
					Cw_1, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}

u16 CHAM_R1_tuples_ADD_Middle(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= Cw_1 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = CHAM_R1_tuples_ADD_MSB(search_round,
				tmp_U,tmp_V,tmp_W,
				Cw_1, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

				if(current_index <= blocksize_len -2)
				{
				//跳转到高比特分析
				best = CHAM_R1_tuples_ADD_Middle(search_round,
						tmp_U, tmp_V, tmp_W,
						Cw_1, Corr_tmp_inc, posi,
						current_index + 1, Fwt);
				}
				else
				{
					best = CHAM_R1_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_1, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//跳转到高比特分析
				best = CHAM_R1_tuples_ADD_Middle(search_round,
						Input_u, Input_v, Input_w,
						Cw_1, Corr_tmp_inc, posi,
						current_index +1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_R1_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_1, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_R1_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_1, Corr_tmp_inc +1, posi,
							current_index +1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 CHAM_R1_tuples_ADD_MSB(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


		if(Corr_tmp_inc > Cw_1)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
		{
			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				CHAM_64_u[1] = tmp_U;
				CHAM_64_v[1] = tmp_V;
				CHAM_64_w[1] = tmp_W;
				//直接跳转到第2轮
				best = CHAM_R2_tuples(search_round);
			}
			else
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				CHAM_64_u[1] = Input_u;
				CHAM_64_v[1] = Input_v;
				CHAM_64_w[1] = Input_w;
				//直接跳转到第2轮
				best = CHAM_R2_tuples(search_round);
			}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		}
		else  // Corr_tmp_inc == part_wt 搜索的当前wt与期望的相关性重量相等
		{
			if( (posi[Cw_1]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0; //!= >
			{
				if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
				{
					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = CHAM_R1_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_1, Corr_tmp_inc,posi,
							current_index +1, Fwt);
				}
				else
				{
					// UVW_i 为7
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
					Input_w = tmp_W | (bit_i << current_index); //该位置置1

					CHAM_64_u[1] = Input_u;
					CHAM_64_v[1] = Input_v;
					CHAM_64_w[1] = Input_w;
					//直接跳转到第2轮
					best = CHAM_R2_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
				}
			}
			else  //(posi[part_wt]-1) == current_index
			{

			if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW[i+1]位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_64_u[1] = Input_u;
					CHAM_64_v[1] = Input_v;
					CHAM_64_w[1] = Input_w;
					//直接跳转到第2轮
					best = CHAM_R2_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
				}
			}
			else
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW的最高位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_64_u[1] = Input_u;
					CHAM_64_v[1] = Input_v;
					CHAM_64_w[1] = Input_w;
					//直接跳转到第2轮
					best = CHAM_R2_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}}
			}}
		return best;
}


u32 CHAM_R2_tuples(u16 search_round)
{
	u32 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 cor_wt = 0;

	u64 M0 = 0;
	u64 N0 = 15; //blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;


	///////////////////round 1 entry/////////////////////
	for(cor_wt = 0; cor_wt < blocksize_len-1; cor_wt++)  //0-->n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if( (P_w[1]+cor_wt + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}

		M0 = cor_wt;  //
		P_w[2] = M0; //相关性重量的记录数组

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			CHAM_64_u[2] = Input_u;
			CHAM_64_v[2] = Input_v;
			CHAM_64_w[2] = Input_w;

			//直接跳转到第3轮
			best = CHAM_R3_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;

			CHAM_64_u[2] = Input_u;
			CHAM_64_v[2] = Input_v;
			CHAM_64_w[2] = Input_w;

			//直接跳转到第3轮
			best = CHAM_R3_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			//直接跳转到内部构造
			best = CHAM_R2_tuples_ADD_Last(search_round,P_w[2],C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHASKEY_Linear;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHASKEY_Linear;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHASKEY_Linear;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHASKEY_Linear;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHASKEY_Linear;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
	CHASKEY_Linear:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}
///////////////输出其它的分布模式/////////////////
				//直接跳转到内部构造
				best = CHAM_R2_tuples_ADD_Last(search_round,
						P_w[2],C0);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}

	return best;
}


u16 CHAM_R2_tuples_ADD_Last(u16 search_round,u16 Cw_2, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

		//跳转到高比特分析
		best = CHAM_R2_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_2, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = CHAM_R2_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_2, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = CHAM_R2_tuples_ADD_Middle(search_round,
					Input_u, Input_v, Input_w,
					Cw_2, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}

u16 CHAM_R2_tuples_ADD_Middle(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_2, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= Cw_2 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = CHAM_R2_tuples_ADD_MSB(search_round,
				tmp_U,tmp_V,tmp_W,
				Cw_2, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

				if(current_index <= blocksize_len -2)
				{
				//跳转到高比特分析
				best = CHAM_R2_tuples_ADD_Middle(search_round,
						tmp_U, tmp_V, tmp_W,
						Cw_2, Corr_tmp_inc, posi,
						current_index + 1, Fwt);
				}
				else
				{
					best = CHAM_R2_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_2, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//跳转到高比特分析
				best = CHAM_R2_tuples_ADD_Middle(search_round,
						Input_u, Input_v, Input_w,
						Cw_2, Corr_tmp_inc, posi,
						current_index +1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_R2_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_2, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_R2_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_2, Corr_tmp_inc +1, posi,
							current_index +1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 CHAM_R2_tuples_ADD_MSB(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_2, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;

		if(Corr_tmp_inc > Cw_2)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
		{
			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				CHAM_64_u[2] = tmp_U;
				CHAM_64_v[2] = tmp_V;
				CHAM_64_w[2] = tmp_W;
				//直接跳转到第3轮
				best = CHAM_R3_tuples(search_round);
			}
			else
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				CHAM_64_u[2] = Input_u;
				CHAM_64_v[2] = Input_v;
				CHAM_64_w[2] = Input_w;
				//直接跳转到第3轮
				best = CHAM_R3_tuples(search_round);
			}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  // Corr_tmp_inc == part_wt 搜索的当前wt与期望的相关性重量相等
		{
			if( (posi[Cw_2]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0; //!= >
			{
				if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
				{
					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = CHAM_R2_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_2, Corr_tmp_inc,posi,
							current_index +1, Fwt);
				}
				else
				{
					// UVW_i 为7
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
					Input_w = tmp_W | (bit_i << current_index); //该位置置1

					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = CHAM_R2_tuples_ADD_MSB(search_round,
							Input_u, Input_v, Input_w,
							Cw_2, Corr_tmp_inc, posi,
							current_index +1, Fwt);
	#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
	#endif
		}
			}
			else  //(posi[part_wt]-1) == current_index
			{

			if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW[i+1]位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_64_u[2] = Input_u;
					CHAM_64_v[2] = Input_v;
					CHAM_64_w[2] = Input_w;
					//直接跳转到第3轮
					best = CHAM_R3_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
				}
			}
			else
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW的最高位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_64_u[2] = Input_u;
					CHAM_64_v[2] = Input_v;
					CHAM_64_w[2] = Input_w;
					//直接跳转到第3轮
					best = CHAM_R3_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}}
			}}
		return best;
}

u32 CHAM_R3_tuples(u16 search_round)
{
	u32 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 cor_wt = 0;

	u64 M0 = 0;
	u64 N0 = 15; //blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;


	///////////////////round 1 entry/////////////////////
	for(cor_wt = 0; cor_wt < blocksize_len-1; cor_wt++)  //0-->n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if( (P_w[1]+P_w[2]+cor_wt + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}

		M0 = cor_wt;  //
		P_w[3] = M0; //相关性重量的记录数组

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			CHAM_64_u[3] = Input_u;
			CHAM_64_v[3] = Input_v;
			CHAM_64_w[3] = Input_w;
			//直接跳转到第4轮
			best = CHAM_R4_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;

			CHAM_64_u[3] = Input_u;
			CHAM_64_v[3] = Input_v;
			CHAM_64_w[3] = Input_w;
			//直接跳转到第4轮
			best = CHAM_R4_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			//直接跳转到内部构造
			best = CHAM_R3_tuples_ADD_Last(search_round,P_w[3],C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHASKEY_Linear;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHASKEY_Linear;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHASKEY_Linear;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHASKEY_Linear;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHASKEY_Linear;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
	CHASKEY_Linear:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}
///////////////输出其它的分布模式/////////////////
				//直接跳转到内部构造
				best = CHAM_R3_tuples_ADD_Last(search_round,P_w[3],C0);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}

	return best;
}


u16 CHAM_R3_tuples_ADD_Last(u16 search_round,u16 Cw_3, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

		//跳转到高比特分析
		best = CHAM_R3_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_3, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = CHAM_R3_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_3, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = CHAM_R3_tuples_ADD_Middle(search_round,
					Input_u, Input_v, Input_w,
					Cw_3, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}

u16 CHAM_R3_tuples_ADD_MSB(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_3, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;

		if(Corr_tmp_inc > Cw_3)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
		{
			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				CHAM_64_u[3] = tmp_U;
				CHAM_64_v[3] = tmp_V;
				CHAM_64_w[3] = tmp_W;
				//直接跳转到第4轮
				best = CHAM_R4_tuples(search_round);
			}
			else
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				CHAM_64_u[3] = Input_u;
				CHAM_64_v[3] = Input_v;
				CHAM_64_w[3] = Input_w;
				//直接跳转到第4轮
				best = CHAM_R4_tuples(search_round);
			}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  // Corr_tmp_inc == part_wt 搜索的当前wt与期望的相关性重量相等
		{
			if( (posi[Cw_3]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0; //!= >
			{
				if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
				{
					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = CHAM_R3_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_3, Corr_tmp_inc,posi,
							current_index +1, Fwt);
				}
				else
				{
					// UVW_i 为7
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
					Input_w = tmp_W | (bit_i << current_index); //该位置置1

					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = CHAM_R3_tuples_ADD_MSB(search_round,
							Input_u, Input_v, Input_w,
							Cw_3, Corr_tmp_inc, posi,
							current_index +1, Fwt);
	#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
	#endif
		}
			}
			else  //(posi[part_wt]-1) == current_index
			{

			if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW[i+1]位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_64_u[3] = Input_u;
					CHAM_64_v[3] = Input_v;
					CHAM_64_w[3] = Input_w;
					//直接跳转到第4轮
					best = CHAM_R4_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
				}
			}
			else
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW的最高位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_64_u[3] = Input_u;
					CHAM_64_v[3] = Input_v;
					CHAM_64_w[3] = Input_w;
					//直接跳转到第4轮
					best = CHAM_R4_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}}
			}}
		return best;
}

u16 CHAM_R3_tuples_ADD_Middle(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_3, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= Cw_3 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = CHAM_R3_tuples_ADD_MSB(search_round,
				tmp_U,tmp_V,tmp_W,
				Cw_3, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

				if(current_index <= blocksize_len -2)
				{
				//跳转到高比特分析
				best = CHAM_R3_tuples_ADD_Middle(search_round,
						tmp_U, tmp_V, tmp_W,
						Cw_3, Corr_tmp_inc, posi,
						current_index + 1, Fwt);
				}
				else
				{
					best = CHAM_R3_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_3, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//跳转到高比特分析
				best = CHAM_R3_tuples_ADD_Middle(search_round,
						Input_u, Input_v, Input_w,
						Cw_3, Corr_tmp_inc, posi,
						current_index +1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_R3_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_3, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_R3_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_3, Corr_tmp_inc +1, posi,
							current_index +1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u32 CHAM_R4_tuples(u16 search_round)
{
	u32 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 cor_wt = 0;

	u64 M0 = 0;
	u64 N0 = 15; //blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;


	///////////////////round 4 entry/////////////////////
	for(cor_wt = 0; cor_wt < blocksize_len-1; cor_wt++)  //0-->n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if( (P_w[1]+P_w[2]+P_w[3]+cor_wt + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}

		M0 = cor_wt;  //
		P_w[4] = M0; //相关性重量的记录数组

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			CHAM_64_u[4] = Input_u;
			CHAM_64_v[4] = Input_v;
			CHAM_64_w[4] = Input_w;

			//构造前4轮的可能输入输出掩码，并开始搜索第5轮的入口
			best = CHAM_First_4_round_masks_comb(search_round);

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;

			CHAM_64_u[4] = Input_u;
			CHAM_64_v[4] = Input_v;
			CHAM_64_w[4] = Input_w;

			//构造前4轮的可能输入输出掩码，并开始搜索第5轮的入口
			best = CHAM_First_4_round_masks_comb(search_round);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			//直接跳转到内部构造
			best = CHAM_R4_tuples_ADD_Last(search_round,P_w[4],C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHASKEY_Linear;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHASKEY_Linear;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHASKEY_Linear;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHASKEY_Linear;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHASKEY_Linear;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
	CHASKEY_Linear:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}
///////////////输出其它的分布模式/////////////////
				//直接跳转到内部构造
				best = CHAM_R4_tuples_ADD_Last(search_round,P_w[4],C0);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}

	return best;
}


u16 CHAM_R4_tuples_ADD_Last(u16 search_round,u16 Cw_4, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

		//跳转到高比特分析
		best = CHAM_R4_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_4, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = CHAM_R4_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_4, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = CHAM_R4_tuples_ADD_Middle(search_round,
					Input_u, Input_v, Input_w,
					Cw_4, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}

u16 CHAM_R4_tuples_ADD_Middle(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_4, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= Cw_4 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = CHAM_R4_tuples_ADD_MSB(search_round,
				tmp_U,tmp_V,tmp_W,
				Cw_4, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

				if(current_index <= blocksize_len -2)
				{
				//跳转到高比特分析
				best = CHAM_R4_tuples_ADD_Middle(search_round,
						tmp_U, tmp_V, tmp_W,
						Cw_4, Corr_tmp_inc, posi,
						current_index + 1, Fwt);
				}
				else
				{
					best = CHAM_R4_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_4, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//跳转到高比特分析
				best = CHAM_R4_tuples_ADD_Middle(search_round,
						Input_u, Input_v, Input_w,
						Cw_4, Corr_tmp_inc, posi,
						current_index +1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_R4_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_4, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_R4_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_4, Corr_tmp_inc +1, posi,
							current_index +1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 CHAM_R4_tuples_ADD_MSB(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_4, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


		if(Corr_tmp_inc > Cw_4)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
		{
			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				CHAM_64_u[4] = tmp_U;
				CHAM_64_v[4] = tmp_V;
				CHAM_64_w[4] = tmp_W;

				//构造前4轮的可能输入输出掩码，并开始搜索第5轮的入口
				best = CHAM_First_4_round_masks_comb(search_round);
			}
			else
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				CHAM_64_u[4] = Input_u;
				CHAM_64_v[4] = Input_v;
				CHAM_64_w[4] = Input_w;
				//构造前4轮的可能输入输出掩码，并开始搜索第5轮的入口
				best = CHAM_First_4_round_masks_comb(search_round);
			}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  // Corr_tmp_inc == part_wt 搜索的当前wt与期望的相关性重量相等
		{
			if( (posi[Cw_4]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0; //!= >
			{
				if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
				{
					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = CHAM_R4_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_4, Corr_tmp_inc,posi,
							current_index +1, Fwt);
				}
				else
				{
					// UVW_i 为7
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
					Input_w = tmp_W | (bit_i << current_index); //该位置置1

					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = CHAM_R4_tuples_ADD_MSB(search_round,
							Input_u, Input_v, Input_w,
							Cw_4, Corr_tmp_inc, posi,
							current_index +1, Fwt);
	#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
	#endif
		}
			}
			else  //(posi[part_wt]-1) == current_index
			{

			if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW[i+1]位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_64_u[4] = Input_u;
					CHAM_64_v[4] = Input_v;
					CHAM_64_w[4] = Input_w;
					//构造前4轮的可能输入输出掩码，并开始搜索第5轮的入口
					best = CHAM_First_4_round_masks_comb(search_round);
	#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
	#endif
				}
			}
			else
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW的最高位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_64_u[4] = Input_u;
					CHAM_64_v[4] = Input_v;
					CHAM_64_w[4] = Input_w;
					//构造前4轮的可能输入输出掩码，并开始搜索第5轮的入口
					best = CHAM_First_4_round_masks_comb(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return best;
}
#endif
		}}
			}}
		return best;
}


u32 CHAM_First_4_round_masks_comb(u16 search_round)
{
	u32 best=0;
	u16 Masks_out[4] = {0};  //第5轮的输入掩码
	u16 ROL_a =8, ROL_b = 1;  //当搜索开始是从奇数轮开始的话，第4轮的两个旋转参数的默认值为8,1

#if(CHAM_even_round == 1) //当搜索开始是从 偶数 轮开始的话，第4轮的两个旋转参数的默认值为1，8
	{
		ROL_a =1; ROL_b = 8;
	}
#endif

	Masks_out[0] =  ROTATE_RIGHT(CHAM_64_w[4],ROL_a,16) & Bit_Align;
	Masks_out[0] = (Masks_out[0]^ ROTATE_LEFT(CHAM_64_u[1],ROL_a,16)) & Bit_Align;
	Masks_out[1] =  ROTATE_LEFT(CHAM_64_u[2],ROL_b,16) & Bit_Align;
	Masks_out[2] =  ROTATE_LEFT(CHAM_64_u[3],ROL_a,16) & Bit_Align;
	Masks_out[3] =  ROTATE_LEFT(CHAM_64_u[4],ROL_b,16) & Bit_Align;

	//跳转到第5轮开始搜索
#if(CHAM_even_round == 0) //当搜索开始是从 偶数 轮开始的话, 第5轮为奇数轮，否则为偶数轮开始
	{
		best = CHAM_round_r_odd(search_round, 5, Masks_out);
	}
#else
	{
		best = CHAM_round_r_even(search_round, 5, Masks_out);
	}
#endif

#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//计算前4轮的输入输出掩码
	CHAM_64_X[0][1] = CHAM_64_v[1];  //第1轮的输入掩码
	CHAM_64_X[1][1] = (ROTATE_RIGHT(CHAM_64_w[1],ROL_b,16) ^ CHAM_64_v[2]) & Bit_Align;
	CHAM_64_X[2][1] = (ROTATE_RIGHT(CHAM_64_w[2],ROL_a,16) ^ CHAM_64_v[3]) & Bit_Align;
	CHAM_64_X[3][1] = (ROTATE_RIGHT(CHAM_64_w[3],ROL_b,16) ^ CHAM_64_v[4]) & Bit_Align;

	CHAM_64_X[0][2] = CHAM_64_v[2];  //第2轮的输入掩码
	CHAM_64_X[1][2] = CHAM_64_X[2][1];
	CHAM_64_X[2][2] = CHAM_64_X[3][1];
	CHAM_64_X[3][2] = ROTATE_LEFT(CHAM_64_u[1],ROL_a,16)  & Bit_Align;

	CHAM_64_X[0][3] = CHAM_64_v[3];  //第3轮的输入掩码
	CHAM_64_X[1][3] = CHAM_64_X[2][2];
	CHAM_64_X[2][3] = CHAM_64_X[3][2];
	CHAM_64_X[3][3] = ROTATE_LEFT(CHAM_64_u[2],ROL_b,16)  & Bit_Align;

	CHAM_64_X[0][4] = CHAM_64_v[4];  //第4轮的输入掩码
	CHAM_64_X[1][4] = CHAM_64_X[2][3];
	CHAM_64_X[2][4] = CHAM_64_X[3][3];
	CHAM_64_X[3][4] = ROTATE_LEFT(CHAM_64_u[3],ROL_a,16)  & Bit_Align;

	CHAM_64_X[0][5] = Masks_out[0];
	CHAM_64_X[1][5] = Masks_out[1];
	CHAM_64_X[2][5] = Masks_out[2];
	CHAM_64_X[3][5] = Masks_out[3];

	return best;
}
#endif

	return best;
}


u32 CHAM_round_r_odd(u16 search_round, u16 cur_round,u16 *Mask_r)
{
	u32 best=0;
	u16 Input_u=0, Input_w=0;
	u16 X0_sub_vector[2]={0};
	u16 u_block[2] = {0};
	u16 w_block[2] = {0};
	u16 Masks_out[4] = {0};  //第r轮的输入掩码
	u16 X0_Cw_min[2]={0};
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	int	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0;
	u64 j0=0,j1=0;
	u16 e_Mxor = 0;
	u16 ROL_a =1, ROL_b = 8;  //当搜索过程中间轮为 奇数 轮，默认旋转参数为1,8

	if(search_round <= cur_round)
	{
		best = CHAM_round_N_odd(search_round, Mask_r);
		return best;
	}

	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}

	if(((search_round + cur_round) &0x01 ) == 0)   //Matsui判断条件，为奇数轮开始的最优路劲
	{
		w_cmp = Bn_w - p_sumof_r - n_P_bestofR_w[search_round - cur_round];
	}
	else //	if(((search_round + cur_round)  &0x01 ) != 0)  //Matsui判断条件，为 偶数 轮开始的最优路劲
	{
		w_cmp = Bn_w - p_sumof_r - CHAM_Pw_even_cor[search_round - cur_round];
	}

	X0_sub_vector[0] = Mask_r[0] & 0xFF; //低8位
	X0_sub_vector[1] = (Mask_r[0] >> 8) & 0xFF;  //高8位
	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	if(cLAT_wtcor_min[X0_sub_vector[0]][0] <= cLAT_wtcor_min[X0_sub_vector[0]][1] )
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[0]; 	//bound wt
/*
	if(cLAT_wtcor_min[X0_sub_vector[1]][0] <= cLAT_wtcor_min[X0_sub_vector[1]][1] )
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][1];// 高位的可能最小相关性重量
	}
*/
	X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量,最高位的链接状态为0
	wt_cor_bound += X0_Cw_min[1]; 	//bound wt

	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

			//由MSB到LSB的方向组合U和W
			for(i0 = cLAT_wtcor_min[X0_sub_vector[1]][0]; i0 < 8; i0++)
			{
				if(i0 + X0_Cw_min[0] > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
			for(j0=0; j0 < cLAT_WU_numb[X0_sub_vector[1]][0][i0]; j0++)
			{
				w_block[1] = cLAT_W[X0_sub_vector[1]][0][i0][j0];
				u_block[1] = cLAT_U[X0_sub_vector[1]][0][i0][j0];
				e_Mxor = cLAT_UVW_bro[u_block[1]][X0_sub_vector[1]][w_block[1]][0];

			for(i1 = cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor]; i1 <= 8; i1++)
			{
				if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
				//可以再考虑加入R-r轮的概率重量的下界的剪枝条件

			for(j1=0; j1 < cLAT_WU_numb[X0_sub_vector[0]][e_Mxor][i1]; j1++)
			{
				w_block[0] = cLAT_W[X0_sub_vector[0]][e_Mxor][i1][j1];
				u_block[0] = cLAT_U[X0_sub_vector[0]][e_Mxor][i1][j1];

				Input_w = (w_block[1] << 8) | w_block[0];  //模加输入右侧掩码
				Input_u = (u_block[1] << 8) | u_block[0];  //模加输入右侧掩码

				//ROTATE_LEFT搞错了，MASK0的输入要ROTATE_RIGHT
				Masks_out[0] = (ROTATE_RIGHT(Input_w,ROL_a,16) ^ Mask_r[1]) & Bit_Align;
				Masks_out[1] = Mask_r[2];
				Masks_out[2] = Mask_r[3];
				Masks_out[3] = ROTATE_LEFT(Input_u,ROL_b,16)& Bit_Align;

				P_w[cur_round] = i0 + i1;  //当前轮的线性相关性重量

				//跳转 下一轮
				best = CHAM_round_r_even(search_round, cur_round+1, Masks_out);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			CHAM_64_X[0][cur_round+1] = Masks_out[0];
			CHAM_64_X[1][cur_round+1] = Masks_out[1];
			CHAM_64_X[2][cur_round+1] = Masks_out[2];
			CHAM_64_X[3][cur_round+1] = Masks_out[3];
			return 1;
		}
#endif
			}}}}
	return best;
}



u32 CHAM_round_r_even(u16 search_round, u16 cur_round,u16 *Mask_r)
{
	u32 best=0;
	u16 Input_u=0, Input_w=0;
	u16 X0_sub_vector[2]={0};
	u16 u_block[2] = {0};
	u16 w_block[2] = {0};
	u16 Masks_out[4] = {0};  //第r轮的输入掩码
	u16 X0_Cw_min[2]={0};
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	int	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0;
	u64 j0=0,j1=0;
	u16 e_Mxor = 0;
	u16 ROL_a =8, ROL_b = 1;  //当搜索过程中间轮为 奇数 轮，默认旋转参数为8,1


	if(search_round <= cur_round)
	{
		best = CHAM_round_N_even(search_round, Mask_r);
		return best;
	}

	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	if(((search_round + cur_round) &0x01) == 0)   //Matsui判断条件，为奇数轮开始的最优路劲
	{
		w_cmp = Bn_w - p_sumof_r - n_P_bestofR_w[search_round - cur_round];
	}
	else //	if(((search_round + cur_round) &0x01) != 0)  //Matsui判断条件，为 偶数 轮开始的最优路劲
	{
		w_cmp = Bn_w - p_sumof_r - CHAM_Pw_even_cor[search_round - cur_round];
	}

	X0_sub_vector[0] = Mask_r[0] & 0xFF; //低8位
	X0_sub_vector[1] = (Mask_r[0] >> 8) & 0xFF;  //高8位
	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	if(cLAT_wtcor_min[X0_sub_vector[0]][0] <= cLAT_wtcor_min[X0_sub_vector[0]][1] )
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[0]; 	//bound wt
	/*
	if(cLAT_wtcor_min[X0_sub_vector[1]][0] <= cLAT_wtcor_min[X0_sub_vector[1]][1] )
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][1];// 高位的可能最小相关性重量
	}
	*/
	X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量,最高位的链接状态为0
	wt_cor_bound += X0_Cw_min[1]; 	//bound wt

	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

			//由MSB到LSB的方向组合U和W
			for(i0 = cLAT_wtcor_min[X0_sub_vector[1]][0]; i0 < 8; i0++)
			{
				if(i0 + X0_Cw_min[0] > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
			for(j0=0; j0 < cLAT_WU_numb[X0_sub_vector[1]][0][i0]; j0++)
			{
				w_block[1] = cLAT_W[X0_sub_vector[1]][0][i0][j0];
				u_block[1] = cLAT_U[X0_sub_vector[1]][0][i0][j0];
				e_Mxor = cLAT_UVW_bro[u_block[1]][X0_sub_vector[1]][w_block[1]][0];

			for(i1 = cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor]; i1 <= 8; i1++)
			{
				if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j1=0; j1 < cLAT_WU_numb[X0_sub_vector[0]][e_Mxor][i1]; j1++)
			{
				w_block[0] = cLAT_W[X0_sub_vector[0]][e_Mxor][i1][j1];
				u_block[0] = cLAT_U[X0_sub_vector[0]][e_Mxor][i1][j1];

				Input_w = (w_block[1] << 8) | w_block[0];  //模加输入右侧掩码
				Input_u = (u_block[1] << 8) | u_block[0];  //模加输入右侧掩码

				//ROTATE_LEFT搞错了，MASK0的输入要ROTATE_RIGHT
				Masks_out[0] = (ROTATE_RIGHT(Input_w,ROL_a,16) ^ Mask_r[1]) & Bit_Align;
				Masks_out[1] = Mask_r[2];
				Masks_out[2] = Mask_r[3];
				Masks_out[3] = ROTATE_LEFT(Input_u,ROL_b,16)& Bit_Align;

				P_w[cur_round] = i0 + i1;  //当前轮的线性相关性重量

				//跳转 下一轮
				best = CHAM_round_r_odd(search_round, cur_round+1, Masks_out);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1)
		{
			CHAM_64_X[0][cur_round+1] = Masks_out[0];
			CHAM_64_X[1][cur_round+1] = Masks_out[1];
			CHAM_64_X[2][cur_round+1] = Masks_out[2];
			CHAM_64_X[3][cur_round+1] = Masks_out[3];
			return 1;
		}
#endif
			}}}}
	return best;
}



u32 CHAM_round_N_odd(u16 search_round,u16 *Mask_r)
{
	u32 best=0;
	u16 Input_u=0, Input_w=0;
	u16 X0_sub_vector[2]={0};
	u16 u_block[2] = {0};
	u16 w_block[2] = {0};
	u16 X0_Cw_min[2]={0};
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	int	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0;
	u64 j0=0,j1=0;
	u16 e_Mxor = 0;


	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = Bn_w - p_sumof_r;

	X0_sub_vector[0] = Mask_r[0] & 0xFF; //低8位
	X0_sub_vector[1] = (Mask_r[0] >> 8) & 0xFF;  //高8位
	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	if(cLAT_wtcor_min[X0_sub_vector[0]][0] <= cLAT_wtcor_min[X0_sub_vector[0]][1] )
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[0]; 	//bound wt
	/*
	if(cLAT_wtcor_min[X0_sub_vector[1]][0] <= cLAT_wtcor_min[X0_sub_vector[1]][1] )
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][1];// 高位的可能最小相关性重量
	}
	*/
	X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量,最高位的链接状态为0
	wt_cor_bound += X0_Cw_min[1]; 	//bound wt

	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

			//由MSB到LSB的方向组合U和W
			for(i0 = cLAT_wtcor_min[X0_sub_vector[1]][0]; i0 < 8; i0++)
			{
				if(i0 + X0_Cw_min[0] > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
			for(j0=0; j0 < cLAT_WU_numb[X0_sub_vector[1]][0][i0]; j0++)
			{
				w_block[1] = cLAT_W[X0_sub_vector[1]][0][i0][j0];
				u_block[1] = cLAT_U[X0_sub_vector[1]][0][i0][j0];
				e_Mxor = cLAT_UVW_bro[u_block[1]][X0_sub_vector[1]][w_block[1]][0];

			for(i1 = cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor]; i1 <= 8; i1++)
			{
				if(i0 + i1  == w_cmp ){  //找到最优路径
			for(j1=0; j1 < cLAT_WU_numb[X0_sub_vector[0]][e_Mxor][i1]; j1++)
			{
				w_block[0] = cLAT_W[X0_sub_vector[0]][e_Mxor][i1][j1];
				u_block[0] = cLAT_U[X0_sub_vector[0]][e_Mxor][i1][j1];

				Input_w = (w_block[1] << 8) | w_block[0];  //模加输入右侧掩码
				Input_u = (u_block[1] << 8) | u_block[0];  //模加输入右侧掩码

				CHAM_64_X[0][search_round+1] = (ROTATE_RIGHT(Input_w,1,16) ^ Mask_r[1]) & Bit_Align;
				CHAM_64_X[1][search_round+1] = Mask_r[2];
				CHAM_64_X[2][search_round+1] = Mask_r[3];
				CHAM_64_X[3][search_round+1] = ROTATE_LEFT(Input_u,8,16)& Bit_Align;

				P_w[search_round] = i0 + i1;  //当前轮的线性相关性重量

				best = 1;

#if(CHAM_even_round == 0) //当搜索开始是从 奇数 轮开始的话，搜索结果记录到n_P_bestofR_w
				{
					n_P_bestofR_w[search_round] = Bn_w;
				}
#else  //当搜索开始是从 偶数 轮开始的话，搜索线性结果记录到CHAM_Pw_even_cor
				{
					CHAM_Pw_even_cor[search_round] = Bn_w;
				}
#endif


#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			return 1;
		}
#endif
			}}}} }
	return best;
}


u32 CHAM_round_N_even(u16 search_round,u16 *Mask_r)
{
	u32 best=0;
	u16 Input_u=0, Input_w=0;
	u16 X0_sub_vector[2]={0};
	u16 u_block[2] = {0};
	u16 w_block[2] = {0};
	u16 X0_Cw_min[2]={0};
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	int	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0;
	u64 j0=0,j1=0;
	u16 e_Mxor = 0;


	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = Bn_w - p_sumof_r;

	X0_sub_vector[0] = Mask_r[0] & 0xFF; //低8位
	X0_sub_vector[1] = (Mask_r[0] >> 8) & 0xFF;  //高8位
	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	if(cLAT_wtcor_min[X0_sub_vector[0]][0] <= cLAT_wtcor_min[X0_sub_vector[0]][1] )
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[0]; 	//bound wt
/*
	if(cLAT_wtcor_min[X0_sub_vector[1]][0] <= cLAT_wtcor_min[X0_sub_vector[1]][1] )
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][1];// 高位的可能最小相关性重量
	}
*/
	X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量,最高位的链接状态为0
	wt_cor_bound += X0_Cw_min[1]; 	//bound wt

	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

			//由MSB到LSB的方向组合U和W
			for(i0 = cLAT_wtcor_min[X0_sub_vector[1]][0]; i0 < 8; i0++)
			{
				if(i0 + X0_Cw_min[0] > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
			for(j0=0; j0 < cLAT_WU_numb[X0_sub_vector[1]][0][i0]; j0++)
			{
				w_block[1] = cLAT_W[X0_sub_vector[1]][0][i0][j0];
				u_block[1] = cLAT_U[X0_sub_vector[1]][0][i0][j0];
				e_Mxor = cLAT_UVW_bro[u_block[1]][X0_sub_vector[1]][w_block[1]][0];

			for(i1 = cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor]; i1 <= 8; i1++)
			{
				if(i0 + i1  == w_cmp ){  //找到最优路径
			for(j1=0; j1 < cLAT_WU_numb[X0_sub_vector[0]][e_Mxor][i1]; j1++)
			{
				w_block[0] = cLAT_W[X0_sub_vector[0]][e_Mxor][i1][j1];
				u_block[0] = cLAT_U[X0_sub_vector[0]][e_Mxor][i1][j1];

				Input_w = (w_block[1] << 8) | w_block[0];  //模加输入右侧掩码
				Input_u = (u_block[1] << 8) | u_block[0];  //模加输入右侧掩码

				CHAM_64_X[0][search_round+1] = (ROTATE_RIGHT(Input_w,8,16) ^ Mask_r[1]) & Bit_Align;
				CHAM_64_X[1][search_round+1] = Mask_r[2];
				CHAM_64_X[2][search_round+1] = Mask_r[3];
				CHAM_64_X[3][search_round+1] = ROTATE_LEFT(Input_u,1,16)& Bit_Align;

				P_w[search_round] = i0 + i1;  //当前轮的线性相关性重量

				best = 1;
#if(CHAM_even_round == 0) //当搜索开始是从 奇数 轮开始的话，搜索结果记录到n_P_bestofR_w
				{
					n_P_bestofR_w[search_round] = Bn_w;
				}
#else  //当搜索开始是从 偶数 轮开始的话，搜索线性结果记录到CHAM_Pw_even_cor
				{
					CHAM_Pw_even_cor[search_round] = Bn_w;
				}
#endif

#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			return 1;
		}
#endif
				}}}} }
	return best;
}



u16 CHAM64_linear_Hull_search_entry (u16 search_round)
{
	u32 best = 0;
	u16 i = 0;
	FILE* CHAM_64_linear_Bn;

	CHAM_64_linear_Bn = fopen ("../tmp/CHAM_64_linear_Bn_wt.xlsx", "a+"); //  "w+"); //
	if(sc_blocksize != 64)
	{
		printf("The block size of CHAM should be 64 bits. \n");
		return 0;
	}
	// For CHAM modular additon is 16 bits.
	blocksize_len = 16;
	Bit_Align = 0xFFFF;

	printf("Constructing CHAM-64 cLAT Tables... \n");
	//构造部分的线性相关性近似表cLAT
	ARX_cLAT_construct();
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct CHAM-64 cLAT: %.2f seconds.  \n", run_time);

	Bn_w = 0;
	if(search_round > 1)
	{
		for(i=1; i <= search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(CHAM_64_linear_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		Bn_w = n_P_bestofR_w[search_round -1] - 1;
	}


		//xx round cor CHAM64
	CHAM_64_IN_Mask[0] = 0x0000;
	CHAM_64_IN_Mask[1] = 0x0000;
	CHAM_64_IN_Mask[2] = 0x0000;
	CHAM_64_IN_Mask[3] = 0x4020;

	CHAM_64_OUT_Mask[0] = 0x0000;
	CHAM_64_OUT_Mask[1] = 0x0000;
	CHAM_64_OUT_Mask[2] = 0x0215;
	CHAM_64_OUT_Mask[3] = 0x0012;

	wt_max = 23;
	n_P_bestofR_w[search_round] = 23;

	Bn_w = n_P_bestofR_w[search_round];
	//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
	printf("wt_min(:%d)--->wt_max: %d \n", n_P_bestofR_w[search_round], wt_max);
	printf("-----------------------Search CHAM-64 Linear Hulls---------------------------\n");
	CHAM64_linear_Hull_round_r_odd( search_round, 1, CHAM_64_IN_Mask);
	printf("-----------------------Record CHAM-64 Linear Hulls---------------------\n");

	for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
	{
		prob = prob + (wt_nmu[i] * pow(2,-2*i));
		prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
		printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
	}
	printf("++++++++++++++++++\n ");
	printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
	//printf("input:0x%012x %012x ======>> output:0x%012x %012x \n",input_diff_L,input_diff_R,output_diff_L,output_diff_R);
	printf( "0x%04llx %04llx %04llx %04llx \n"
			"==================>>\n"
		    "0x%04llx %04llx %04llx %04llx \n",
			CHAM_64_IN_Mask[0],CHAM_64_IN_Mask[1],CHAM_64_IN_Mask[2],CHAM_64_IN_Mask[3],
			CHAM_64_OUT_Mask[0],CHAM_64_OUT_Mask[1],CHAM_64_OUT_Mask[2],CHAM_64_OUT_Mask[3]);

	printf(" wt_min: -%d ===>> wt_max: -%d \n",n_P_bestofR_w[search_round],wt_max);
	printf(" %d Rounds Linear Hull with total %d trails.\n",search_round,count);
	printf(" Correlation potential is: %.2Lf \n",prob_w);
	printf("++++++++++++++++++\n ");

	time_finish = clock();
	run_time = (double)(time_finish - time_ARX_cLAT) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours == %.2f days. \n", run_time,run_time/60.0,run_time/3600.0,run_time/86400.0 );
	printf("Auto-search CHAM-64 optimal linear trails END! \n");
	printf("|************************************************************************|\n");
	fclose(CHAM_64_linear_Bn);

	return best;
}



u32 CHAM64_linear_Hull_round_r_odd(u16 search_round, u16 cur_round,u16 *Mask_r)
{
	u32 best=0;
	u16 Input_u=0, Input_w=0;
	u16 X0_sub_vector[2]={0};
	u16 u_block[2] = {0};
	u16 w_block[2] = {0};
	u16 Masks_out[4] = {0};  //第r轮的输入掩码
	u16 X0_Cw_min[2]={0};
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0;
	u64 j0=0,j1=0;
	u16 e_Mxor = 0;


	X0_sub_vector[0] = Mask_r[0] & 0xFF; //低8位
	X0_sub_vector[1] = (Mask_r[0] >> 8) & 0xFF;  //高8位


	if(search_round <= cur_round)
	{
		best = CHAM64_linear_Hull_round_N_odd(search_round, Mask_r);
		return best;
	}

	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r - n_P_bestofR_w[search_round - cur_round];

	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	if(cLAT_wtcor_min[X0_sub_vector[0]][0] <= cLAT_wtcor_min[X0_sub_vector[0]][1] )
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[0]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[1]][0] <= cLAT_wtcor_min[X0_sub_vector[1]][1] )
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[1]; 	//bound wt
	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

			//由MSB到LSB的方向组合U和W
			for(i0 = cLAT_wtcor_min[X0_sub_vector[1]][0]; i0 < 8; i0++)
			{
				if(i0 + X0_Cw_min[0] > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
			for(j0=0; j0 < cLAT_WU_numb[X0_sub_vector[1]][0][i0]; j0++)
			{
				w_block[1] = cLAT_W[X0_sub_vector[1]][0][i0][j0];
				u_block[1] = cLAT_U[X0_sub_vector[1]][0][i0][j0];
				e_Mxor = cLAT_UVW_bro[u_block[1]][X0_sub_vector[1]][w_block[1]][0];

			for(i1 = cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor]; i1 <= 8; i1++)
			{
				if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j1=0; j1 < cLAT_WU_numb[X0_sub_vector[0]][e_Mxor][i1]; j1++)
			{
				w_block[0] = cLAT_W[X0_sub_vector[0]][e_Mxor][i1][j1];
				u_block[0] = cLAT_U[X0_sub_vector[0]][e_Mxor][i1][j1];

				Input_w = (w_block[1] << 8) | w_block[0];  //模加输入右侧掩码
				Input_u = (u_block[1] << 8) | u_block[0];  //模加输入右侧掩码

				Masks_out[0] = (ROTATE_RIGHT(Input_w,1,16) ^ Mask_r[1]) & Bit_Align;
				Masks_out[1] = Mask_r[2];
				Masks_out[2] = Mask_r[3];
				Masks_out[3] = ROTATE_LEFT(Input_u,8,16)& Bit_Align;

				P_w[cur_round] = i0 + i1;  //当前轮的线性相关性重量

				//跳转 下一轮
				best = CHAM64_linear_Hull_round_r_even(search_round, cur_round+1, Masks_out);

			}}}}
	return best;
}



u32 CHAM64_linear_Hull_round_r_even(u16 search_round, u16 cur_round,u16 *Mask_r)
{
	u32 best=0;
	u16 Input_u=0, Input_w=0;
	u16 X0_sub_vector[2]={0};
	u16 u_block[2] = {0};
	u16 w_block[2] = {0};
	u16 Masks_out[4] = {0};  //第r轮的输入掩码
	u16 X0_Cw_min[2]={0};
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0;
	u64 j0=0,j1=0;
	u16 e_Mxor = 0;


	X0_sub_vector[0] = Mask_r[0] & 0xFF; //低8位
	X0_sub_vector[1] = (Mask_r[0] >> 8) & 0xFF;  //高8位


	if(search_round <= cur_round)
	{
		best = CHAM64_linear_Hull_round_N_even(search_round, Mask_r);
		return best;
	}

	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r - n_P_bestofR_w[search_round - cur_round];

	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	if(cLAT_wtcor_min[X0_sub_vector[0]][0] <= cLAT_wtcor_min[X0_sub_vector[0]][1] )
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[0]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[1]][0] <= cLAT_wtcor_min[X0_sub_vector[1]][1] )
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[1]; 	//bound wt

	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

			//由MSB到LSB的方向组合U和W
			for(i0 = cLAT_wtcor_min[X0_sub_vector[1]][0]; i0 < 8; i0++)
			{
				if(i0 + X0_Cw_min[0] > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
			for(j0=0; j0 < cLAT_WU_numb[X0_sub_vector[1]][0][i0]; j0++)
			{
				w_block[1] = cLAT_W[X0_sub_vector[1]][0][i0][j0];
				u_block[1] = cLAT_U[X0_sub_vector[1]][0][i0][j0];
				e_Mxor = cLAT_UVW_bro[u_block[1]][X0_sub_vector[1]][w_block[1]][0];

			for(i1 = cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor]; i1 <= 8; i1++)
			{
				if(i0 + i1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j1=0; j1 < cLAT_WU_numb[X0_sub_vector[0]][e_Mxor][i1]; j1++)
			{
				w_block[0] = cLAT_W[X0_sub_vector[0]][e_Mxor][i1][j1];
				u_block[0] = cLAT_U[X0_sub_vector[0]][e_Mxor][i1][j1];

				Input_w = (w_block[1] << 8) | w_block[0];  //模加输入右侧掩码
				Input_u = (u_block[1] << 8) | u_block[0];  //模加输入右侧掩码

				Masks_out[0] = (ROTATE_RIGHT(Input_w,8,16) ^ Mask_r[1]) & Bit_Align;
				Masks_out[1] = Mask_r[2];
				Masks_out[2] = Mask_r[3];
				Masks_out[3] = ROTATE_LEFT(Input_u,1,16)& Bit_Align;

				P_w[cur_round] = i0 + i1;  //当前轮的线性相关性重量

				//跳转 下一轮
				best = CHAM64_linear_Hull_round_r_odd(search_round, cur_round+1, Masks_out);

			}}}}
	return best;
}



u32 CHAM64_linear_Hull_round_N_odd(u16 search_round,u16 *Mask_r)
{
	u32 best=0;
	u16 Input_u=0, Input_w=0;
	u16 X0_sub_vector[2]={0};
	u16 u_block[2] = {0};
	u16 w_block[2] = {0};
	u16 X0_Cw_min[2]={0};
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0;
	u64 j0=0,j1=0;
	u16 e_Mxor = 0;
	u16 j = 0, Not_eq=0;


	X0_sub_vector[0] = Mask_r[0] & 0xFF; //低8位
	X0_sub_vector[1] = (Mask_r[0] >> 8) & 0xFF;  //高8位

	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r;

	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	if(cLAT_wtcor_min[X0_sub_vector[0]][0] <= cLAT_wtcor_min[X0_sub_vector[0]][1] )
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[0]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[1]][0] <= cLAT_wtcor_min[X0_sub_vector[1]][1] )
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[1]; 	//bound wt

	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

			//由MSB到LSB的方向组合U和W
			for(i0 = cLAT_wtcor_min[X0_sub_vector[1]][0]; i0 < 8; i0++)
			{
				if(i0 + X0_Cw_min[0] > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
			for(j0=0; j0 < cLAT_WU_numb[X0_sub_vector[1]][0][i0]; j0++)
			{
				w_block[1] = cLAT_W[X0_sub_vector[1]][0][i0][j0];
				u_block[1] = cLAT_U[X0_sub_vector[1]][0][i0][j0];
				e_Mxor = cLAT_UVW_bro[u_block[1]][X0_sub_vector[1]][w_block[1]][0];

			for(i1 = cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor]; i1 <= 8; i1++)
			{
				if(i0 + i1  == w_cmp ){  //找到最优路径
			for(j1=0; j1 < cLAT_WU_numb[X0_sub_vector[0]][e_Mxor][i1]; j1++)
			{
				w_block[0] = cLAT_W[X0_sub_vector[0]][e_Mxor][i1][j1];
				u_block[0] = cLAT_U[X0_sub_vector[0]][e_Mxor][i1][j1];

				Input_w = (w_block[1] << 8) | w_block[0];  //模加输入右侧掩码
				Input_u = (u_block[1] << 8) | u_block[0];  //模加输入右侧掩码

				CHAM_64_X[0][search_round+1] = (ROTATE_RIGHT(Input_w,1,16) ^ Mask_r[1]) & Bit_Align;
				CHAM_64_X[1][search_round+1] = Mask_r[2];
				CHAM_64_X[2][search_round+1] = Mask_r[3];
				CHAM_64_X[3][search_round+1] = ROTATE_LEFT(Input_u,8,16)& Bit_Align;

				P_w[search_round] = i0 + i1;  //当前轮的线性相关性重量

				Not_eq = 0;
				for(j=0;j<4;j++)
				{
					if(CHAM_64_X[j][search_round +1] != CHAM_64_OUT_Mask[j] ) //u16 OUT_Y_Mask[8] = {0};
					{
						Not_eq = 1;
						break;
					}
				}

				if( Not_eq != 0)
				{ continue; }

				count++;
				Bn_w = p_sumof_r + P_w[search_round] ;
				printf("count: %d    weight: %d \n",count,Bn_w);
				wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;

			}}}} }
	return best;
}


u32 CHAM64_linear_Hull_round_N_even(u16 search_round,u16 *Mask_r)
{
	u32 best=0;
	u16 Input_u=0, Input_w=0;
	u16 X0_sub_vector[2]={0};
	u16 u_block[2] = {0};
	u16 w_block[2] = {0};
	u16 X0_Cw_min[2]={0};
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0;
	u64 j0=0,j1=0;
	u16 e_Mxor = 0;
	u16 j = 0, Not_eq=0;

	X0_sub_vector[0] = Mask_r[0] & 0xFF; //低8位
	X0_sub_vector[1] = (Mask_r[0] >> 8) & 0xFF;  //高8位

	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r;

	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	if(cLAT_wtcor_min[X0_sub_vector[0]][0] <= cLAT_wtcor_min[X0_sub_vector[0]][1] )
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[0]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[1]][0] <= cLAT_wtcor_min[X0_sub_vector[1]][1] )
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[1]; 	//bound wt

	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

			//由MSB到LSB的方向组合U和W
			for(i0 = cLAT_wtcor_min[X0_sub_vector[1]][0]; i0 < 8; i0++)
			{
				if(i0 + X0_Cw_min[0] > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
			for(j0=0; j0 < cLAT_WU_numb[X0_sub_vector[1]][0][i0]; j0++)
			{
				w_block[1] = cLAT_W[X0_sub_vector[1]][0][i0][j0];
				u_block[1] = cLAT_U[X0_sub_vector[1]][0][i0][j0];
				e_Mxor = cLAT_UVW_bro[u_block[1]][X0_sub_vector[1]][w_block[1]][0];

			for(i1 = cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor]; i1 <= 8; i1++)
			{
				if(i0 + i1  == w_cmp )
				{  //找到最优路径
			for(j1=0; j1 < cLAT_WU_numb[X0_sub_vector[0]][e_Mxor][i1]; j1++)
			{
				w_block[0] = cLAT_W[X0_sub_vector[0]][e_Mxor][i1][j1];
				u_block[0] = cLAT_U[X0_sub_vector[0]][e_Mxor][i1][j1];

				Input_w = (w_block[1] << 8) | w_block[0];  //模加输入右侧掩码
				Input_u = (u_block[1] << 8) | u_block[0];  //模加输入右侧掩码

				CHAM_64_X[0][search_round+1] = (ROTATE_RIGHT(Input_w,8,16) ^ Mask_r[1]) & Bit_Align;
				CHAM_64_X[1][search_round+1] = Mask_r[2];
				CHAM_64_X[2][search_round+1] = Mask_r[3];
				CHAM_64_X[3][search_round+1] = ROTATE_LEFT(Input_u,1,16)& Bit_Align;

				P_w[search_round] = i0 + i1;  //当前轮的线性相关性重量

				Not_eq = 0;
				for(j=0;j<4;j++)
				{
					if(CHAM_64_X[j][search_round +1] != CHAM_64_OUT_Mask[j] ) //u16 OUT_Y_Mask[8] = {0};
					{
						Not_eq = 1;
						break;
					}
				}

				if( Not_eq != 0)
				{ continue; }

				count++;
				Bn_w = p_sumof_r + P_w[search_round] ;
				printf("count: %d    weight: %d \n",count,Bn_w);
				wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;

				}}}} }
	return best;
}



/**
 * @搜索CHAM的最优线性特征的代码
 * @ MOde_2
 */
u32 CHAM_128_Linear_trail_search_entry(u16 search_round)
{
	u32 best = 0;
	u16 i = 0;
	u16 Bn_expected = 0;
	FILE* CHAM_128_linear_Bn;
	FILE* CHAM_128_linear_Bn_even;



	if(sc_blocksize != 128)
	{
		printf("The block size of CHAM should be 128 bits. \n");
		return 0;
	}

	CHAM_128_linear_Bn = fopen ("../tmp/CHAM_128_linear_Bn_wt.xlsx", "a+"); //  "w+"); //
	CHAM_128_linear_Bn_even = fopen ("../tmp/CHAM_128_linear_Bn_wt_even.xlsx", "a+"); //  "w+"); //

	Bn_w = 0;
	if(search_round > 1)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(CHAM_128_linear_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			fscanf(CHAM_128_linear_Bn_even,"%d",&CHAM_Pw_even_cor[i]);  //read.
		}
#if(CHAM_even_round == 0) //结束条件判断是搜索的奇数还是偶数轮开始的路径,=0为奇数轮开始的正常搜索
		{
			printf("===============Search odd-round============= \n");
			Bn_w = n_P_bestofR_w[search_round -1] - 1;
		}
#else
		{
			printf("===============Search even-round============= \n");
			Bn_w = CHAM_Pw_even_cor[search_round -1] - 1;
		}
#endif
	}


	// For CHAM-128 modular additon is 32 bits.
	blocksize_len = 32;
	Bit_Align = 0xFFFFFFFF;
	printf("Constructing CHAM-128 cLAT Tables... \n");
	//构造部分的线性相关性近似表cLAT
	ARX_cLAT_construct();
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct CHAM-128 cLAT: %.2f seconds.  \n", run_time);

	u16 F4_THRD = 0;
//	printf("===============First 4 round total cor_wt < %d============= \n",F4_THRD );

//	Bn_w = 25;  //直接设定开始的概率重量,快速达到期望的概率重量
		do
		{
			Bn_w = Bn_w + 1;
//			printf("Searching CHAM-128 Bn_w: %d \n", Bn_w);

			F4_THRD = 4;   //Bn_w - n_P_bestofR_w[search_round -4];
			printf("Searching CHAM-128 Bn_w: %d  F4_cor_wt <= %d \n",
					Bn_w, F4_THRD);


			//CHAM_even = 0;
			// Search Entry.
			//best = CHAM_128_R1_tuples(search_round); //效率高
			best = CHAM_128_R1_R4_wt(search_round,F4_THRD); //提前组合前4轮的相关性重量

			time_Round = clock();
			run_time =  (time_Round - time_ARX_cLAT) / CLOCKS_PER_SEC;
			printf("Time: %.2f seconds.  \n", run_time);

#if(CHAM_even_round == 0) //结束条件判断是搜索的奇数还是偶数轮开始的路径
			{
				Bn_expected =  n_P_bestofR_w[search_round];
			}
#else
			{
				Bn_expected =  CHAM_Pw_even_cor[search_round];
			}
#endif
		}while(Bn_w != Bn_expected);   //end conditions.
		print_CHAM_128_linear_resoult(search_round);  //打印CHASKEY的输入输出掩码

		time_finish = clock();
		run_time = (double)(time_finish - time_ARX_cLAT) / CLOCKS_PER_SEC;
		printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours == %.2f days. \n", run_time,run_time/60.0,run_time/3600.0,run_time/86400.0 );
		printf("Auto-search CHAM-128 optimal linear trails END! \n");
		printf("|************************************************************************|\n");
		fclose(CHAM_128_linear_Bn);
		fclose(CHAM_128_linear_Bn_even);

	return best;
}


u32 CHAM_128_R1_R4_wt(u16 search_round, u16 F4_thrd)
{
	u32 best = 0;
	u16 f4=0;


	for(f4=0; f4 <= F4_thrd; f4++)
	{
#if (CHAM_even_round == 0 ) //当前搜索参数（1，8）开始的奇数轮的最优路径
		if( (f4 + CHAM_Pw_even_cor[search_round - 4]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}
#else  //CHAM_even_round=1, 当前搜索参数（8,1）开始的偶数轮的最优路径
	if( (f4 + n_P_bestofR_w[search_round - 4]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
	{
		return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
	}
#endif

		for(CHAM_first_four_wt[0]=0; CHAM_first_four_wt[0] <= f4; CHAM_first_four_wt[0]++) //15
		{
			for(CHAM_first_four_wt[1]=0; CHAM_first_four_wt[1] <= f4; CHAM_first_four_wt[1]++) //15
			{
				for(CHAM_first_four_wt[2]=0; CHAM_first_four_wt[2] <= f4; CHAM_first_four_wt[2]++) //15
				{
					for(CHAM_first_four_wt[3]=0; CHAM_first_four_wt[3] <= f4; CHAM_first_four_wt[3]++)//15
					{
						if((CHAM_first_four_wt[0] + CHAM_first_four_wt[1] +
								CHAM_first_four_wt[2] + CHAM_first_four_wt[3]) == f4)
						{
							best = CHAM_128_R1_tuples(search_round);
							if(best== 1 )
							{
								return 1;
							}
}}}}}}
/*
	CHAM_first_four_wt[0]=0;
	CHAM_first_four_wt[1]=1;
	CHAM_first_four_wt[2]=2;
	CHAM_first_four_wt[3]=1;
	best = CHAM_128_R1_tuples(search_round);
	if(best== 1 )
	{
		return 1;
	}
*/
	return best;
}



u32 CHAM_128_R1_tuples(u16 search_round)
{
	u32 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 cor_wt = 0;

	u64 M0 = 0;
	u64 N0 = 31; // blocksize_len-1
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;





	///////////////////round 1 entry///////////////////// //前4轮的线性相关性重量限定不能太小
	cor_wt = CHAM_first_four_wt[0];
	//	for(cor_wt = 0; cor_wt < 2; cor_wt++)  //0-->n-1 //blocksize_len-1 //CHAM_first_four_wt[0]
	{
		// thr_d : 首轮的线性相关性重量递增
#if (CHAM_even_round == 0 ) //当前搜索参数（1，8）开始的奇数轮的最优路径
		if( (cor_wt + CHAM_Pw_even_cor[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}
#else  //CHAM_even_round=1, 当前搜索参数（8,1）开始的偶数轮的最优路径
	if( (cor_wt + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
	{
		return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
	}
#endif


		M0 = cor_wt;  //
		P_w[1] = M0; //相关性重量的记录数组
		p_sumof_r_P_w[1] = P_w[1];

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			CHAM_128_u[1] = Input_u;
			CHAM_128_v[1] = Input_v;
			CHAM_128_w[1] = Input_w;

			//直接跳转到第2轮
			best = CHAM_128_R2_tuples(search_round);

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;

			CHAM_128_u[1] = Input_u;
			CHAM_128_v[1] = Input_v;
			CHAM_128_w[1] = Input_w;

			//直接跳转到第2轮
			best = CHAM_128_R2_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			//直接跳转到第1轮各个部分的内部构造
			best = CHAM_128_R1_tuples_ADD_Last(search_round,P_w[1],C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHASKEY_Linear;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHASKEY_Linear;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHASKEY_Linear;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHASKEY_Linear;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHASKEY_Linear;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
	CHASKEY_Linear:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}
///////////////输出其它的分布模式/////////////////
				//直接跳转到第1轮各个部分的内部构造
				best = CHAM_128_R1_tuples_ADD_Last(search_round,P_w[1],C0);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}

	return best;
}


u16 CHAM_128_R1_tuples_ADD_Last(u16 search_round, u16 Cw_1, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

		//跳转到高比特分析
		best = CHAM_128_R1_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_1, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = CHAM_128_R1_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_1, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = CHAM_128_R1_tuples_ADD_Middle(search_round,
					Input_u, Input_v, Input_w,
					Cw_1, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}

u16 CHAM_128_R1_tuples_ADD_Middle(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= Cw_1 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = CHAM_128_R1_tuples_ADD_MSB(search_round,
				tmp_U,tmp_V,tmp_W,
				Cw_1, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

				if(current_index <= blocksize_len -2)
				{
				//跳转到高比特分析
				best = CHAM_128_R1_tuples_ADD_Middle(search_round,
						tmp_U, tmp_V, tmp_W,
						Cw_1, Corr_tmp_inc, posi,
						current_index + 1, Fwt);
				}
				else
				{
					best = CHAM_128_R1_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_1, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//跳转到高比特分析
				best = CHAM_128_R1_tuples_ADD_Middle(search_round,
						Input_u, Input_v, Input_w,
						Cw_1, Corr_tmp_inc, posi,
						current_index +1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_128_R1_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_1, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_128_R1_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_1, Corr_tmp_inc +1, posi,
							current_index +1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 CHAM_128_R1_tuples_ADD_MSB(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


		if(Corr_tmp_inc > Cw_1)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
		{
			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				CHAM_128_u[1] = tmp_U;
				CHAM_128_v[1] = tmp_V;
				CHAM_128_w[1] = tmp_W;
				//直接跳转到第2轮
				best = CHAM_128_R2_tuples(search_round);
			}
			else
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				CHAM_128_u[1] = Input_u;
				CHAM_128_v[1] = Input_v;
				CHAM_128_w[1] = Input_w;
				//直接跳转到第2轮
				best = CHAM_128_R2_tuples(search_round);
			}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		}
		else  // Corr_tmp_inc == part_wt 搜索的当前wt与期望的相关性重量相等
		{
			if( (posi[Cw_1]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0; //!= >
			{
				if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
				{
					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = CHAM_128_R1_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_1, Corr_tmp_inc,posi,
							current_index +1, Fwt);
				}
				else
				{
					// UVW_i 为7
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
					Input_w = tmp_W | (bit_i << current_index); //该位置置1

					CHAM_128_u[1] = Input_u;
					CHAM_128_v[1] = Input_v;
					CHAM_128_w[1] = Input_w;
					//直接跳转到第2轮
					best = CHAM_128_R2_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
				}
			}
			else  //(posi[part_wt]-1) == current_index
			{

			if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW[i+1]位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_128_u[1] = Input_u;
					CHAM_128_v[1] = Input_v;
					CHAM_128_w[1] = Input_w;
					//直接跳转到第2轮
					best = CHAM_128_R2_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
				}
			}
			else
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW的最高位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_128_u[1] = Input_u;
					CHAM_128_v[1] = Input_v;
					CHAM_128_w[1] = Input_w;
					//直接跳转到第2轮
					best = CHAM_128_R2_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}}
			}}
		return best;
}


u32 CHAM_128_R2_tuples(u16 search_round)
{
	u32 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 cor_wt = 0;

	u64 M0 = 0;
	u64 N0 = 31;  //blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;


	///////////////////round 1 entry/////////////////////
	cor_wt = CHAM_first_four_wt[1];
//	for(cor_wt = 0; cor_wt < 2; cor_wt++)  //0-->n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
#if (CHAM_even_round == 0 ) //当前搜索参数（1，8）开始的奇数轮的最优路径
		if( (P_w[1]+cor_wt + n_P_bestofR_w[search_round - 2]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}
#else  //CHAM_even_round=1, 当前搜索参数（8,1）开始的偶数轮的最优路径
		if( (P_w[1]+cor_wt + CHAM_Pw_even_cor[search_round - 2]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}
#endif


		M0 = cor_wt;  //
		P_w[2] = M0; //相关性重量的记录数组
		p_sumof_r_P_w[2] = P_w[1] + P_w[2];

		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			CHAM_128_u[2] = Input_u;
			CHAM_128_v[2] = Input_v;
			CHAM_128_w[2] = Input_w;

			//直接跳转到第3轮
			best = CHAM_128_R3_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;

			CHAM_128_u[2] = Input_u;
			CHAM_128_v[2] = Input_v;
			CHAM_128_w[2] = Input_w;

			//直接跳转到第3轮
			best = CHAM_128_R3_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			//直接跳转到内部构造
			best = CHAM_128_R2_tuples_ADD_Last(search_round,P_w[2],C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHASKEY_Linear;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHASKEY_Linear;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHASKEY_Linear;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHASKEY_Linear;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHASKEY_Linear;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
	CHASKEY_Linear:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}
///////////////输出其它的分布模式/////////////////
				//直接跳转到内部构造
				best = CHAM_128_R2_tuples_ADD_Last(search_round,
						P_w[2],C0);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}

	return best;
}


u16 CHAM_128_R2_tuples_ADD_Last(u16 search_round,u16 Cw_2, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

		//跳转到高比特分析
		best = CHAM_128_R2_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_2, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = CHAM_128_R2_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_2, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = CHAM_128_R2_tuples_ADD_Middle(search_round,
					Input_u, Input_v, Input_w,
					Cw_2, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}

u16 CHAM_128_R2_tuples_ADD_Middle(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_2, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= Cw_2 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = CHAM_128_R2_tuples_ADD_MSB(search_round,
				tmp_U,tmp_V,tmp_W,
				Cw_2, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

				if(current_index <= blocksize_len -2)
				{
				//跳转到高比特分析
				best = CHAM_128_R2_tuples_ADD_Middle(search_round,
						tmp_U, tmp_V, tmp_W,
						Cw_2, Corr_tmp_inc, posi,
						current_index + 1, Fwt);
				}
				else
				{
					best = CHAM_128_R2_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_2, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//跳转到高比特分析
				best = CHAM_128_R2_tuples_ADD_Middle(search_round,
						Input_u, Input_v, Input_w,
						Cw_2, Corr_tmp_inc, posi,
						current_index +1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_128_R2_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_2, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_128_R2_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_2, Corr_tmp_inc +1, posi,
							current_index +1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 CHAM_128_R2_tuples_ADD_MSB(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_2, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;

		if(Corr_tmp_inc > Cw_2)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
		{
			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				CHAM_128_u[2] = tmp_U;
				CHAM_128_v[2] = tmp_V;
				CHAM_128_w[2] = tmp_W;
				//直接跳转到第3轮
				best = CHAM_128_R3_tuples(search_round);
			}
			else
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				CHAM_128_u[2] = Input_u;
				CHAM_128_v[2] = Input_v;
				CHAM_128_w[2] = Input_w;
				//直接跳转到第3轮
				best = CHAM_128_R3_tuples(search_round);
			}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  // Corr_tmp_inc == part_wt 搜索的当前wt与期望的相关性重量相等
		{
			if( (posi[Cw_2]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0; //!= >
			{
				if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
				{
					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = CHAM_128_R2_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_2, Corr_tmp_inc,posi,
							current_index +1, Fwt);
				}
				else
				{
					// UVW_i 为7
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
					Input_w = tmp_W | (bit_i << current_index); //该位置置1

					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = CHAM_128_R2_tuples_ADD_MSB(search_round,
							Input_u, Input_v, Input_w,
							Cw_2, Corr_tmp_inc, posi,
							current_index +1, Fwt);
	#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
	#endif
		}
			}
			else  //(posi[part_wt]-1) == current_index
			{

			if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW[i+1]位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_128_u[2] = Input_u;
					CHAM_128_v[2] = Input_v;
					CHAM_128_w[2] = Input_w;
					//直接跳转到第3轮
					best = CHAM_128_R3_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
				}
			}
			else
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW的最高位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_128_u[2] = Input_u;
					CHAM_128_v[2] = Input_v;
					CHAM_128_w[2] = Input_w;
					//直接跳转到第3轮
					best = CHAM_128_R3_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}}
			}}
		return best;
}

u32 CHAM_128_R3_tuples(u16 search_round)
{
	u32 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 cor_wt = 0;

	u64 M0 = 0;
	u64 N0 = 31; //blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;


	///////////////////round 1 entry/////////////////////
	cor_wt = CHAM_first_four_wt[2];
//	for(cor_wt = 0; cor_wt < 2; cor_wt++)  //0-->n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
#if (CHAM_even_round == 0 ) //当前搜索参数（1，8）开始的奇数轮的最优路径
		if( (P_w[1]+P_w[2]+cor_wt + CHAM_Pw_even_cor[search_round - 3]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}
#else  //CHAM_even_round=1, 当前搜索参数（8,1）开始的偶数轮的最优路径
		if( (P_w[1]+P_w[2]+cor_wt + n_P_bestofR_w[search_round - 3]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}
#endif


		M0 = cor_wt;  //
		P_w[3] = M0; //相关性重量的记录数组
		p_sumof_r_P_w[3] = P_w[1] + P_w[2] + P_w[3];
		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			CHAM_128_u[3] = Input_u;
			CHAM_128_v[3] = Input_v;
			CHAM_128_w[3] = Input_w;
			//直接跳转到第4轮
			best = CHAM_128_R4_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;

			CHAM_128_u[3] = Input_u;
			CHAM_128_v[3] = Input_v;
			CHAM_128_w[3] = Input_w;
			//直接跳转到第4轮
			best = CHAM_128_R4_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			//直接跳转到内部构造
			best = CHAM_128_R3_tuples_ADD_Last(search_round,P_w[3],C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHASKEY_Linear;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHASKEY_Linear;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHASKEY_Linear;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHASKEY_Linear;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHASKEY_Linear;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
	CHASKEY_Linear:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}
///////////////输出其它的分布模式/////////////////
				//直接跳转到内部构造
				best = CHAM_128_R3_tuples_ADD_Last(search_round,P_w[3],C0);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}

	return best;
}


u16 CHAM_128_R3_tuples_ADD_Last(u16 search_round,u16 Cw_3, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

		//跳转到高比特分析
		best = CHAM_128_R3_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_3, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = CHAM_128_R3_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_3, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = CHAM_128_R3_tuples_ADD_Middle(search_round,
					Input_u, Input_v, Input_w,
					Cw_3, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}

u16 CHAM_128_R3_tuples_ADD_Middle(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_3, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= Cw_3 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = CHAM_128_R3_tuples_ADD_MSB(search_round,
				tmp_U,tmp_V,tmp_W,
				Cw_3, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

				if(current_index <= blocksize_len -2)
				{
				//跳转到高比特分析
				best = CHAM_128_R3_tuples_ADD_Middle(search_round,
						tmp_U, tmp_V, tmp_W,
						Cw_3, Corr_tmp_inc, posi,
						current_index + 1, Fwt);
				}
				else
				{
					best = CHAM_128_R3_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_3, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//跳转到高比特分析
				best = CHAM_128_R3_tuples_ADD_Middle(search_round,
						Input_u, Input_v, Input_w,
						Cw_3, Corr_tmp_inc, posi,
						current_index +1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_128_R3_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_3, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_128_R3_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_3, Corr_tmp_inc +1, posi,
							current_index +1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 CHAM_128_R3_tuples_ADD_MSB(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_3, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;

		if(Corr_tmp_inc > Cw_3)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
		{
			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				CHAM_128_u[3] = tmp_U;
				CHAM_128_v[3] = tmp_V;
				CHAM_128_w[3] = tmp_W;
				//直接跳转到第4轮
				best = CHAM_128_R4_tuples(search_round);
			}
			else
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				CHAM_128_u[3] = Input_u;
				CHAM_128_v[3] = Input_v;
				CHAM_128_w[3] = Input_w;
				//直接跳转到第4轮
				best = CHAM_128_R4_tuples(search_round);
			}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  // Corr_tmp_inc == part_wt 搜索的当前wt与期望的相关性重量相等
		{
			if( (posi[Cw_3]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0; //!= >
			{
				if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
				{
					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = CHAM_128_R3_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_3, Corr_tmp_inc,posi,
							current_index +1, Fwt);
				}
				else
				{
					// UVW_i 为7
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
					Input_w = tmp_W | (bit_i << current_index); //该位置置1

					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = CHAM_128_R3_tuples_ADD_MSB(search_round,
							Input_u, Input_v, Input_w,
							Cw_3, Corr_tmp_inc, posi,
							current_index +1, Fwt);
	#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
	#endif
		}
			}
			else  //(posi[part_wt]-1) == current_index
			{

			if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW[i+1]位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_128_u[3] = Input_u;
					CHAM_128_v[3] = Input_v;
					CHAM_128_w[3] = Input_w;
					//直接跳转到第4轮
					best = CHAM_128_R4_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
				}
			}
			else
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW的最高位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_128_u[3] = Input_u;
					CHAM_128_v[3] = Input_v;
					CHAM_128_w[3] = Input_w;
					//直接跳转到第4轮
					best = CHAM_128_R4_tuples(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}}
			}}
		return best;
}

u32 CHAM_128_R4_tuples(u16 search_round)
{
	u32 best = 0;

	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 cor_wt = 0;

	u64 M0 = 0;
	u64 N0 = 31;  //blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;




	///////////////////round 4 entry/////////////////////
	cor_wt = CHAM_first_four_wt[3];
//	for(cor_wt = 0; cor_wt < 2; cor_wt++)  //0-->n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
#if (CHAM_even_round == 0 ) //当前搜索参数（1，8）开始的奇数轮的最优路径
		if( (P_w[1]+P_w[2]+P_w[3]+cor_wt + n_P_bestofR_w[search_round - 4]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}
#else  //CHAM_even_round=1, 当前搜索参数（8,1）开始的偶数轮的最优路径
		if( (P_w[1]+P_w[2]+P_w[3]+cor_wt + CHAM_Pw_even_cor[search_round - 4]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}
#endif


		M0 = cor_wt;  //
		P_w[4] = M0; //相关性重量的记录数组
		p_sumof_r_P_w[4] = P_w[1] + P_w[2] + P_w[3] +P_w[4];
		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			CHAM_128_u[4] = Input_u;
			CHAM_128_v[4] = Input_v;
			CHAM_128_w[4] = Input_w;

			//构造前4轮的可能输入输出掩码，并开始搜索第5轮的入口
			best = CHAM_128_First_4_round_masks_comb(search_round);

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;

			CHAM_128_u[4] = Input_u;
			CHAM_128_v[4] = Input_v;
			CHAM_128_w[4] = Input_w;

			//构造前4轮的可能输入输出掩码，并开始搜索第5轮的入口
			best = CHAM_128_First_4_round_masks_comb(search_round);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			//直接跳转到内部构造
			best = CHAM_128_R4_tuples_ADD_Last(search_round,P_w[4],C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHASKEY_Linear;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHASKEY_Linear;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHASKEY_Linear;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHASKEY_Linear;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHASKEY_Linear;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHASKEY_Linear;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
	CHASKEY_Linear:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}
///////////////输出其它的分布模式/////////////////
				//直接跳转到内部构造
				best = CHAM_128_R4_tuples_ADD_Last(search_round,P_w[4],C0);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}

	return best;
}


u16 CHAM_128_R4_tuples_ADD_Last(u16 search_round,u16 Cw_4, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;

		//跳转到高比特分析
		best = CHAM_128_R4_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_4, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = CHAM_128_R4_tuples_ADD_Middle(search_round,
				Input_u, Input_v, Input_w,
				Cw_4, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = CHAM_128_R4_tuples_ADD_Middle(search_round,
					Input_u, Input_v, Input_w,
					Cw_4, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}

u16 CHAM_128_R4_tuples_ADD_Middle(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_4, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= Cw_4 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = CHAM_128_R4_tuples_ADD_MSB(search_round,
				tmp_U,tmp_V,tmp_W,
				Cw_4, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0

				if(current_index <= blocksize_len -2)
				{
				//跳转到高比特分析
				best = CHAM_128_R4_tuples_ADD_Middle(search_round,
						tmp_U, tmp_V, tmp_W,
						Cw_4, Corr_tmp_inc, posi,
						current_index + 1, Fwt);
				}
				else
				{
					best = CHAM_128_R4_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_4, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				//跳转到高比特分析
				best = CHAM_128_R4_tuples_ADD_Middle(search_round,
						Input_u, Input_v, Input_w,
						Cw_4, Corr_tmp_inc, posi,
						current_index +1, Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_128_R4_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_4, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = CHAM_128_R4_tuples_ADD_Middle(search_round,
							Input_u, Input_v, Input_w,
							Cw_4, Corr_tmp_inc +1, posi,
							current_index +1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 CHAM_128_R4_tuples_ADD_MSB(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Cw_4, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


		if(Corr_tmp_inc > Cw_4)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
		{
			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				CHAM_128_u[4] = tmp_U;
				CHAM_128_v[4] = tmp_V;
				CHAM_128_w[4] = tmp_W;

				//构造前4轮的可能输入输出掩码，并开始搜索第5轮的入口
				best = CHAM_128_First_4_round_masks_comb(search_round);
			}
			else
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1

				CHAM_128_u[4] = Input_u;
				CHAM_128_v[4] = Input_v;
				CHAM_128_w[4] = Input_w;
				//构造前4轮的可能输入输出掩码，并开始搜索第5轮的入口
				best = CHAM_128_First_4_round_masks_comb(search_round);
			}
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  // Corr_tmp_inc == part_wt 搜索的当前wt与期望的相关性重量相等
		{
			if( (posi[Cw_4]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0; //!= >
			{
				if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
				{
					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = CHAM_128_R4_tuples_ADD_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Cw_4, Corr_tmp_inc,posi,
							current_index +1, Fwt);
				}
				else
				{
					// UVW_i 为7
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
					Input_w = tmp_W | (bit_i << current_index); //该位置置1

					//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
					best = CHAM_128_R4_tuples_ADD_MSB(search_round,
							Input_u, Input_v, Input_w,
							Cw_4, Corr_tmp_inc, posi,
							current_index +1, Fwt);
	#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
	#endif
		}
			}
			else  //(posi[part_wt]-1) == current_index
			{

			if( pre_cor_0or1 == 0) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW[i+1]位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_128_u[4] = Input_u;
					CHAM_128_v[4] = Input_v;
					CHAM_128_w[4] = Input_w;
					//构造前4轮的可能输入输出掩码，并开始搜索第5轮的入口
					best = CHAM_128_First_4_round_masks_comb(search_round);
	#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
	#endif
				}
			}
			else
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//UVW的最高位为7
					Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
					Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
					Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

					CHAM_128_u[4] = Input_u;
					CHAM_128_v[4] = Input_v;
					CHAM_128_w[4] = Input_w;
					//构造前4轮的可能输入输出掩码，并开始搜索第5轮的入口
					best = CHAM_128_First_4_round_masks_comb(search_round);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return best;
}
#endif
		}}
			}}
		return best;
}


u32 CHAM_128_First_4_round_masks_comb(u16 search_round)
{
	u32 best=0;
	u32 Masks_out[4] = {0};  //第5轮的输入掩码
	u16 ROL_a =8, ROL_b = 1;  //当搜索开始是从奇数轮开始的话，第4轮的两个旋转参数的默认值为8,1


#if(CHAM_even_round == 1) //当搜索开始是从 偶数 轮开始的话，第4轮的两个旋转参数的默认值为1，8
	{
		ROL_a =1; ROL_b = 8;
	}
#endif
	Masks_out[0] =  ROTATE_RIGHT(CHAM_128_w[4],ROL_a,blocksize_len) & Bit_Align;
	Masks_out[0] = (Masks_out[0]^ ROTATE_LEFT(CHAM_128_u[1],ROL_a,blocksize_len)) & Bit_Align;
	Masks_out[1] =  ROTATE_LEFT(CHAM_128_u[2],ROL_b,blocksize_len) & Bit_Align;
	Masks_out[2] =  ROTATE_LEFT(CHAM_128_u[3],ROL_a,blocksize_len) & Bit_Align;
	Masks_out[3] =  ROTATE_LEFT(CHAM_128_u[4],ROL_b,blocksize_len) & Bit_Align;
	//跳转到第5轮开始搜索
	best = CHAM_128_round_r(search_round, 5, Masks_out);

#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//计算前4轮的输入输出掩码
	CHAM_128_X[0][1] = CHAM_128_v[1];  //第1轮的输入掩码
	CHAM_128_X[1][1] = (ROTATE_RIGHT(CHAM_128_w[1],ROL_b,blocksize_len) ^ CHAM_128_v[2]) & Bit_Align;
	CHAM_128_X[2][1] = (ROTATE_RIGHT(CHAM_128_w[2],ROL_a,blocksize_len) ^ CHAM_128_v[3]) & Bit_Align;
	CHAM_128_X[3][1] = (ROTATE_RIGHT(CHAM_128_w[3],ROL_b,blocksize_len) ^ CHAM_128_v[4]) & Bit_Align;

	CHAM_128_X[0][2] = CHAM_128_v[2];  //第2轮的输入掩码
	CHAM_128_X[1][2] = CHAM_128_X[2][1];
	CHAM_128_X[2][2] = CHAM_128_X[3][1];
	CHAM_128_X[3][2] = ROTATE_LEFT(CHAM_128_u[1],ROL_a,blocksize_len)  & Bit_Align;

	CHAM_128_X[0][3] = CHAM_128_v[3];  //第3轮的输入掩码
	CHAM_128_X[1][3] = CHAM_128_X[2][2];
	CHAM_128_X[2][3] = CHAM_128_X[3][2];
	CHAM_128_X[3][3] = ROTATE_LEFT(CHAM_128_u[2],ROL_b,blocksize_len)  & Bit_Align;

	CHAM_128_X[0][4] = CHAM_128_v[4];  //第4轮的输入掩码
	CHAM_128_X[1][4] = CHAM_128_X[2][3];
	CHAM_128_X[2][4] = CHAM_128_X[3][3];
	CHAM_128_X[3][4] = ROTATE_LEFT(CHAM_128_u[3],ROL_a,blocksize_len)  & Bit_Align;

	CHAM_128_X[0][5] = Masks_out[0];
	CHAM_128_X[1][5] = Masks_out[1];
	CHAM_128_X[2][5] = Masks_out[2];
	CHAM_128_X[3][5] = Masks_out[3];

	return best;
}
#endif
	return best;
}

u32 CHAM_128_round_r(u16 search_round, u16 cur_round,u32 *Mask_r)
{
	u32 best=0;
	u32 Input_u=0, Input_w=0;
	u32 X0_sub_vector[4]={0};
	u32 u_block[4] = {0};
	u32 w_block[4] = {0};
	u32 Masks_out[4] = {0};  //第r轮的输入掩码
	u16 X0_Cw_min[4]={0};
//	u16 i = 0;
//	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0,i2=0,i3=0;
	u64 j0=0,j1=0,j2=0,j3=0;
	u16 e_Mxor[4] = {0};
	u16 ROL_a = 1, ROL_b = 8;

	if(search_round <= cur_round)
	{
		best = CHAM_128_round_N(search_round, Mask_r);
		return best;
	}

//	for(i=1;i<cur_round;i++)
	{
//		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}

#if (CHAM_even_round == 0 ) //当前搜索参数（1，8）开始的奇数轮的最优路径
	if((cur_round & 0x01) == 0)  //偶数轮 %2
	{
		ROL_a = 8; ROL_b = 1;
		w_cmp = Bn_w - p_sumof_r_P_w[cur_round-1] - n_P_bestofR_w[search_round - cur_round];
	}
	else  // 奇数轮
	{
		//ROL_a =1; ROL_b = 8; //默认的值就是1,8
		w_cmp = Bn_w - p_sumof_r_P_w[cur_round-1] - CHAM_Pw_even_cor[search_round - cur_round];
	}
#else  //CHAM_even_round=1, 当前搜索参数（8,1）开始的偶数轮的最优路径
	if((cur_round & 0x01) == 0)  //偶数轮 %2
	{
		//ROL_a = 1; ROL_b = 8;  //默认的值就是1,8
		w_cmp = Bn_w - p_sumof_r_P_w[cur_round-1] - CHAM_Pw_even_cor[search_round - cur_round];
	}
	else  // 奇数轮
	{
		ROL_a =8; ROL_b = 1;
		w_cmp = Bn_w - p_sumof_r_P_w[cur_round-1] - n_P_bestofR_w[search_round - cur_round];
	}
#endif


	X0_sub_vector[0] = Mask_r[0] & 0xFF; //低8位
	X0_sub_vector[1] = (Mask_r[0] >> 8) & 0xFF;  //高8位
	X0_sub_vector[2] = (Mask_r[0] >> 16) & 0xFF;  //高8位
	X0_sub_vector[3] = (Mask_r[0] >> 24) & 0xFF;  //高8位
	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	if(cLAT_wtcor_min[X0_sub_vector[0]][0] <= cLAT_wtcor_min[X0_sub_vector[0]][1] )
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[0]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[1]][0] <= cLAT_wtcor_min[X0_sub_vector[1]][1] )
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[1]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[2]][0] <= cLAT_wtcor_min[X0_sub_vector[2]][1] )
	{
		X0_Cw_min[2] = cLAT_wtcor_min[X0_sub_vector[2]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[2] = cLAT_wtcor_min[X0_sub_vector[2]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[2]; 	//bound wt
/*	if(cLAT_wtcor_min[X0_sub_vector[3]][0] <= cLAT_wtcor_min[X0_sub_vector[3]][1] )
	{
		X0_Cw_min[3] = cLAT_wtcor_min[X0_sub_vector[3]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[3] = cLAT_wtcor_min[X0_sub_vector[3]][1];// 高位的可能最小相关性重量
	}   */
	X0_Cw_min[3] = cLAT_wtcor_min[X0_sub_vector[3]][0];// 最高链接状态为0
	wt_cor_bound += X0_Cw_min[3]; 	//bound wt
	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

	//由MSB到LSB的方向组合U和W
	for(i0 = cLAT_wtcor_min[X0_sub_vector[3]][0];
			i0 <=cLAT_wtcor_min[X0_sub_vector[3]][0]; i0++)  //<8
	{
		if(i0 +X0_Cw_min[2]+X0_Cw_min[1]+X0_Cw_min[0]> w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
	for(j0=0; j0 < cLAT_WU_numb[X0_sub_vector[3]][0][i0]; j0++)
	{
		w_block[3] = cLAT_W[X0_sub_vector[3]][0][i0][j0];
		u_block[3] = cLAT_U[X0_sub_vector[3]][0][i0][j0];
		e_Mxor[3] = cLAT_UVW_bro[u_block[3]][X0_sub_vector[3]][w_block[3]][0];

	for(i1 = cLAT_wtcor_min[X0_sub_vector[2]][e_Mxor[3]];
			i1 <= cLAT_wtcor_min[X0_sub_vector[2]][e_Mxor[3]]; i1++)
	{
		if(i0 + i1 +X0_Cw_min[1]+X0_Cw_min[0]> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cLAT_WU_numb[X0_sub_vector[2]][e_Mxor[3]][i1]; j1++)
	{
		w_block[2] = cLAT_W[X0_sub_vector[2]][e_Mxor[3]][i1][j1];
		u_block[2] = cLAT_U[X0_sub_vector[2]][e_Mxor[3]][i1][j1];
		e_Mxor[2] = cLAT_UVW_bro[u_block[2]][X0_sub_vector[2]][w_block[2]][e_Mxor[3]];

	for(i2 = cLAT_wtcor_min[X0_sub_vector[1]][e_Mxor[2]];
			i2 <= cLAT_wtcor_min[X0_sub_vector[1]][e_Mxor[2]]; i2++)
	{
		if(i0 + i1 +i2 +X0_Cw_min[0]> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j2=0; j2 < cLAT_WU_numb[X0_sub_vector[1]][e_Mxor[2]][i2]; j2++)
	{
		w_block[1] = cLAT_W[X0_sub_vector[1]][e_Mxor[2]][i2][j2];
		u_block[1] = cLAT_U[X0_sub_vector[1]][e_Mxor[2]][i2][j2];
		e_Mxor[1] = cLAT_UVW_bro[u_block[1]][X0_sub_vector[1]][w_block[1]][e_Mxor[2]];

	for(i3 = cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor[1]];
			i3 <= cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor[1]]; i3++)
	{
		if(i0 + i1 +i2 +i3> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j3=0; j3 < cLAT_WU_numb[X0_sub_vector[0]][e_Mxor[1]][i3]; j3++)
	{
		w_block[0] = cLAT_W[X0_sub_vector[0]][e_Mxor[1]][i3][j3];
		u_block[0] = cLAT_U[X0_sub_vector[0]][e_Mxor[1]][i3][j3];

		Input_w = (w_block[3] << 24)|(w_block[2] << 16)|
				(w_block[1] << 8) | w_block[0];  //模加输入右侧掩码
		Input_u = (u_block[3] << 24)|(u_block[2] << 16)|
				(u_block[1] << 8) | u_block[0];  //模加输出掩码

		Masks_out[0] = (ROTATE_RIGHT(Input_w,ROL_a,blocksize_len) ^ Mask_r[1]) & Bit_Align;
		Masks_out[1] = Mask_r[2];
		Masks_out[2] = Mask_r[3];
		Masks_out[3] = ROTATE_LEFT(Input_u,ROL_b,blocksize_len)& Bit_Align;

		P_w[cur_round] = i0+i1+i2+i3;  //当前轮的线性相关性重量
		p_sumof_r_P_w[cur_round] = p_sumof_r_P_w[cur_round-1] + P_w[cur_round];

		//跳转 下一轮
		best = CHAM_128_round_r(search_round, cur_round+1, Masks_out);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			CHAM_128_X[0][cur_round+1] = Masks_out[0];
			CHAM_128_X[1][cur_round+1] = Masks_out[1];
			CHAM_128_X[2][cur_round+1] = Masks_out[2];
			CHAM_128_X[3][cur_round+1] = Masks_out[3];
			return 1;
		}
#endif
			}}}}}}}}
	return best;
}




u32 CHAM_128_round_N(u16 search_round,u32 *Mask_r)
{
	u32 best=0;
	u32 Input_u=0, Input_w=0;
	u32 X0_sub_vector[4]={0};
	u32 u_block[4] = {0};
	u32 w_block[4] = {0};
	u32 Masks_out[4] = {0};  //第r轮的输入掩码
	u16 X0_Cw_min[4]={0};
	u16 i = 0;
//	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0,i2=0,i3=0;
	u64 j0=0,j1=0,j2=0,j3=0;
	u16 e_Mxor[4] = {0};
	u16 ROL_a = 1, ROL_b = 8;

#if(CHAM_even_round == 0) //结束条件判断是搜索的奇数还是偶数轮开始的路径
	{
		if((search_round &0x01) == 0)  //偶数轮
		{
			ROL_a = 8; ROL_b = 1;
		}
		else  //奇数轮
		{
			ROL_a =1; ROL_b = 8;
		}
	}
#else // 搜索的路径为从奇数轮开始的
	{
		if((search_round &0x01) == 0)  //偶数轮
		{
			ROL_a = 1; ROL_b = 8;
		}
		else  //奇数轮
		{
			ROL_a =8; ROL_b = 1;
		}
	}
#endif

	w_cmp = Bn_w - p_sumof_r_P_w[search_round-1]; // p_sumof_r is the sum of r-1 rounds weight.


	X0_sub_vector[0] = Mask_r[0] & 0xFF; //低8位
	X0_sub_vector[1] = (Mask_r[0] >> 8) & 0xFF;  //高8位
	X0_sub_vector[2] = (Mask_r[0] >> 16) & 0xFF;  //高8位
	X0_sub_vector[3] = (Mask_r[0] >> 24) & 0xFF;  //高8位
	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	if(cLAT_wtcor_min[X0_sub_vector[0]][0] <= cLAT_wtcor_min[X0_sub_vector[0]][1] )
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[0]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[1]][0] <= cLAT_wtcor_min[X0_sub_vector[1]][1] )
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[1]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[2]][0] <= cLAT_wtcor_min[X0_sub_vector[2]][1] )
	{
		X0_Cw_min[2] = cLAT_wtcor_min[X0_sub_vector[2]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[2] = cLAT_wtcor_min[X0_sub_vector[2]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[2]; 	//bound wt
/*	if(cLAT_wtcor_min[X0_sub_vector[3]][0] <= cLAT_wtcor_min[X0_sub_vector[3]][1] )
	{
		X0_Cw_min[3] = cLAT_wtcor_min[X0_sub_vector[3]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[3] = cLAT_wtcor_min[X0_sub_vector[3]][1];// 高位的可能最小相关性重量
	} */
	X0_Cw_min[3] = cLAT_wtcor_min[X0_sub_vector[3]][0];// 最高链接状态为0
	wt_cor_bound += X0_Cw_min[3]; 	//bound wt
	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

	//由MSB到LSB的方向组合U和W
	for(i0 = cLAT_wtcor_min[X0_sub_vector[3]][0];
			i0 <=cLAT_wtcor_min[X0_sub_vector[3]][0]; i0++)
	{
		if(i0 +X0_Cw_min[2]+X0_Cw_min[1]+X0_Cw_min[0]> w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
	for(j0=0; j0 < cLAT_WU_numb[X0_sub_vector[3]][0][i0]; j0++)
	{
		w_block[3] = cLAT_W[X0_sub_vector[3]][0][i0][j0];
		u_block[3] = cLAT_U[X0_sub_vector[3]][0][i0][j0];
		e_Mxor[3] = cLAT_UVW_bro[u_block[3]][X0_sub_vector[3]][w_block[3]][0];

	for(i1 = cLAT_wtcor_min[X0_sub_vector[2]][e_Mxor[3]];
			i1 <= cLAT_wtcor_min[X0_sub_vector[2]][e_Mxor[3]]; i1++)
	{
		if(i0 + i1 +X0_Cw_min[1]+X0_Cw_min[0]> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cLAT_WU_numb[X0_sub_vector[2]][e_Mxor[3]][i1]; j1++)
	{
		w_block[2] = cLAT_W[X0_sub_vector[2]][e_Mxor[3]][i1][j1];
		u_block[2] = cLAT_U[X0_sub_vector[2]][e_Mxor[3]][i1][j1];
		e_Mxor[2] = cLAT_UVW_bro[u_block[2]][X0_sub_vector[2]][w_block[2]][e_Mxor[3]];

	for(i2 = cLAT_wtcor_min[X0_sub_vector[1]][e_Mxor[2]];
			i2 <= cLAT_wtcor_min[X0_sub_vector[1]][e_Mxor[2]]; i2++)
	{
		if(i0 + i1 +i2 +X0_Cw_min[0]> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j2=0; j2 < cLAT_WU_numb[X0_sub_vector[1]][e_Mxor[2]][i2]; j2++)
	{
		w_block[1] = cLAT_W[X0_sub_vector[1]][e_Mxor[2]][i2][j2];
		u_block[1] = cLAT_U[X0_sub_vector[1]][e_Mxor[2]][i2][j2];
		e_Mxor[1] = cLAT_UVW_bro[u_block[1]][X0_sub_vector[1]][w_block[1]][e_Mxor[2]];

	for(i3 = cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor[1]];
			i3 <= cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor[1]]; i3++)
	{
		if(i0 + i1 +i2 + i3 == w_cmp ){  //找到最优路径
		//if(i0 + i1 +i2 +i3> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j3=0; j3 < cLAT_WU_numb[X0_sub_vector[0]][e_Mxor[1]][i3]; j3++)
	{
		w_block[0] = cLAT_W[X0_sub_vector[0]][e_Mxor[1]][i3][j3];
		u_block[0] = cLAT_U[X0_sub_vector[0]][e_Mxor[1]][i3][j3];

		Input_w = (w_block[3] << 24)|(w_block[2] << 16)|
				(w_block[1] << 8) | w_block[0];  //模加输入右侧掩码
		Input_u = (u_block[3] << 24)|(u_block[2] << 16)|
				(u_block[1] << 8) | u_block[0];  //模加输出掩码

		CHAM_128_X[0][search_round+1] = (ROTATE_RIGHT(Input_w,ROL_a,blocksize_len) ^ Mask_r[1]) & Bit_Align;
		CHAM_128_X[1][search_round+1] = Mask_r[2];
		CHAM_128_X[2][search_round+1] = Mask_r[3];
		CHAM_128_X[3][search_round+1] = ROTATE_LEFT(Input_u,ROL_b,blocksize_len)& Bit_Align;
		P_w[search_round] = i0 + i1+i2+i3;  //当前轮的线性相关性重量
		p_sumof_r_P_w[search_round] = p_sumof_r_P_w[search_round-1] + P_w[search_round];

#if(CHAM_even_round == 0) //当搜索开始是从 奇数 轮开始的话，搜索结果记录到n_P_bestofR_w
		{
			if(p_sumof_r_P_w[search_round] <=Bn_w)
			{
				n_P_bestofR_w[search_round] = Bn_w;
				//p_sumof_r_P_w[search_round-1] + P_w[search_round];    //
			}

		}
#else  //当搜索开始是从 偶数 轮开始的话，搜索线性结果记录到CHAM_Pw_even_cor
		{
			if(p_sumof_r_P_w[search_round] <=Bn_w)
			{
				//p_sumof_r_P_w[search_round-1] + P_w[search_round];    //
				CHAM_Pw_even_cor[search_round] = Bn_w;
			}
		}
#endif

		best = 1;
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			return 1;
		}
#endif
			}}}}}}}}}
	return best;
}




u32 CHAM128_Linear_Hull_search_entry(u16 search_round)
{
	u32 best = 0;
	u16 i = 0;
	FILE* CHAM_128_linear_Bn;

	CHAM_128_linear_Bn = fopen ("../tmp/CHAM_128_linear_Bn_wt.xlsx", "a+"); //  "w+"); //
	if(sc_blocksize != 128)
	{
		printf("The block size of CHAM should be 128 bits. \n");
		return 0;
	}
	// For CHAM-128 modular additon is 32 bits.
	blocksize_len = 32;
	Bit_Align = 0xFFFFFFFF;

	printf("Constructing CHAM-128 cLAT Tables... \n");
	//构造部分的线性相关性近似表cLAT
	ARX_cLAT_construct();
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct CHAM-128 cLAT: %.2f seconds.  \n", run_time);

	Bn_w = 0;
	if(search_round > 1)
	{
		for(i=1; i <= search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(CHAM_128_linear_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		Bn_w = n_P_bestofR_w[search_round -1] - 1;
	}


	//xx round cor CHAM128
	CHAM_128_IN_Mask[0] = 0x0000;
	CHAM_128_IN_Mask[1] = 0x0000;
	CHAM_128_IN_Mask[2] = 0x0000;
	CHAM_128_IN_Mask[3] = 0x4020;

	CHAM_128_OUT_Mask[0] = 0x0000;
	CHAM_128_OUT_Mask[1] = 0x0000;
	CHAM_128_OUT_Mask[2] = 0x0215;
	CHAM_128_OUT_Mask[3] = 0x0012;

	wt_max = 23;
	n_P_bestofR_w[search_round] = 23;

	Bn_w = n_P_bestofR_w[search_round];
	//通过参数wt_max来选择需要搜索的路径的概率范围:最优路径-->wt_max.
	printf("wt_min(:%d)--->wt_max: %d \n", n_P_bestofR_w[search_round], wt_max);
	printf("-----------------------Search CHAM-128 Linear Hulls---------------------------\n");
	CHAM128_Linear_Hull_round_r_odd(search_round,1,  CHAM_128_IN_Mask);
	printf("-----------------------Record CHAM-128 Linear Hulls---------------------\n");


	for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
	{
		prob = prob + (wt_nmu[i] * pow(2,-2*i));
		prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
		printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
	}
	printf("++++++++++++++++++\n ");
	printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
	//printf("input:0x%012x %012x ======>> output:0x%012x %012x \n",input_diff_L,input_diff_R,output_diff_L,output_diff_R);
	printf( "0x%08llx %08llx %08llx %08llx \n"
			"==================>>\n"
		    "0x%08llx %08llx %08llx %08llx \n",
			CHAM_128_IN_Mask[0],CHAM_128_IN_Mask[1],CHAM_128_IN_Mask[2],CHAM_128_IN_Mask[3],
			CHAM_128_OUT_Mask[0],CHAM_128_OUT_Mask[1],CHAM_128_OUT_Mask[2],CHAM_128_OUT_Mask[3]);

	printf(" wt_min: -%d ===>> wt_max: -%d \n",n_P_bestofR_w[search_round],wt_max);
	printf(" %d Rounds Linear Hull with total %d trails.\n",search_round,count);
	printf(" Correlation potential is: %.2Lf \n",prob_w);
	printf("++++++++++++++++++\n ");


	time_finish = clock();
	run_time = (double)(time_finish - time_ARX_cLAT) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours == %.2f days. \n", run_time,run_time/60.0,run_time/3600.0,run_time/86400.0 );
	printf("Auto-search CHAM-128 Linear hulls END! \n");
	printf("|************************************************************************|\n");
	fclose(CHAM_128_linear_Bn);

	return best;
}


u32 CHAM128_Linear_Hull_round_r_odd(u16 search_round, u16 cur_round,u32 *Mask_r)
{
	u32 best=0;
	u32 Input_u=0, Input_w=0;
	u32 X0_sub_vector[4]={0};
	u32 u_block[4] = {0};
	u32 w_block[4] = {0};
	u32 Masks_out[4] = {0};  //第r轮的输入掩码
	u16 X0_Cw_min[4]={0};
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0,i2=0,i3=0;
	u64 j0=0,j1=0,j2=0,j3=0;
	u16 e_Mxor[4] = {0};


	X0_sub_vector[0] = Mask_r[0] & 0xFF; //低8位
	X0_sub_vector[1] = (Mask_r[0] >> 8) & 0xFF;  //高8位
	X0_sub_vector[2] = (Mask_r[0] >> 16) & 0xFF;  //高8位
	X0_sub_vector[3] = (Mask_r[0] >> 24) & 0xFF;  //高8位

	if(search_round <= cur_round)
	{
		best = CHAM128_Linear_Hull_round_N_odd(search_round, Mask_r);
		return best;
	}

	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r - n_P_bestofR_w[search_round - cur_round];

	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	if(cLAT_wtcor_min[X0_sub_vector[0]][0] <= cLAT_wtcor_min[X0_sub_vector[0]][1] )
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[0]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[1]][0] <= cLAT_wtcor_min[X0_sub_vector[1]][1] )
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[1]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[2]][0] <= cLAT_wtcor_min[X0_sub_vector[2]][1] )
	{
		X0_Cw_min[2] = cLAT_wtcor_min[X0_sub_vector[2]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[2] = cLAT_wtcor_min[X0_sub_vector[2]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[2]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[3]][0] <= cLAT_wtcor_min[X0_sub_vector[3]][1] )
	{
		X0_Cw_min[3] = cLAT_wtcor_min[X0_sub_vector[3]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[3] = cLAT_wtcor_min[X0_sub_vector[3]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[3]; 	//bound wt
	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

			//由MSB到LSB的方向组合U和W
			for(i0 = cLAT_wtcor_min[X0_sub_vector[3]][0]; i0 < 8; i0++)
			{
				if(i0 +X0_Cw_min[2]+X0_Cw_min[1]+X0_Cw_min[0]> w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
			for(j0=0; j0 < cLAT_WU_numb[X0_sub_vector[3]][0][i0]; j0++)
			{
				w_block[3] = cLAT_W[X0_sub_vector[3]][0][i0][j0];
				u_block[3] = cLAT_U[X0_sub_vector[3]][0][i0][j0];
				e_Mxor[3] = cLAT_UVW_bro[u_block[3]][X0_sub_vector[3]][w_block[3]][0];

			for(i1 = cLAT_wtcor_min[X0_sub_vector[2]][e_Mxor[3]]; i1 <= 8; i1++)
			{
				if(i0 + i1 +X0_Cw_min[1]+X0_Cw_min[0]> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j1=0; j1 < cLAT_WU_numb[X0_sub_vector[2]][e_Mxor[3]][i1]; j1++)
			{
				w_block[2] = cLAT_W[X0_sub_vector[2]][e_Mxor[3]][i1][j1];
				u_block[2] = cLAT_U[X0_sub_vector[2]][e_Mxor[3]][i1][j1];
				e_Mxor[2] = cLAT_UVW_bro[u_block[2]][X0_sub_vector[2]][w_block[2]][e_Mxor[3]];

			for(i2 = cLAT_wtcor_min[X0_sub_vector[1]][e_Mxor[2]]; i2 <= 8; i2++)
			{
				if(i0 + i1 +i2 +X0_Cw_min[0]> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j2=0; j2 < cLAT_WU_numb[X0_sub_vector[1]][e_Mxor[3]][i2]; j2++)
			{
				w_block[1] = cLAT_W[X0_sub_vector[1]][e_Mxor[2]][i2][j2];
				u_block[1] = cLAT_U[X0_sub_vector[1]][e_Mxor[2]][i2][j2];
				e_Mxor[1] = cLAT_UVW_bro[u_block[1]][X0_sub_vector[1]][w_block[1]][e_Mxor[2]];

			for(i3 = cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor[1]]; i3 <= 8; i3++)
			{
				if(i0 + i1 +i2 +i3> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
			for(j3=0; j3 < cLAT_WU_numb[X0_sub_vector[0]][e_Mxor[1]][i3]; j3++)
			{
				w_block[0] = cLAT_W[X0_sub_vector[0]][e_Mxor[1]][i3][j3];
				u_block[0] = cLAT_U[X0_sub_vector[0]][e_Mxor[1]][i3][j3];

				Input_w = (w_block[3] << 24)|(w_block[2] << 16)|
						(w_block[1] << 8) | w_block[0];  //模加输入右侧掩码
				Input_u = (u_block[3] << 24)|(u_block[2] << 16)|
						(u_block[1] << 8) | u_block[0];  //模加输出掩码

				Masks_out[0] = (ROTATE_RIGHT(Input_w,1,blocksize_len) ^ Mask_r[1]) & Bit_Align;
				Masks_out[1] = Mask_r[2];
				Masks_out[2] = Mask_r[3];
				Masks_out[3] = ROTATE_LEFT(Input_u,8,blocksize_len)& Bit_Align;

				P_w[cur_round] = i0+i1+i2+i3;  //当前轮的线性相关性重量

				//跳转 下一轮
				best = CHAM128_Linear_Hull_round_r_even(search_round, cur_round+1, Masks_out);

			}}}}}}}}
	return best;
}



u32 CHAM128_Linear_Hull_round_r_even(u16 search_round, u16 cur_round,u32 *Mask_r)
{
	u32 best=0;
	u32 Input_u=0, Input_w=0;
	u32 X0_sub_vector[4]={0};
	u32 u_block[4] = {0};
	u32 w_block[4] = {0};
	u32 Masks_out[4] = {0};  //第r轮的输入掩码
	u16 X0_Cw_min[4]={0};
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0,i2=0,i3=0;
	u64 j0=0,j1=0,j2=0,j3=0;
	u16 e_Mxor[4] = {0};


	X0_sub_vector[0] = Mask_r[0] & 0xFF; //低8位
	X0_sub_vector[1] = (Mask_r[0] >> 8) & 0xFF;  //高8位
	X0_sub_vector[2] = (Mask_r[0] >> 16) & 0xFF;  //高8位
	X0_sub_vector[3] = (Mask_r[0] >> 24) & 0xFF;  //高8位


	if(search_round <= cur_round)
	{
		best = CHAM128_Linear_Hull_round_N_even(search_round, Mask_r);
		return best;
	}

	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r - n_P_bestofR_w[search_round - cur_round];

	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	if(cLAT_wtcor_min[X0_sub_vector[0]][0] <= cLAT_wtcor_min[X0_sub_vector[0]][1] )
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[0]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[1]][0] <= cLAT_wtcor_min[X0_sub_vector[1]][1] )
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[1]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[2]][0] <= cLAT_wtcor_min[X0_sub_vector[2]][1] )
	{
		X0_Cw_min[2] = cLAT_wtcor_min[X0_sub_vector[2]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[2] = cLAT_wtcor_min[X0_sub_vector[2]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[2]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[3]][0] <= cLAT_wtcor_min[X0_sub_vector[3]][1] )
	{
		X0_Cw_min[3] = cLAT_wtcor_min[X0_sub_vector[3]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[3] = cLAT_wtcor_min[X0_sub_vector[3]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[3]; 	//bound wt
	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

	//由MSB到LSB的方向组合U和W
	for(i0 = cLAT_wtcor_min[X0_sub_vector[3]][0]; i0 < 8; i0++)
	{
		if(i0 +X0_Cw_min[2]+X0_Cw_min[1]+X0_Cw_min[0]> w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
	for(j0=0; j0 < cLAT_WU_numb[X0_sub_vector[3]][0][i0]; j0++)
	{
		w_block[3] = cLAT_W[X0_sub_vector[3]][0][i0][j0];
		u_block[3] = cLAT_U[X0_sub_vector[3]][0][i0][j0];
		e_Mxor[3] = cLAT_UVW_bro[u_block[3]][X0_sub_vector[3]][w_block[3]][0];

	for(i1 = cLAT_wtcor_min[X0_sub_vector[2]][e_Mxor[3]]; i1 <= 8; i1++)
	{
		if(i0 + i1 +X0_Cw_min[1]+X0_Cw_min[0]> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cLAT_WU_numb[X0_sub_vector[2]][e_Mxor[3]][i1]; j1++)
	{
		w_block[2] = cLAT_W[X0_sub_vector[2]][e_Mxor[3]][i1][j1];
		u_block[2] = cLAT_U[X0_sub_vector[2]][e_Mxor[3]][i1][j1];
		e_Mxor[2] = cLAT_UVW_bro[u_block[2]][X0_sub_vector[2]][w_block[2]][e_Mxor[3]];

	for(i2 = cLAT_wtcor_min[X0_sub_vector[1]][e_Mxor[2]]; i2 <= 8; i2++)
	{
		if(i0 + i1 +i2 +X0_Cw_min[0]> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j2=0; j2 < cLAT_WU_numb[X0_sub_vector[1]][e_Mxor[3]][i2]; j2++)
	{
		w_block[1] = cLAT_W[X0_sub_vector[1]][e_Mxor[2]][i2][j2];
		u_block[1] = cLAT_U[X0_sub_vector[1]][e_Mxor[2]][i2][j2];
		e_Mxor[1] = cLAT_UVW_bro[u_block[1]][X0_sub_vector[1]][w_block[1]][e_Mxor[2]];

	for(i3 = cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor[1]]; i3 <= 8; i3++)
	{
		if(i0 + i1 +i2 +i3> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j3=0; j3 < cLAT_WU_numb[X0_sub_vector[0]][e_Mxor[1]][i3]; j3++)
	{
		w_block[0] = cLAT_W[X0_sub_vector[0]][e_Mxor[1]][i3][j3];
		u_block[0] = cLAT_U[X0_sub_vector[0]][e_Mxor[1]][i3][j3];


		Input_w = (w_block[3] << 24)|(w_block[2] << 16)|
				(w_block[1] << 8) | w_block[0];  //模加输入右侧掩码
		Input_u = (u_block[3] << 24)|(u_block[2] << 16)|
				(u_block[1] << 8) | u_block[0];  //模加输出掩码

		Masks_out[0] = (ROTATE_RIGHT(Input_w,8,blocksize_len) ^ Mask_r[1]) & Bit_Align;
		Masks_out[1] = Mask_r[2];
		Masks_out[2] = Mask_r[3];
		Masks_out[3] = ROTATE_LEFT(Input_u,1,blocksize_len)& Bit_Align;

		P_w[cur_round] = i0 + i1+i2+i3;  //当前轮的线性相关性重量

				//跳转 下一轮
				best = CHAM128_Linear_Hull_round_r_odd(search_round, cur_round+1, Masks_out);

			}}}}}}}}
	return best;
}



u32 CHAM128_Linear_Hull_round_N_odd(u16 search_round,u32 *Mask_r)
{
	u32 best=0;
	u32 Input_u=0, Input_w=0;
	u32 X0_sub_vector[4]={0};
	u32 u_block[4] = {0};
	u32 w_block[4] = {0};
//	u32 Masks_out[4] = {0};  //第r轮的输入掩码
	u16 X0_Cw_min[4]={0};
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0,i2=0,i3=0;
	u64 j0=0,j1=0,j2=0,j3=0;
	u16 e_Mxor[4] = {0};
	u16 j = 0, Not_eq=0;

	X0_sub_vector[0] = Mask_r[0] & 0xFF; //低8位
	X0_sub_vector[1] = (Mask_r[0] >> 8) & 0xFF;  //高8位
	X0_sub_vector[2] = (Mask_r[0] >> 16) & 0xFF;  //高8位
	X0_sub_vector[3] = (Mask_r[0] >> 24) & 0xFF;  //高8位

	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r;
	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	if(cLAT_wtcor_min[X0_sub_vector[0]][0] <= cLAT_wtcor_min[X0_sub_vector[0]][1] )
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[0]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[1]][0] <= cLAT_wtcor_min[X0_sub_vector[1]][1] )
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[1]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[2]][0] <= cLAT_wtcor_min[X0_sub_vector[2]][1] )
	{
		X0_Cw_min[2] = cLAT_wtcor_min[X0_sub_vector[2]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[2] = cLAT_wtcor_min[X0_sub_vector[2]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[2]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[3]][0] <= cLAT_wtcor_min[X0_sub_vector[3]][1] )
	{
		X0_Cw_min[3] = cLAT_wtcor_min[X0_sub_vector[3]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[3] = cLAT_wtcor_min[X0_sub_vector[3]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[3]; 	//bound wt
	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

	//由MSB到LSB的方向组合U和W
	for(i0 = cLAT_wtcor_min[X0_sub_vector[3]][0]; i0 < 8; i0++)
	{
		if(i0 +X0_Cw_min[2]+X0_Cw_min[1]+X0_Cw_min[0]> w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
	for(j0=0; j0 < cLAT_WU_numb[X0_sub_vector[3]][0][i0]; j0++)
	{
		w_block[3] = cLAT_W[X0_sub_vector[3]][0][i0][j0];
		u_block[3] = cLAT_U[X0_sub_vector[3]][0][i0][j0];
		e_Mxor[3] = cLAT_UVW_bro[u_block[3]][X0_sub_vector[3]][w_block[3]][0];

	for(i1 = cLAT_wtcor_min[X0_sub_vector[2]][e_Mxor[3]]; i1 <= 8; i1++)
	{
		if(i0 + i1 +X0_Cw_min[1]+X0_Cw_min[0]> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cLAT_WU_numb[X0_sub_vector[2]][e_Mxor[3]][i1]; j1++)
	{
		w_block[2] = cLAT_W[X0_sub_vector[2]][e_Mxor[3]][i1][j1];
		u_block[2] = cLAT_U[X0_sub_vector[2]][e_Mxor[3]][i1][j1];
		e_Mxor[2] = cLAT_UVW_bro[u_block[2]][X0_sub_vector[2]][w_block[2]][e_Mxor[3]];

	for(i2 = cLAT_wtcor_min[X0_sub_vector[1]][e_Mxor[2]]; i2 <= 8; i2++)
	{
		if(i0 + i1 +i2 +X0_Cw_min[0]> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j2=0; j2 < cLAT_WU_numb[X0_sub_vector[1]][e_Mxor[3]][i2]; j2++)
	{
		w_block[1] = cLAT_W[X0_sub_vector[1]][e_Mxor[2]][i2][j2];
		u_block[1] = cLAT_U[X0_sub_vector[1]][e_Mxor[2]][i2][j2];
		e_Mxor[1] = cLAT_UVW_bro[u_block[1]][X0_sub_vector[1]][w_block[1]][e_Mxor[2]];

	for(i3 = cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor[1]]; i3 <= 8; i3++)
	{
		if(i0 + i1 +i2 + i3 == w_cmp ){  //找到最优路径
		//if(i0 + i1 +i2 +i3> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j3=0; j3 < cLAT_WU_numb[X0_sub_vector[0]][e_Mxor[1]][i3]; j3++)
	{
		w_block[0] = cLAT_W[X0_sub_vector[0]][e_Mxor[1]][i3][j3];
		u_block[0] = cLAT_U[X0_sub_vector[0]][e_Mxor[1]][i3][j3];


		Input_w = (w_block[3] << 24)|(w_block[2] << 16)|
				(w_block[1] << 8) | w_block[0];  //模加输入右侧掩码
		Input_u = (u_block[3] << 24)|(u_block[2] << 16)|
				(u_block[1] << 8) | u_block[0];  //模加输出掩码

		CHAM_128_X[0][search_round+1] = (ROTATE_RIGHT(Input_w,1,blocksize_len) ^ Mask_r[1]) & Bit_Align;
		CHAM_128_X[1][search_round+1] = Mask_r[2];
		CHAM_128_X[2][search_round+1] = Mask_r[3];
		CHAM_128_X[3][search_round+1] = ROTATE_LEFT(Input_u,8,blocksize_len)& Bit_Align;
		P_w[search_round] = i0 + i1+i2+i3;  //当前轮的线性相关性重量

		Not_eq = 0;
		for(j=0;j<4;j++)
		{
			if(CHAM_128_X[j][search_round +1] != CHAM_128_OUT_Mask[j] ) //u16 OUT_Y_Mask[8] = {0};
			{
				Not_eq = 1;
				break;
			}
		}

		if( Not_eq != 0)
		{ continue; }

		count++;
		Bn_w = p_sumof_r + P_w[search_round] ;
		printf("count: %d    weight: %d \n",count,Bn_w);
		wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;

	}}}}}}}}}
	return best;
}


u32 CHAM128_Linear_Hull_round_N_even(u16 search_round,u32 *Mask_r)
{
	u32 best=0;
	u32 Input_u=0, Input_w=0;
	u32 X0_sub_vector[4]={0};
	u32 u_block[4] = {0};
	u32 w_block[4] = {0};
//	u32 Masks_out[4] = {0};  //第r轮的输入掩码
	u16 X0_Cw_min[4]={0};
	u16 i = 0;
	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u16 wt_cor_bound = 0;
	u64 i0=0,i1=0,i2=0,i3=0;
	u64 j0=0,j1=0,j2=0,j3=0;
	u16 e_Mxor[4] = {0};
	u16 j = 0, Not_eq=0;

	X0_sub_vector[0] = Mask_r[0] & 0xFF; //低8位
	X0_sub_vector[1] = (Mask_r[0] >> 8) & 0xFF;  //高8位
	X0_sub_vector[2] = (Mask_r[0] >> 16) & 0xFF;  //高8位
	X0_sub_vector[3] = (Mask_r[0] >> 24) & 0xFF;  //高8位

	for(i=1;i<search_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
	w_cmp = wt_max - p_sumof_r;

	//对于每个分块都将16比特的分组分别分成2个8比特的块，并记录可能的最小相关性重量
	if(cLAT_wtcor_min[X0_sub_vector[0]][0] <= cLAT_wtcor_min[X0_sub_vector[0]][1] )
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[0] = cLAT_wtcor_min[X0_sub_vector[0]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[0]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[1]][0] <= cLAT_wtcor_min[X0_sub_vector[1]][1] )
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[1] = cLAT_wtcor_min[X0_sub_vector[1]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[1]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[2]][0] <= cLAT_wtcor_min[X0_sub_vector[2]][1] )
	{
		X0_Cw_min[2] = cLAT_wtcor_min[X0_sub_vector[2]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[2] = cLAT_wtcor_min[X0_sub_vector[2]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[2]; 	//bound wt
	if(cLAT_wtcor_min[X0_sub_vector[3]][0] <= cLAT_wtcor_min[X0_sub_vector[3]][1] )
	{
		X0_Cw_min[3] = cLAT_wtcor_min[X0_sub_vector[3]][0];// 高位的可能最小相关性重量
	}
	else
	{
		X0_Cw_min[3] = cLAT_wtcor_min[X0_sub_vector[3]][1];// 高位的可能最小相关性重量
	}
	wt_cor_bound += X0_Cw_min[3]; 	//bound wt
	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}

	//由MSB到LSB的方向组合U和W
	for(i0 = cLAT_wtcor_min[X0_sub_vector[3]][0]; i0 < 8; i0++)
	{
		if(i0 +X0_Cw_min[2]+X0_Cw_min[1]+X0_Cw_min[0]> w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
	for(j0=0; j0 < cLAT_WU_numb[X0_sub_vector[3]][0][i0]; j0++)
	{
		w_block[3] = cLAT_W[X0_sub_vector[3]][0][i0][j0];
		u_block[3] = cLAT_U[X0_sub_vector[3]][0][i0][j0];
		e_Mxor[3] = cLAT_UVW_bro[u_block[3]][X0_sub_vector[3]][w_block[3]][0];

	for(i1 = cLAT_wtcor_min[X0_sub_vector[2]][e_Mxor[3]]; i1 <= 8; i1++)
	{
		if(i0 + i1 +X0_Cw_min[1]+X0_Cw_min[0]> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cLAT_WU_numb[X0_sub_vector[2]][e_Mxor[3]][i1]; j1++)
	{
		w_block[2] = cLAT_W[X0_sub_vector[2]][e_Mxor[3]][i1][j1];
		u_block[2] = cLAT_U[X0_sub_vector[2]][e_Mxor[3]][i1][j1];
		e_Mxor[2] = cLAT_UVW_bro[u_block[2]][X0_sub_vector[2]][w_block[2]][e_Mxor[3]];

	for(i2 = cLAT_wtcor_min[X0_sub_vector[1]][e_Mxor[2]]; i2 <= 8; i2++)
	{
		if(i0 + i1 +i2 + X0_Cw_min[0]> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j2=0; j2 < cLAT_WU_numb[X0_sub_vector[1]][e_Mxor[3]][i2]; j2++)
	{
		w_block[1] = cLAT_W[X0_sub_vector[1]][e_Mxor[2]][i2][j2];
		u_block[1] = cLAT_U[X0_sub_vector[1]][e_Mxor[2]][i2][j2];
		e_Mxor[1] = cLAT_UVW_bro[u_block[1]][X0_sub_vector[1]][w_block[1]][e_Mxor[2]];

	for(i3 = cLAT_wtcor_min[X0_sub_vector[0]][e_Mxor[1]]; i3 <= 8; i3++)
	{
		if(i0 + i1 +i2 + i3 == w_cmp ){  //找到最优路径
		//if(i0 + i1 +i2 +i3> w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j3=0; j3 < cLAT_WU_numb[X0_sub_vector[0]][e_Mxor[1]][i3]; j3++)
	{
		w_block[0] = cLAT_W[X0_sub_vector[0]][e_Mxor[1]][i3][j3];
		u_block[0] = cLAT_U[X0_sub_vector[0]][e_Mxor[1]][i3][j3];

		Input_w = (w_block[3] << 24)|(w_block[2] << 16)|
				(w_block[1] << 8) | w_block[0];  //模加输入右侧掩码
		Input_u = (u_block[3] << 24)|(u_block[2] << 16)|
				(u_block[1] << 8) | u_block[0];  //模加输出掩码

		CHAM_128_X[0][search_round+1] = (ROTATE_RIGHT(Input_w,8,blocksize_len) ^ Mask_r[1]) & Bit_Align;
		CHAM_128_X[1][search_round+1] = Mask_r[2];
		CHAM_128_X[2][search_round+1] = Mask_r[3];
		CHAM_128_X[3][search_round+1] = ROTATE_LEFT(Input_u,1,blocksize_len)& Bit_Align;

		P_w[search_round] = i0 + i1+i2+i3;  //当前轮的线性相关性重量

		Not_eq = 0;
		for(j=0;j<4;j++)
		{
			if(CHAM_128_X[j][search_round +1] != CHAM_128_OUT_Mask[j] ) //u16 OUT_Y_Mask[8] = {0};
			{
				Not_eq = 1;
				break;
			}
		}

		if( Not_eq != 0)
		{ continue; }

		count++;
		Bn_w = p_sumof_r + P_w[search_round] ;
		printf("count: %d    weight: %d \n",count,Bn_w);
		wt_nmu[Bn_w] = wt_nmu[Bn_w] + 1;

		}}}}}}}}}
	return best;
}


////////////////////////////////搜索Alzette的最优 差分 特征的代码//////////////////////////////
u32 Alzette_Diff_trail_search_entry(u16 search_round)
{
	u32 best = 0;
	u16 i = 0;
	FILE* Alzette_diff_Bn;
	u16 Bn_wt_expected = 0;


	Alzette_diff_Bn = fopen ("../tmp/Alzette_diff_Bn_wt.xlsx", "a+"); //  "w+"); //

	if(sc_blocksize != 64)
	{
		printf("The block size of Alzette(ARX-Box) should be 64 bits. \n");
		return 0;
	}
	// For Alzette modular additon is 32 bits.
	blocksize_len = 32;
	nBytes = 4;  //分为几个8比特的块
	Bit_Align = 0xFFFFFFFF;
	ValueMax_Align = 0x7FFFFFFF;
	V_MSB = 0x80000000;
/*
	printf("---------------------------------------- \n");
	u16 AA =0x8054, AAx=0, Ar=0, CAr=0;
	u16 BB = 0xA900, BBx=0, Br=0,CBr=0;
	AAx = AA; BBx=BB;
	for(i=1;i<16;i++)
	{
		Ar= (AAx << i) | (AAx >> (16-i));
		Br = (BBx << i) | (BBx >> (16-i));
		CAr = CAr ^ Ar; CBr = CBr ^ Br;
		printf("AA: 0x%04llx  0x%04llx  ABr_<<<%d:0x%04llx  x%04llx  CAr:0x%04llx  CBr:0x%04llx \n",
				AA, BB, i,Ar,Br, CAr, CBr);

		AA = AA ^ Ar;
		BB = BB ^ Br;

	}
	printf("AA:   0x%04llx   0x%04llx \n", AA, BB);
	printf("--------------------------------------- \n");
*/
	printf("Constructing cDDT Lookup Tables... \n");
	//构造cDDT
	ARX_carry_DDTm_construct();  // FOR cDDT
	//fixed_Alpha_get_betagamma();   //for 234 round
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct Alzette cDDT: %.2f seconds.  \n", run_time);

	Bn_w = 0;
	if(search_round > 1)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(Alzette_diff_Bn,"%d",&n_P_bestofR_w[i]);  //read.
		}
	}

	Bn_w = n_P_bestofR_w[search_round -1] - 1;
	p_sumof_r_P_w[search_round] = 0xFFFF;

	Bn_w = 33;  //直接设定开始的概率重量,快速达到期望的概率重量
			do
			{
				Bn_w = Bn_w + 1;
				printf("Searching Alzette Bn_w: %d \n", Bn_w);

				// Search Entry.
				best = Alzette_Diff_trail_round_1(search_round); //效率高

				time_Round = clock();
				run_time =  (time_Round - time_ARX_cLAT) / CLOCKS_PER_SEC;
				printf("Time: %.2f seconds.  \n", run_time);

				Bn_wt_expected =  n_P_bestofR_w[search_round];
			}while(Bn_w != Bn_wt_expected);   //end conditions. // !=

			fprintf(Alzette_diff_Bn,"%d \n",n_P_bestofR_w[search_round]);  // write.
			print_Alzette_diff_resoult(search_round);  //打印

			time_finish = clock();
			run_time = (double)(time_finish - time_ARX_cLAT) / CLOCKS_PER_SEC;
			printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours == %.2f days. \n", run_time,run_time/60.0,run_time/3600.0,run_time/86400.0 );
			printf("Auto-search %d-Round Alzette optimal differential trails END! \n", search_round);
			printf("|************************************************************************|\n");
			fclose(Alzette_diff_Bn);
	return best;
}

u32 Alzette_Diff_trail_round_1(u16 search_round)
{
	u32 best = 0;
	u16 thr_d = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;


	u64 M0 = 0;
	u64 N0 = blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;
	u16 j_abc = 0;


///////////////////round 1 entry/////////////////////
	if( search_round == 1)
	{
		best = round_1_j(1);
		return best;
	}
	else
	{	// 可以选择是否限定第1轮的概率重量
		for(thr_d = 0; thr_d < blocksize_len-1 ;thr_d++)  //0::n-1 //blocksize_len-1
		{
			// thr_d : the bits number of alpha/beta/gamma that the position not equal at the same time.
			if ((thr_d + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
			{
				return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
			}

			M0 = thr_d;  //三个alpha,beta和gamma同时考虑
			P_w[1] = M0;  //pro;
			p_sumof_r_P_w[1] = P_w[1];
			if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
			{
				for(j_abc = 1; j_abc < 4;j_abc++)
				{
					if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
					{
						Input_alpha = V_MSB;
					}
					else
					{
						Input_alpha = 0;  // & Bit_Align;
					}

					if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
					{
						Input_beta = V_MSB;
					}
					else
					{
						Input_beta = 0; // & Bit_Align;
					}

					if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
					{
						Input_gamma = V_MSB;
					}
					else
					{
						Input_gamma = 0;  // & Bit_Align;
					}

					Alzette_X[0][0] = Input_alpha;
					Alzette_X[1][0] = Alzette_rol_left_31(Input_beta);
					Alzette_X[0][1] = Input_gamma;  // left part output of fisrt round.
					Alzette_X[1][1] = Alzette_X[1][0] ^ (Alzette_rol_right_24(Input_gamma));

					best = Alzette_Diff_trail_round_r
							(search_round, 2,
									Alzette_X[0][1],
									Alzette_X[1][1]);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
					}
				}
				else  //M0 > 0.
				{
					for ( i=0; i<=(N0-M0); i++) A0[i] = 0;
					for ( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
					for ( i = 1; i<=M0; i++) { C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
					T0[N0-M0] = -1;
					T0[1] = 0;
					F0[N0] = N0 - M0 + 1;
					I0 = N0 - M0; L0 = N0;

/*
					if(Bn_w == 5 ){
				//第一种模式输出 //These bits position are SET. LSB-->MSB.
					for( i=1; i<=M0; i++)
					{
						printf("%d\t",C0[i]);
					}
				printf("\n");
					}
*/
					best = Alzette_input_MSB(search_round,
							Input_alpha,
							Input_beta,
							Input_gamma,thr_d,C0);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		return 1;
	}
#endif

////////////////////
				do
				{
					if (I0 == 0)
					{
						break;
					}
					else
					{
						if (T0[I0] < 0)
						{
							if ((-T0[I0]) != (I0-1))
							{
								T0[I0-1] = T0[I0];
							}
							T0[I0] = I0-1;
						}
						if ( A0[I0]==0 )
						{
							X0 = I0;
							Y0 = F0[L0];
							if (A0[I0-1] == 1)
							{
								F0[I0] = F0[I0 - 1];
							}
							else
							{
								F0[I0] = I0;
							}
							if (F0[L0] == L0)
							{
								L0 = I0; I0 = T0[I0];
								goto CHANGE1;
							}
							if (L0 == N0)
							{
								T0[F0[N0]] = -I0 - 1;
								T0[I0 + 1] = T0[I0];
								I0 = F0[N0];
								F0[N0] = F0[N0] + 1;
								goto CHANGE1;
							}
							T0				[L0] = -I0-1;
							T0[I0+1] = T0[I0];
							F0[L0] = F0[L0] + 1;
							I0 = L0;
							goto CHANGE1;
						}
						Y0 = I0;
						if (I0 != L0)
						{
							F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
							if (L0 == N0)
							{
								if (I0 == (F0[N0] - 1))
								{
									I0 = T0[I0];
									goto CHANGE1;
								}
								T0[F0[N0]-1] = -I0-1;
								T0[I0+1] = T0[I0];
								I0 = F0[N0] - 1;
								goto CHANGE1;
							}
							T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0; goto CHANGE1;
						}
						X0 = N0;
						F0[L0 - 1] = F0[L0];
						F0[N0] = N0;
						L0 = N0;
						if (I0 == N0 - 1)
						{
							I0 = T0[N0 - 1];
							goto CHANGE1;
						}
						T0[N0 - 1] = -I0 - 1;
						T0[I0 + 1] = T0[I0];
						I0 = N0 - 1;
			CHANGE1:
					A0[X0] = 1;
					A0[Y0] = 0;
					H0[X0] = Z0 = H0[Y0];
					C0[Z0] = X0;
					}

/////////////////////////////////
			best = Alzette_input_MSB(search_round,
					Input_alpha,
					Input_beta,
					Input_gamma,thr_d,C0);

#if 1   //是否找到第一条最优路径就返回？
			if(best == 1 )
			{
				return 1;
			}
#endif
///////////////////////////////////////
					} while(1);
				}
		}
	}

	return best;
}


u16 Alzette_input_MSB
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi )
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 j_abc = 0;

/*  //只考虑了set-A
	for(j_abc = 0; j_abc < 4;j_abc++)   // MSB
	{
		if((set_A_4[j_abc] & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = V_MSB;
		}
		else
		{
			Input_alpha = 0;  // & Bit_Align;
		}

		if((set_A_4[j_abc] & 0x2) != 0) // beta bit j.
		{
			Input_beta = V_MSB;
		}
		else
		{
			Input_beta = 0; // & Bit_Align;
		}

		if((set_A_4[j_abc] & 0x1) != 0) // gamma bit j.
		{
			Input_gamma = V_MSB;
		}
		else
		{
			Input_gamma = 0;  // & Bit_Align;
		}
*/


	// MSB of of alpha/beta/gamma
	for(j_abc = 0; j_abc < 8;j_abc++)   // MSB
	{
		//set A of MSB.
		if((j_abc==0) || (j_abc==3) || (j_abc==5) || (j_abc==6) )
		{
			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = V_MSB;
			}
			else
			{
				Input_alpha = 0;  // & Bit_Align;
			}

			if((j_abc & 0x2) != 0) // beta bit j.
			{
				Input_beta = V_MSB;
			}
			else
			{
				Input_beta = 0; // & Bit_Align;
			}

			if((j_abc & 0x1) != 0) // gamma bit j.
			{
				Input_gamma = V_MSB;
			}
			else
			{
				Input_gamma = 0;  // & Bit_Align;
			}

			state = Alzette_input_Middle(search_round,
					Input_alpha,Input_beta, Input_gamma,P_1,posi,P_1);
		}
		else //set B of MSB //if((j_abc==1) || (j_abc==2) || (j_abc==4) || (j_abc==7) )
		{
			//对于speck96和speck128,不考虑导致后续比特全确定情况
			//若为{0,3,5,6}则除MSB外其它后面比特全为0
			//若为{1、2、4,7}则除MSB外其它后面比特全为1
		if((j_abc & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = Bit_Align;
		}
		else
		{
			Input_alpha = ValueMax_Align;  // & Bit_Align;
		}

		if((j_abc & 0x2) != 0) // beta bit j.
		{
			Input_beta = Bit_Align;
		}
		else
		{
			Input_beta = ValueMax_Align; // & Bit_Align;
		}

		if((j_abc & 0x1) != 0) // gamma bit j.
		{
			Input_gamma = ValueMax_Align;
		}
		else
		{
			Input_gamma = Bit_Align;  // & Bit_Align;
		}

		state = Alzette_input_Middle(search_round,
				Input_alpha,Input_beta, Input_gamma,P_1,posi,P_1);
		}

		//当只有考虑Set——A时用下面的函数
		//state = Alzette_input_Middle(search_round,Input_alpha,Input_beta, Input_gamma,P_1,posi,P_1);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
}
	return state;
}

//由高位到低位逐步判断
u16 Alzette_input_Middle
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi, u16 cur_posi)
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u64 indx_tmp = 0;
	//u16 i = 0;
	u64 bit_i = 1;


	indx_tmp = posi[cur_posi] - 1;

	// 考虑到产生概率重量的位置为全部可能的状态{3/5/6,1/2/4}
	// Middle bit positionsof of alpha/beta/gamma
	if( cur_posi > 1)  // Middle bit positionsof of alpha/beta/gamma
	{
		//只有{3/5/6,1/2/4}会导致该位置产生概率重量
		for(j_abc = 1; j_abc < 7; j_abc++)   //概率重量位置的可能取值组合
		{
			//判断该位置对应的alpha、beta、gamma的比特值为0还是1；
			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = alpha | (bit_i << indx_tmp);
			}
			else
			{
				//Input_alpha = alpha; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_alpha = (alpha & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x2) != 0) // alpha bit j.
			{
				Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_beta = beta; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_beta = (beta & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x1) != 0) // alpha bit j.
			{
				Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ); // & Bit_Align;
			}


			//判断该位置是属于{3/5/6}，后续比特位置全清0
			if( (j_abc==3) || (j_abc==5) || (j_abc==6) )
			{
				// setA对应到下一个不全同比特位置,全设置为0才满足差分有效性条件.
				for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
				{
					Input_alpha &= ~(bit_i << j_last);
					Input_beta  &= ~(bit_i << j_last);
					Input_gamma &= ~(bit_i << j_last);
				}
			}
			else //判断该位置是属于{1/2/4}，后续比特位置全部置1；
			{
				// setB_3对应到下一个不全同比特位置,全设置为 1 才满足差分有效性条件.
				for(j_last=posi[cur_posi - 1]; j_last < indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
				{
					Input_alpha ^= (bit_i << j_last);
					Input_beta  ^= (bit_i << j_last);
					Input_gamma ^= (bit_i << j_last);
				}
			}


/*  //只考虑了产生概率重量的比特位置为{3/5/6}的情况，可能会忽略部分组合
	//indx_tmp = 1 << (posi[cur_posi] - 1);
	indx_tmp = posi[cur_posi] - 1;

	// Middle bit positionsof of alpha/beta/gamma
	if( cur_posi > 1)  // Middle bit positionsof of alpha/beta/gamma
	{

		//for(j_abc = 1; j_abc < 7; j_abc++)   // MSB //for speck32/48/64
		for(i = 0; i < 3; i++)   // MSB //for speck96/128
		{
			j_abc = set_A_3[i];  //for speck96/128

			if((j_abc & 0x4) != 0) // alpha bit j.
			{
				Input_alpha = alpha | (bit_i << indx_tmp);
			}
			else
			{
				Input_alpha = alpha; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				//Input_alpha = (alpha & ( ~(1 << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x2) != 0) // alpha bit j.
			{
				Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				Input_beta = beta; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				//Input_beta = (beta & ( ~(1 << indx_tmp)) ); // & Bit_Align;
			}

			if((j_abc & 0x1) != 0) // alpha bit j.
			{
				Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
			}
			else
			{
				Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ); // & Bit_Align;
				//Input_gamma = (gamma & ( ~(1 << indx_tmp)) ); // & Bit_Align;
			}
*/

			state = Alzette_input_Middle(search_round,Input_alpha,Input_beta, Input_gamma,P_1,posi,cur_posi-1);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
		}
	}
	else 	//call last position.
	{
		state = Alzette_input_Last(search_round,
				alpha,beta,	gamma,P_1,posi );
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
	}
	return state;
}

u16 Alzette_input_Last
(u16 search_round,u64 alpha, u64 beta, u64 gamma,u16 P_1, char *posi )
{
	u16 state = 0;
	u64 Input_alpha = 0;
	u64 Input_beta = 0;
	u64 Input_gamma = 0;
	u16 j_abc = 0;
	u16 j_last = 0;
	u64 indx_tmp = 0;
	u64 bit_i = 1;


	indx_tmp = posi[1] - 1;

	// 最后的一个产生概率重量的比特位置只能为{3/5/6}，在该位置之后的更低的比特位置都全部清0；
	for(j_abc = 0; j_abc < 3;j_abc++)// Last bit position.
	{
		if((set_A_3[j_abc] & 0x4) != 0) // alpha bit j.
		{
			Input_alpha = alpha | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_alpha = alpha; // & ( ~(1 << indx_tmp))) & Bit_Align;
			Input_alpha = (alpha & ( ~(bit_i << indx_tmp))) & Bit_Align;
		}

		if((set_A_3[j_abc] & 0x2) != 0) // alpha bit j.
		{
			Input_beta = beta | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_beta = beta; // & ( ~(1 << indx_tmp))) & Bit_Align;
			Input_beta = (beta & ( ~(bit_i << indx_tmp))) & Bit_Align;
		}

		if((set_A_3[j_abc] & 0x1) != 0) // alpha bit j.
		{
			Input_gamma = gamma | (bit_i << indx_tmp); // & Bit_Align;
		}
		else
		{
			//Input_gamma = gamma; // & ( ~(1 << indx_tmp)) ) & Bit_Align;
			Input_gamma = (gamma & ( ~(bit_i << indx_tmp)) ) & Bit_Align;
		}

 	 	 // 需要在此将产生概率重量位置更低的比特位置全部清零
		if(posi[1] > 1)  //若产生概率重量的最后一个位置是LSB，则不用清0
			for(j_last=0; j_last< indx_tmp;j_last++ )  // Last position of alpha/beta/gamma set to all 0s.
			{
				Input_alpha &= ~(bit_i << j_last);
				Input_beta  &= ~(bit_i << j_last);
				Input_gamma &= ~(bit_i << j_last);
			}

		//基于构造的第1轮的输入输出差分组合，调用下一轮
		//P_w[1] = P_1;
		Alzette_X[0][0] = Input_alpha;
		Alzette_X[1][0] = Alzette_rol_left_31(Input_beta);
		Alzette_X[0][1] = Input_gamma;  // left part output of fisrt round.
		Alzette_X[1][1] = Alzette_X[1][0] ^ (Alzette_rol_right_24(Input_gamma));

		state = Alzette_Diff_trail_round_r
				(search_round, 2,
						Alzette_X[0][1],
						Alzette_X[1][1]);
#if 1   //是否找到第一条最优路径就返回？
	if(state == 1 )
	{
		return 1;
	}
#endif
	}
	return state;
}


u32 Alzette_Diff_trail_round_r(u16 search_round, u16 cur_round, u64 x, u64 y)
{
	u32 best = 0;
	u64 Alpha = 0;
	u64 Beta = 0;
	u64 gamma_temp = 0;
	u64 xor_alpha_beta = 0;
	u16 w_xor = 0;
	u16	w_cmp = 0;
	u64 i = 0,j = 0;
//	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 alpha_bloc[8] = {0};
	u64 beta_bloc[8] = {0};
	u64 gamma_bloc[8] = {0};
	u64 AB_block[8] = {0};
	u64 carry[8] ={0};
	u64 carry_tmp[8] ={0};
	u8 w_xor_block[8] = {0};
	u64 i0=0,i1=0,i2=0,i3=0;
	u64 j0=0,j1=0,j2=0,j3=0;
	u64 w1=0,w2=0,w3=0;


	if(search_round == cur_round)
	{
		best = Alzette_Diff_trail_round_N(search_round, x, y );
		return best;
	}

	Alpha = x;
	Beta =rol_right_32(y,Alzette_rol_a[cur_round-1]);
	xor_alpha_beta = (Beta ^ Alpha) & ValueMax_Align ;
	w_xor = HM_weight(xor_alpha_beta );
/*
	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
*/
	w_cmp = Bn_w - p_sumof_r_P_w[cur_round -1] - n_P_bestofR_w[search_round - cur_round];
	if ( w_xor > w_cmp)
	{
		return 0;
	}


////////////////////////////选择对应64bit分组版本////////////////////////////
	for(i=0;i<nBytes;i++)  //nBytes
	{
		alpha_bloc[i] = (Alpha >> (8*i)) & 0xFF; //8 bit
		beta_bloc[i]  = (Beta >> (8*i))  & 0xFF; //8 bit
		AB_block[i] = ((alpha_bloc[i] << 8) | beta_bloc[i]);
	}
	for(j=1;j<nBytes;j++)  //nBytes
	{
		w_xor_block[j] = (u8)_mm_popcnt_u64((xor_alpha_beta >> (j*8)));
	}
	carry[0] = 0;
	for(j=1;j<nBytes;j++)  //nBytes
	{
		carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
			+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
	}
/////////////////////
	for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
	{
		if(i0 + w_xor_block[1] > w_cmp ){break;}
	for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
	{
		gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
		//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
		//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
		carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB

	for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
	{
		w1 = i0 + i1;
		if(w1 + w_xor_block[2] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
	{
		gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
		//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
		//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
		carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

	for(i2 = 0; i2 <= cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
	{
		w2 = w1 + i2;
		if(w2 + w_xor_block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
	{
		gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
		//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
		//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
		carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB

	for(i3 = 0; i3 <= MSB_cDDT_wt_max[carry[3]][AB_block[3]]; i3++)
	{
		w3 = w2 + i3;
		if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j3=0; j3 < MSB_cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
	{
		gamma_bloc[3] = MSB_cDDT_v[carry[3]][AB_block[3]][i3][j3];
		gamma_temp = (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
				   | (gamma_bloc[1] <<8) | gamma_bloc[0];


		P_w[cur_round] = w3; //i0 + i1 +i2 +i3;
		p_sumof_r_P_w[cur_round] = p_sumof_r_P_w[cur_round -1] + P_w[cur_round];

		Alzette_X[1][cur_round] = rol_right_32(gamma_temp,Alzette_rol_b[cur_round-1])^y;
		best = Alzette_Diff_trail_round_r(search_round,
				cur_round +1,
				gamma_temp,
				Alzette_X[1][cur_round]);

#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{   //本轮的输出差分
			Alzette_X[0][cur_round] = gamma_temp;
		//	Alzette_X[1][cur_round] = rol_right_32(gamma_temp,Alzette_rol_b[(cur_round-1)%4])^y;
			return 1;
		}
#endif
		}}}}}}}}
	return best;
}



u32 Alzette_Diff_trail_round_N(u16 search_round, u64 x, u64 y)
{
	u32 best = 0;
	u64 Alpha = 0;
	u64 Beta = 0;
	u64 gamma_temp = 0;
	u64 xor_alpha_beta = 0;
	u16 w_xor = 0;
	u16	w_cmp = 0;
	u64 i = 0,j = 0;
//	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u64 alpha_bloc[8] = {0};
	u64 beta_bloc[8] = {0};
	u64 gamma_bloc[8] = {0};
	u64 AB_block[8] = {0};
	u64 carry[8] ={0};
	u64 carry_tmp[8] ={0};
	u8 w_xor_block[8] = {0};
	u64 i0=0,i1=0,i2=0,i3=0;
	u64 j0=0,j1=0,j2=0,j3=0;
	u64 w1=0,w2=0,w3=0;

	Alpha = x;
	Beta = rol_right_32(y,Alzette_rol_a[search_round-1]);
	xor_alpha_beta = (Beta ^ Alpha) & ValueMax_Align ;
	w_xor = HM_weight(xor_alpha_beta );
/*
	for(i=1;i<cur_round;i++)
	{
		p_sumof_r += P_w[i]; // p_sumof_r is the sum of r-1 rounds weight.
	}
*/
	w_cmp = Bn_w - p_sumof_r_P_w[search_round -1];
	if (w_xor > w_cmp)
	{
		return 0;
	}


////////////////////////////选择对应64bit分组版本////////////////////////////
	for(i=0;i<nBytes;i++)  //nBytes
	{
		alpha_bloc[i] = (Alpha >> (8*i)) & 0xFF; //8 bit
		beta_bloc[i]  = (Beta >> (8*i))  & 0xFF; //8 bit
		AB_block[i] = ((alpha_bloc[i] << 8) | beta_bloc[i]);
	}
	for(j=1;j<nBytes;j++)  //nBytes
	{
		w_xor_block[j] = (u8)_mm_popcnt_u64((xor_alpha_beta >> (j*8)));
	}
	carry[0] = 0;
	for(j=1;j<nBytes;j++)  //nBytes
	{
		carry_tmp[j] = ((alpha_bloc[j-1] >> 7) << 2) //alpha MSB
			+ ((beta_bloc[j-1] >> 7) << 1);   //beta MSB
	}
/////////////////////
	for(i0 = 0; i0 <= cDDT_wt_max[carry[0]][AB_block[0]]; i0++)
	{
		if(i0 + w_xor_block[1] > w_cmp ){break;}
	for(j0=0; j0 < cDDT_n[carry[0]][AB_block[0]][i0]; j0++)
	{
		gamma_bloc[0] = cDDT_v[carry[0]][AB_block[0]][i0][j0];
		//carry[1] = ((alpha_bloc[0] >> 7) << 2) //alpha MSB
		//		+ ((beta_bloc[0] >> 7) << 1)   //beta MSB
		carry[1] = carry_tmp[1] + (gamma_bloc[0] >> 7); // gamma MSB

	for(i1 = 0; i1 <= cDDT_wt_max[carry[1]][AB_block[1]]; i1++)
	{
		w1 = i0 + i1;
		if(w1 + w_xor_block[2] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j1=0; j1 < cDDT_n[carry[1]][AB_block[1]][i1]; j1++)
	{
		gamma_bloc[1] = cDDT_v[carry[1]][AB_block[1]][i1][j1];
		//carry[2] = ((alpha_bloc[1] >> 7) << 2) //alpha MSB
		//		+ ((beta_bloc[1] >> 7) << 1)   //beta MSB
		carry[2] = carry_tmp[2] + (gamma_bloc[1] >> 7); // gamma MSB

	for(i2 = 0; i2 <= cDDT_wt_max[carry[2]][AB_block[2]]; i2++)
	{
		w2 = w1 + i2;
		if(w2 + w_xor_block[3] > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
	for(j2=0; j2 < cDDT_n[carry[2]][AB_block[2]][i2]; j2++)
	{
		gamma_bloc[2] = cDDT_v[carry[2]][AB_block[2]][i2][j2];
		//carry[3] = ((alpha_bloc[2] >> 7) << 2) //alpha MSB
		//		+ ((beta_bloc[2] >> 7) << 1)   //beta MSB
		carry[3] = carry_tmp[3] + (gamma_bloc[2] >> 7); // gamma MSB

	for(i3 = 0; i3 <= MSB_cDDT_wt_max[carry[3]][AB_block[3]]; i3++)
	{
		w3 = w2 + i3;
		 //概率满足Matsui条件,找到期望相关性重量的线性路径
		if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.

		for(j3=0; j3 < MSB_cDDT_n[carry[3]][AB_block[3]][i3]; j3++)
			{
				gamma_bloc[3] = MSB_cDDT_v[carry[3]][AB_block[3]][i3][j3];
				gamma_temp = (gamma_bloc[3] << 24) | (gamma_bloc[2] << 16)
						   | (gamma_bloc[1] <<8) | gamma_bloc[0];

				P_w[search_round] = w3; //i0 + i1 +i2 +i3;
		//		p_sumof_r_P_w[search_round] = p_sumof_r_P_w[search_round -1] +P_w[search_round];
				if(P_w[search_round] == w_cmp) //概率满足Matsui条件,找到期望相关性重量的线性路径
				{
				best  = 1;
				n_P_bestofR_w[search_round] = Bn_w;
				Alzette_X[0][search_round] = gamma_temp;  // output part of the r-th round..
				Alzette_X[1][search_round] = rol_right_32(gamma_temp,Alzette_rol_b[search_round-1])^y;
				return best;
				}
		}}}}}}}}
////////////////////////////
return  best;
}


////////////Linear trail search/////////
u32 Alzette_Linear_trail_search_entry(u16 search_round)
{
	u32 best = 0;
	u16 i = 0;
	FILE* Alzette_Linear_Bn;
	u16 Bn_wt_expected = 0;


	Alzette_Linear_Bn = fopen ("../tmp/Alzette_Linear_Bn.xlsx", "a+"); //  "w+"); //

	if(sc_blocksize != 64)
	{
		printf("The block size of Alzette(ARX-Box) should be 64 bits. \n");
		return 0;
	}
	// For Alzette modular additon is 32 bits.
	blocksize_len = 32;
	nBytes = 4;  //分为几个8比特的块
	Bit_Align = 0xFFFFFFFF;
	ValueMax_Align = 0x7FFFFFFF;
	V_MSB = 0x80000000;

	printf("Constructing cLAT Lookup Tables... \n");
	//构造部分的线性相关性近似表cLAT
	ARX_cLAT_construct();
	time_ARX_cLAT = clock();
	run_time =  (time_ARX_cLAT - time_start) / CLOCKS_PER_SEC;
	printf("Time of Construct Alzette cLAT: %.2f seconds.  \n", run_time);

	Bn_w = 0;
	if(search_round > 1)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(Alzette_Linear_Bn,"%d",&n_P_bestofR_w[i]);  //read.
		}
	}

	Bn_w = n_P_bestofR_w[search_round -1] - 1;
	p_sumof_r_P_w[search_round] = 0xFFFF;

	Bn_w = 16;  //直接设定开始的概率重量,快速达到期望的概率重量
			do
			{
				Bn_w = Bn_w + 1;
				printf("Searching Alzette Cor_w: %d \n", Bn_w);

				// Search Entry.
				best = Alzette_Linear_trail_round_1(search_round); //效率高

				time_Round = clock();
				run_time =  (time_Round - time_ARX_cLAT) / CLOCKS_PER_SEC;
				printf("Time: %.2f seconds.  \n", run_time);

				if(best==1){
					Bn_wt_expected =  n_P_bestofR_w[search_round];}
				//printf("best:%d  Bn_wd: %d  n_P_bestofR_w:%d  \n",best, Bn_w, n_P_bestofR_w[search_round]);
			}while(Bn_w != Bn_wt_expected);   //end conditions. // !=

			fprintf(Alzette_Linear_Bn,"%d \n",n_P_bestofR_w[search_round]);  // write.
			print_Alzette_linear_resoult(search_round);  //打印

			time_finish = clock();
			run_time = (double)(time_finish - time_ARX_cLAT) / CLOCKS_PER_SEC;
			printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours == %.2f days. \n", run_time,run_time/60.0,run_time/3600.0,run_time/86400.0 );
			printf("Auto-search %d-Round Alzette optimal Linear trails END! \n", search_round);
			printf("|************************************************************************|\n");
			fclose(Alzette_Linear_Bn);
	return best;
}


u32 Alzette_Linear_trail_round_1(u16 search_round)
{
	u32 best = 0;
	u16 thrd_cor_1 = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码


	u64 M0 = 0;
	u64 N0 = blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;


	///////////////////round 1 entry/////////////////////
	if( search_round == 1)
	{
		return best;
	}
	//这里可以启发式的限制第1/2轮的相关性重量  blocksize_len-1
	for(thrd_cor_1 = 1; thrd_cor_1 < 2 ;thrd_cor_1++)  //0::n-1 //blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if( (thrd_cor_1 + n_P_bestofR_w[search_round - 1]) > Bn_w) // Pmax_compute(xi) is the ri round min weight.
		{
			return 0;  //Return the upper procedure::sepck_differential_trail_search_entry
		}

		M0 = thrd_cor_1;  //
		P_w[1] = M0; //相关性重量的记录数组
		p_sumof_r_P_w[1] = P_w[1];
		if(M0 == 0)  /// abd [0 -> n-2] 没有完全不相同的比特,且MSB之后只能为0
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;
			//直接跳转到第2轮
			best = Alzette_Linear_trail_round_2(search_round,Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			//UVW =7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;
			//直接跳转到第2轮
			best = Alzette_Linear_trail_round_2(search_round,Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for( i = 1; i<=M0; i++){ C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			best = Alzette_ADD_mask_Last(search_round,thrd_cor_1,C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if(I0 == 0)
				{
					break;
				}
				else
				{
					if(T0[I0] < 0)
					{
						if((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if(A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if(F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHANGE_L_1;
						}
						if(L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHANGE_L_1;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHANGE_L_1;
					}
					Y0 = I0;
					if(I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if(L0 == N0)
						{
							if(I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHANGE_L_1;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHANGE_L_1;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHANGE_L_1;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if(I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHANGE_L_1;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
			CHANGE_L_1:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}

///////////////输出其它的分布模式/////////////////
		best = Alzette_ADD_mask_Last(search_round,thrd_cor_1,C0);

#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}
	return best;
}



/////////////////////
u16 Alzette_ADD_mask_Last
(u16 search_round,u16 Corr_1, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;
		//跳转到高比特分析
		//跳转到高比特分析
		best = Alzette_ADD_mask_Middle(search_round,
				Input_u, Input_v, Input_w,
				Corr_1, Corr_inc, posi,
				1,Fwt );

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

		////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;
		//跳转到高比特分析
		//跳转到高比特分析
		best = Alzette_ADD_mask_Middle(search_round,
				Input_u, Input_v, Input_w,
				Corr_1, Corr_inc, posi,
				1,Fwt );

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else  //记录M向量位置0的重量为1，
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = Alzette_ADD_mask_Middle(search_round,
					Input_u, Input_v, Input_w,
					Corr_1, Corr_inc, posi,
					1,Fwt );

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}


//////
u16 Alzette_ADD_mask_Middle(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	if(Corr_tmp_inc >= Corr_1 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = Alzette_ADD_mask_MSB(search_round,
				tmp_U,tmp_V,tmp_W,
				Corr_1, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0
				//跳转到高比特分析
				if(current_index <= blocksize_len -2)
				{
					best = Alzette_ADD_mask_Middle(search_round,
							tmp_U, tmp_V, tmp_W,
							Corr_1, Corr_tmp_inc, posi,
							current_index +1,Fwt );
				}
				else
				{
					best = Alzette_ADD_mask_MSB(search_round,
							tmp_U,tmp_V,tmp_W,
							Corr_1, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
				}

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1
				//跳转到高比特分析
				best = Alzette_ADD_mask_Middle(search_round,
						Input_u, Input_v, Input_w,
						Corr_1, Corr_tmp_inc, posi,
						current_index +1, Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = Alzette_ADD_mask_Middle(search_round,
							Input_u, Input_v, Input_w,
							Corr_1, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = Alzette_ADD_mask_Middle(search_round,
							Input_u, Input_v, Input_w,
							Corr_1, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}

	return best;
}

u16 Alzette_ADD_mask_MSB(u16 search_round,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_1, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
//	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;



	if(Corr_tmp_inc > Corr_1)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
	{
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			//跳转 下一轮   Input_u,Input_v,Input_w
			best = Alzette_Linear_trail_round_2(search_round, tmp_U,tmp_V,tmp_W);
		}
		else
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//跳转 下一轮
			best = Alzette_Linear_trail_round_2(search_round,Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
//	printf("U:0x%08llx   V:0x%08llx    W:0x%08llx  \n",Input_u,Input_v,Input_w);
	//记录并返回UVW
	return 1;
}
#endif
		}
	}
	else
	if( (posi[Corr_1]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
	{
		//Fwt = 0;//当前M向量该比特位无相关性重量
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
			//Input_u = tmp_U | (0 << current_index); //该位置置0
			//Input_v = tmp_V | (0 << current_index); //该位置置0
			//Input_w = tmp_W | (0 << current_index); //该位置置0

			if(current_index <= blocksize_len-2)
			{
				//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
				best = Alzette_ADD_mask_MSB(search_round,
						tmp_U,tmp_V,tmp_W,
						Corr_1, Corr_tmp_inc,posi,
						current_index + 1,Fwt);
			}
			else //直接跳转到第3轮
			{
				//跳转 下一轮   Input_u,Input_v,Input_w
				best = Alzette_Linear_trail_round_2(search_round, tmp_U,tmp_V,tmp_W);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
//	printf("U:0x%08llx   V:0x%08llx    W:0x%08llx  \n",tmp_U,tmp_V,tmp_W);
	//记录并返回UVW
	return 1;
}
			}
#endif
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
			best = Alzette_ADD_mask_MSB(search_round,
					Input_u, Input_v, Input_w,
					Corr_1, Corr_tmp_inc,posi,
					current_index + 1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
	}
	else //////当前M向量该比特位you相关性重量, M_i = 1; (posi[Corr_1]-1) == current_index .
	{
		//Fwt = 1;//当前M向量该比特位you相关性重量
		//Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_B_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_B_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_B_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				//跳转 下一轮
				best = Alzette_Linear_trail_round_2(search_round,Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
//	printf("U:0x%08llx   V:0x%08llx    W:0x%08llx  \n",Input_u,Input_v,Input_w);
	//记录并返回UVW
	return 1;
}
#endif
			}
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_A_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_A_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_A_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				//跳转 下一轮
				best = Alzette_Linear_trail_round_2(search_round,Input_u,Input_v,Input_w);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
//	printf("U:0x%08llx   V:0x%08llx    W:0x%08llx  \n",Input_u,Input_v,Input_w);
	//记录并返回UVW
	return best;
}
#endif
			}
		}
	}
	return best;
}


////
u32 Alzette_Linear_trail_round_2(u16 search_round,
		u64 r1_tmp_U, u64 r1_tmp_V, u64 r1_tmp_W)
{
	u16 best = 0;
	u16 thrd_cor = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
//	u64 Input_tmp_right = 0;  //模加输出掩码

	u64 M0 = 0;
	u64 N0 = blocksize_len-1;
	char A0[65], T0[65], F0[65], H0[65], C0[65];
	volatile char X0, Y0, I0, L0, Z0;
	int i=0;


	///////////////////round 2 entry/////////////////////
	if( search_round == 2)
	{
		return best;
	}
	//这里可以启发式的限制第1/2轮的相关性重量
	for(thrd_cor = 0; thrd_cor < blocksize_len ;thrd_cor++)  //0::n-1 // blocksize_len-1
	{
		// thr_d : 首轮的线性相关性重量递增
		if ((P_w[1] + thrd_cor + n_P_bestofR_w[search_round - 2]) > Bn_w) //
		{
			return 0;  //Return the upper procedure:
		}

		M0 = thrd_cor;  //
		P_w[2] = M0; //相关性重量的记录数组
		p_sumof_r_P_w[2] = P_w[1] + P_w[2];
		if(M0 == 0)  ///
		{
			//uvw的值只能为0或者7
			Input_v = 0;
			Input_w = 0;
			Input_u = 0;

			//第2轮的输入掩码左右两边
			Alzette_X[0][1] = Input_v;
			Alzette_X[1][1] = Alzette_rol_right_24(r1_tmp_U ^ Input_v);

			//第2轮的输出、第3轮的输入掩码
			Alzette_X[1][2] = Alzette_X[1][1] ^ rol_left_32(Input_w,17);
			Alzette_X[0][2] = rol_left_32(Alzette_X[1][2],17) ^ Input_u;

			//直接跳转到第3轮
			best = Alzette_Linear_trail_round_r(search_round, 3,Alzette_X[0][2],Alzette_X[1][2]);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//第1轮的输入掩码左右两边
		Alzette_X[0][0] = r1_tmp_V;
		Alzette_X[1][0] = Alzette_X[1][1] ^ rol_left_32(r1_tmp_W,31); // 第1轮右侧输入掩码
		return 1;
	}
#endif
			//UVW = 7
			Input_v = 1;
			Input_w = 1;
			Input_u = 1;

			//第2轮的输入掩码左右两边
			Alzette_X[0][1] = Input_v;
			Alzette_X[1][1] = Alzette_rol_right_24(r1_tmp_U ^ Input_v);

			//第2轮的输出、第3轮的输入掩码
			Alzette_X[1][2] = Alzette_X[1][1] ^ rol_left_32(Input_w,17);
			Alzette_X[0][2] = rol_left_32(Alzette_X[1][2],17) ^ Input_u;

			//直接跳转到第3轮
			best = Alzette_Linear_trail_round_r(search_round, 3,Alzette_X[0][2],Alzette_X[1][2]);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//第1轮的输入掩码左右两边
		Alzette_X[0][0] = r1_tmp_V;
		Alzette_X[1][0] = Alzette_X[1][1] ^ rol_left_32(r1_tmp_W,31); // 第1轮右侧输入掩码
		return 1;
	}
#endif
		}
		else  //M0 > 0.
		{
			for ( i=0; i<=(N0-M0); i++) A0[i] = 0;
			for ( i=N0-M0+1; i<=N0; i++) A0[i] = 1;
			for ( i = 1; i<=M0; i++) { C0[i] = N0 - M0 + i; H0[N0-M0+i] = i; }
			T0[N0-M0] = -1;
			T0[1] = 0;
			F0[N0] = N0 - M0 + 1;
			I0 = N0 - M0; L0 = N0;

			//第一种模式输出 //These bits position are SET. LSB-->MSB.
			best = Alzette_ADD_mask_Last_2(search_round,
					r1_tmp_U, r1_tmp_V, r1_tmp_W,
					thrd_cor,C0);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	return 1;
}
#endif

////////////////////产生后续的模式
			do
			{
				if (I0 == 0)
				{
					break;
				}
				else
				{
					if (T0[I0] < 0)
					{
						if ((-T0[I0]) != (I0-1))
						{
							T0[I0-1] = T0[I0];
						}
						T0[I0] = I0-1;
					}
					if ( A0[I0]==0 )
					{
						X0 = I0;
						Y0 = F0[L0];
						if (A0[I0-1] == 1)
						{
							F0[I0] = F0[I0 - 1];
						}
						else
						{
							F0[I0] = I0;
						}
						if (F0[L0] == L0)
						{
							L0 = I0; I0 = T0[I0];
							goto CHANGE_L_2;
						}
						if (L0 == N0)
						{
							T0[F0[N0]] = -I0 - 1;
							T0[I0 + 1] = T0[I0];
							I0 = F0[N0];
							F0[N0] = F0[N0] + 1;
							goto CHANGE_L_2;
						}
						T0[L0] = -I0-1;
						T0[I0+1] = T0[I0];
						F0[L0] = F0[L0] + 1;
						I0 = L0;
						goto CHANGE_L_2;
					}
					Y0 = I0;
					if (I0 != L0)
					{
						F0[L0] = X0 = F0[L0] - 1; F0[I0 - 1] = F0[I0];
						if (L0 == N0)
						{
							if (I0 == (F0[N0] - 1))
							{
								I0 = T0[I0];
								goto CHANGE_L_2;
							}
							T0[F0[N0]-1] = -I0-1;
							T0[I0+1] = T0[I0];
							I0 = F0[N0] - 1;
							goto CHANGE_L_2;
						}
						T0[L0] = -I0 -1; T0[I0 + 1] = T0[I0]; I0 = L0;
						goto CHANGE_L_2;
					}
					X0 = N0;
					F0[L0 - 1] = F0[L0];
					F0[N0] = N0;
					L0 = N0;
					if (I0 == N0 - 1)
					{
						I0 = T0[N0 - 1];
						goto CHANGE_L_2;
					}
					T0[N0 - 1] = -I0 - 1;
					T0[I0 + 1] = T0[I0];
					I0 = N0 - 1;
	CHANGE_L_2:
				A0[X0] = 1;
				A0[Y0] = 0;
				H0[X0] = Z0 = H0[Y0];
				C0[Z0] = X0;
				}

///////////////输出其它的分布模式/////////////////
				best = Alzette_ADD_mask_Last_2(search_round,
						r1_tmp_U, r1_tmp_V, r1_tmp_W,
						thrd_cor,C0);
#if 1   //是否找到第一条最优路径就返回？
		if(best == 1 )
		{
			return 1;
		}
#endif
///////////////////////////////////////
	} while(1);
	}
	}
	return best;
}



/////////////////////
u16 Alzette_ADD_mask_Last_2(u16 search_round,
		u64 r1_tmp_U, u64 r1_tmp_V, u64 r1_tmp_W,
		u16 Corr_2, char *posi )
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 j_last = 0;
	u16 Corr_inc = 1;

	if( (posi[Corr_inc]-1) != 0 ) //最低的M向量最低位无相关性重量
	{
		Fwt = 0; //记录M向量位置0的重量为0，并传递给更高一比特

		//uvw的值只能为0或者7
		Input_v = 0;
		Input_w = 0;
		Input_u = 0;
		//跳转到高比特分析
		//跳转到高比特分析
		best = Alzette_ADD_mask_Middle_2(search_round,
				r1_tmp_U, r1_tmp_V, r1_tmp_W,
				Input_u, Input_v, Input_w,
				Corr_2, Corr_inc, posi,
				1,Fwt );

#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif

	////uvw的值只能为0或者7
		Input_v = 1;
		Input_w = 1;
		Input_u = 1;

		//跳转到高比特分析
		best = Alzette_ADD_mask_Middle_2(search_round,
				r1_tmp_U, r1_tmp_V, r1_tmp_W,
				Input_u, Input_v, Input_w,
				Corr_2, Corr_inc, posi,
				1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		Fwt = 1; //记录M向量位置0的重量为1，并传递给更高一比特
		Corr_inc++; //已经构造的相关性重量累加1

		//uvw的值可能为0--7
		for(j_last=0; j_last<8; j_last++)
		{
			//U
			if((j_last & 0x4) != 0) // Input_u
			{
				Input_u = 1;
			}
			else
			{
				Input_u = 0;
			}

			//V
			if((j_last & 0x2) != 0) //Input_v
			{
				Input_v = 1;
			}
			else
			{
				Input_v = 0;
			}

			//W
			if((j_last & 0x1) != 0) //Input_w
			{
				Input_w = 1;
			}
			else
			{
				Input_w = 0;
			}

			//跳转到高比特分析
			best = Alzette_ADD_mask_Middle_2(search_round,
					r1_tmp_U, r1_tmp_V, r1_tmp_W,
					Input_u, Input_v, Input_w,
					Corr_2, Corr_inc, posi,
					1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
		}
	}
	return best;
}


//////
u16 Alzette_ADD_mask_Middle_2(u16 search_round,
		u64 r1_tmp_U, u64 r1_tmp_V, u64 r1_tmp_W,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_2, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码

	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	//u16 j_abc = 0;
	u16 i = 0;


	if(Corr_tmp_inc >= Corr_2 ) // 相关性重量大于1时,组合模式的数组的下标校验M向量的有重量的最高比特位
	{
		best = Alzette_ADD_mask_MSB_2(search_round,
				r1_tmp_U, r1_tmp_V, r1_tmp_W,
				tmp_U,tmp_V,tmp_W,
				Corr_2, Corr_tmp_inc,posi,
				current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
	}
	else
	{
		if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
		{
			Fwt = 0;//当前M向量该比特位无相关性重量

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
				//Input_u = tmp_U | (0 << current_index); //该位置置0
				//Input_v = tmp_V | (0 << current_index); //该位置置0
				//Input_w = tmp_W | (0 << current_index); //该位置置0
				//跳转到高比特分析
				if(current_index <= blocksize_len -2)
				{
					best = Alzette_ADD_mask_Middle_2(search_round,
							r1_tmp_U, r1_tmp_V, r1_tmp_W,
							tmp_U, tmp_V, tmp_W,
							Corr_2, Corr_tmp_inc, posi,
							current_index +1, Fwt );
				}
				else
				{
					best = Alzette_ADD_mask_MSB_2(search_round,
							r1_tmp_U, r1_tmp_V, r1_tmp_W,
							tmp_U,tmp_V,tmp_W,
							Corr_2, Corr_tmp_inc,posi,
							current_index,pre_cor_0or1);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为7
				Input_u = tmp_U | (bit_i << current_index); //该位置置1
				Input_v = tmp_V | (bit_i << current_index); //该位置置1
				Input_w = tmp_W | (bit_i << current_index); //该位置置1
				//跳转到高比特分析
				best = Alzette_ADD_mask_Middle_2(search_round,
						r1_tmp_U, r1_tmp_V, r1_tmp_W,
						Input_u, Input_v, Input_w,
						Corr_2, Corr_tmp_inc, posi,
						current_index +1, Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
			}
		}
		else //////当前M向量该比特位you相关性重量, M_i = 1;
		{
			Fwt = 1;//当前M向量该比特位you相关性重量
			Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

			if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
			{
				// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_B_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_B_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_B_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = Alzette_ADD_mask_Middle_2(search_round,
							r1_tmp_U, r1_tmp_V, r1_tmp_W,
							Input_u, Input_v, Input_w,
							Corr_2, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
			else // 上一个更低比特的M位置的相关性重量为 1.
			{
				// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
				for(i=0; i<4; i++ )
				{
					//U
					if( (set_A_4[i] & 0x4) != 0)
					{
						Input_u = tmp_U | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_u = tmp_U; //该位置默认为0;
					}

					//V
					if( (set_A_4[i] & 0x2) != 0)
					{
						Input_v = tmp_V | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_v = tmp_V; //该位置默认为0;
					}

					//W
					if( (set_A_4[i] & 0x1) != 0)
					{
						Input_w = tmp_W | (bit_i << current_index); //该位置置1
					}
					else
					{
						Input_w = tmp_W; //该位置默认为0;
					}

					//跳转到高比特分析
					best = Alzette_ADD_mask_Middle_2(search_round,
							r1_tmp_U, r1_tmp_V, r1_tmp_W,
							Input_u, Input_v, Input_w,
							Corr_2, Corr_tmp_inc +1, posi,
							current_index +1,Fwt );
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//记录并返回UVW
		return 1;
	}
#endif
				}
			}
		}
	}
	return best;
}

u16 Alzette_ADD_mask_MSB_2(u16 search_round,
		u64 r1_tmp_U, u64 r1_tmp_V, u64 r1_tmp_W,
		u64 tmp_U, u64 tmp_V, u64 tmp_W,
		u16 Corr_2, u16 Corr_tmp_inc, char *posi,
		u16 current_index, u16 pre_cor_0or1)
{
	u16 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
///	u64 Input_tmp_right = 0;  //模加输出掩码
	u16 Fwt = 0;
	u16 Corr_inc = 0; //已经构造的相关性重量累加1
	u64 bit_i = 1;
	u16 i = 0;


	//printf("OK \n");
	if(Corr_tmp_inc > Corr_2)  //搜索的当前wt要比期望的相关性重量大，已经构造完毕
	{
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			//第2轮的输入掩码左右两边
			Alzette_X[0][1] = tmp_V;
			Alzette_X[1][1] = Alzette_rol_right_24(r1_tmp_U ^ tmp_V);

			//第1轮的输入掩码左右两边
			Alzette_X[0][0] = r1_tmp_V;
			Alzette_X[1][0] = Alzette_X[1][1] ^ rol_left_32(r1_tmp_W,31); // 第1轮右侧输入掩码

			//第2轮的输出、第3轮的输入掩码
			Alzette_X[1][2] = Alzette_X[1][1] ^ rol_left_32(tmp_W,17);
			Alzette_X[0][2] = rol_left_32(Alzette_X[1][2],17) ^ tmp_U;

			//直接跳转到第3轮
			best = Alzette_Linear_trail_round_r(search_round, 3,Alzette_X[0][2],Alzette_X[1][2]);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//第1轮的输入掩码左右两边
//		Alzette_X[0][0] = r1_tmp_V;
//		Alzette_X[1][0] = Alzette_X[1][1] ^ rol_left_32(r1_tmp_W,31); // 第1轮右侧输入掩码
		return 1;
	}
#endif
		}
		else
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//第2轮的输入掩码左右两边
			Alzette_X[0][1] = Input_v;
			Alzette_X[1][1] = Alzette_rol_right_24(r1_tmp_U ^ Input_v);

			//第1轮的输入掩码左右两边
			Alzette_X[0][0] = r1_tmp_V;
			Alzette_X[1][0] = Alzette_X[1][1] ^ rol_left_32(r1_tmp_W,31); // 第1轮右侧输入掩码

			//第2轮的输出、第3轮的输入掩码
			Alzette_X[1][2] = Alzette_X[1][1] ^ rol_left_32(Input_w,17);
			Alzette_X[0][2] = rol_left_32(Alzette_X[1][2],17) ^ Input_u;

			//直接跳转到第3轮
			best = Alzette_Linear_trail_round_r(search_round, 3,Alzette_X[0][2],Alzette_X[1][2]);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//第1轮的输入掩码左右两边
		Alzette_X[0][0] = r1_tmp_V;
		Alzette_X[1][0] = Alzette_X[1][1] ^ rol_left_32(r1_tmp_W,31); // 第1轮右侧输入掩码
		return 1;
	}
#endif
		}
	}
	else
	if( (posi[Corr_tmp_inc]-1) != current_index) //当前M向量该比特位无相关性重量,M_i = 0;
	{
		//Fwt = 0;//当前M向量该比特位无相关性重量
		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为0,可以不用管，默认相应的UVW的位置为0
			//Input_u = tmp_U | (0 << current_index); //该位置置0
			//Input_v = tmp_V | (0 << current_index); //该位置置0
			//Input_w = tmp_W | (0 << current_index); //该位置置0

			if(current_index <= blocksize_len-2)
			{
			//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
			best = Alzette_ADD_mask_MSB_2(search_round,
					r1_tmp_U, r1_tmp_V, r1_tmp_W,
					tmp_U,tmp_V,tmp_W,
					Corr_2, Corr_tmp_inc,posi,
					current_index + 1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//第1轮的输入掩码左右两边
//		Alzette_X[0][0] = r1_tmp_V;
//		Alzette_X[1][0] = Alzette_X[1][1] ^ rol_left_32(r1_tmp_W,31); // 第1轮右侧输入掩码
		return 1;
	}
#endif
			}
			else //直接跳转到第3轮
			{
				//第2轮的输入掩码左右两边
				Alzette_X[0][1] = tmp_V;
				Alzette_X[1][1] = Alzette_rol_right_24(r1_tmp_U ^ tmp_V);

				//第2轮的输出、第3轮的输入掩码
				Alzette_X[1][2] = Alzette_X[1][1] ^ rol_left_32(tmp_W,17);
				Alzette_X[0][2] = rol_left_32(Alzette_X[1][2],17) ^ tmp_U;

				//直接跳转到第3轮
				best = Alzette_Linear_trail_round_r(search_round, 3,Alzette_X[0][2],Alzette_X[1][2]);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//第1轮的输入掩码左右两边
		Alzette_X[0][0] = r1_tmp_V;
		Alzette_X[1][0] = Alzette_X[1][1] ^ rol_left_32(r1_tmp_W,31); // 第1轮右侧输入掩码
		return 1;
	}
#endif
			}
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为7
			Input_u = tmp_U | (bit_i << current_index); //该位置置1
			Input_v = tmp_V | (bit_i << current_index); //该位置置1
			Input_w = tmp_W | (bit_i << current_index); //该位置置1

			//if(current_index >= blocksize_len-2){printf("OK lenene 2 \n"); return 0;}
			//跳转 下一位置,直到相关性重量的位置与坐标相互匹配
			best = Alzette_ADD_mask_MSB_2(search_round,
					r1_tmp_U, r1_tmp_V, r1_tmp_W,
					Input_u, Input_v, Input_w,
					Corr_2, Corr_tmp_inc,posi,
					current_index + 1,Fwt);
#if 1   //是否找到第一条最优路径就返回？
if(best == 1 )
{
	//记录并返回UVW
	return 1;
}
#endif
		}
	}
	else //////当前M向量该比特位you相关性重量, M_i = 1;
	{
		//Fwt = 1;//当前M向量该比特位you相关性重量
		//Corr_inc = Corr_tmp_inc + 1; //已经构造的相关性重量累加1

		if( pre_cor_0or1 == 0 ) // 上一个更低比特的M位置的相关性重量为 0.
		{
			// UVW_i 为u16 set_B_4[4] = {1,2,4,7};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_B_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_B_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_B_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				//第2轮的输入掩码左右两边
				Alzette_X[0][1] = Input_v;
				Alzette_X[1][1] = Alzette_rol_right_24(r1_tmp_U ^ Input_v);

				//第2轮的输出、第3轮的输入掩码
				Alzette_X[1][2] = Alzette_X[1][1] ^ rol_left_32(Input_w,17);
				Alzette_X[0][2] = rol_left_32(Alzette_X[1][2],17) ^ Input_u;

				//直接跳转到第3轮
				best = Alzette_Linear_trail_round_r(search_round, 3,Alzette_X[0][2],Alzette_X[1][2]);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//第1轮的输入掩码左右两边
		Alzette_X[0][0] = r1_tmp_V;
		Alzette_X[1][0] = Alzette_X[1][1] ^ rol_left_32(r1_tmp_W,31); // 第1轮右侧输入掩码
		return 1;
	}
#endif
			}
		}
		else // 上一个更低比特的M位置的相关性重量为 1.
		{
			// UVW_i 为u16 set_A_4[4] = {0,3,5,6};
			for(i=0; i<4; i++ )
			{
				//U
				if( (set_A_4[i] & 0x4) != 0)
				{
					Input_u = tmp_U | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_u = tmp_U; //该位置默认为0;
				}

				//V
				if( (set_A_4[i] & 0x2) != 0)
				{
					Input_v = tmp_V | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_v = tmp_V; //该位置默认为0;
				}

				//W
				if( (set_A_4[i] & 0x1) != 0)
				{
					Input_w = tmp_W | (bit_i << current_index); //该位置置1
				}
				else
				{
					Input_w = tmp_W; //该位置默认为0;
				}

				//UVW的最高位为7
				Input_u = Input_u | (bit_i << (current_index +1)); //该位置置1
				Input_v = Input_v | (bit_i << (current_index +1)); //该位置置1
				Input_w = Input_w | (bit_i << (current_index +1)); //该位置置1

				//第2轮的输入掩码左右两边
				Alzette_X[0][1] = Input_v;
				Alzette_X[1][1] = Alzette_rol_right_24(r1_tmp_U ^ Input_v);

				//第2轮的输出、第3轮的输入掩码
				Alzette_X[1][2] = Alzette_X[1][1] ^ rol_left_32(Input_w,17);
				Alzette_X[0][2] = rol_left_32(Alzette_X[1][2],17) ^ Input_u;

				//直接跳转到第3轮
				best = Alzette_Linear_trail_round_r(search_round, 3,Alzette_X[0][2],Alzette_X[1][2]);
#if 1   //是否找到第一条最优路径就返回？
	if(best == 1 )
	{
		//第1轮的输入掩码左右两边
		Alzette_X[0][0] = r1_tmp_V;
		Alzette_X[1][0] = Alzette_X[1][1] ^ rol_left_32(r1_tmp_W,31); // 第1轮右侧输入掩码
		return 1;
	}
#endif
			}
		}
	}
	return best;
}


/////
u32 Alzette_Linear_trail_round_r(u16 search_round, u16 cur_round, u64 x, u64 y)
{
	u32 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
//	u64 Output_tmp_right = 0;  //模加输出掩码
//	u16 i = 0;
//	u16 p_sumof_r = 0; // p_sumof_r is the sum of r-1 rounds weight.
	u16	w_cmp = 0;
	u64 v_block[8] = {0}; //按照8比特进行切片
	u64 w_block[8] = {0};
	u64 u_block[8] = {0};
	u64 e_Mxor[8] ={0}; //用于记录M向量的高比特的异或和
	u64 i0=0,i1=0,i2=0,i3=0;
	u64 j0=0,j1=0,j2=0,j3=0;
	u64 j = 0;
	u64 w1=0,w2=0,w3=0;
	u16 wt_cor_bound = 0;
	u64 wt_block_min[8] ={0};


	if(cur_round == search_round)
	{
		best = Alzette_Linear_round_N(search_round,x, y);
		return best;
	}

	w_cmp = Bn_w - p_sumof_r_P_w[cur_round -1] - n_P_bestofR_w[search_round - cur_round];
	Input_v = x;
//	printf("Input_v: %x  \n", Input_v);

	for(j=0;j<nBytes;j++)  //nBytes
	{
		//从MSB向LSB的方向进行分块
		v_block[j] = (Input_v >> 8*(nBytes - j-1)) & 0xFF; // 8 bit
		wt_block_min[j] = cLAT_wtcor_min[v_block[j]][0]; //借位假设为ie=0时最小
		wt_cor_bound += wt_block_min[j];
	}
	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}
///////////////////////////////////
	for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
	{
		if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
		for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
		{
			w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
			u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
			e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];

	for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
	{
		w1 = i0 + i1;
		if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
		{
			w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
			u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
			e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];

	for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
	{
		w2 = w1 + i2;
		if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
		{
			w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
			u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];
			e_Mxor[3] = cLAT_UVW_bro[u_block[2]][v_block[2]][w_block[2]][e_Mxor[2]];

	for(i3 = cLAT_wtcor_min[v_block[3]][e_Mxor[3]]; i3 <= 8; i3++)
	{
		w3 = w2 + i3;
		if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < cLAT_WU_numb[v_block[3]][e_Mxor[3]][i3]; j3++)
		{
			w_block[3] = cLAT_W[v_block[3]][e_Mxor[3]][i3][j3];
			u_block[3] = cLAT_U[v_block[3]][e_Mxor[3]][i3][j3];

			Input_w = (w_block[0] << 24) | (w_block[1] << 16) |
					(w_block[2] << 8) | w_block[3];  //模加输入右侧掩码
			Input_u = (u_block[0] << 24) | (u_block[1] << 16) |
					(u_block[2] << 8) | u_block[3];  //模加输入右侧掩码

			//第cur_round轮的输入掩码左右两边
			Alzette_X[1][cur_round] = y ^ rol_left_32(Input_w, Alzette_rol_a[cur_round-1]); //右侧输出掩码
			Alzette_X[0][cur_round] = Input_u ^
									rol_left_32(Alzette_X[1][cur_round], Alzette_rol_b[cur_round-1]); //左侧输出掩码
			P_w[cur_round] = w3;  //当前cur_round轮的线性相关性重量
			p_sumof_r_P_w[cur_round] = p_sumof_r_P_w[cur_round -1] + P_w[cur_round];
			//跳转 下一轮
			best = Alzette_Linear_trail_round_r(search_round,
					cur_round + 1,
					Alzette_X[0][cur_round], Alzette_X[1][cur_round]);
#if 1   //是否找到第一条最优路径就返回？
		if( best == 1 )
		{
			return 1;
		}
#endif
				}}}}}}}}
	return best;
}

/////
u32 Alzette_Linear_round_N(u16 search_round, u64 x, u64 y)
{
	u32 best = 0;
	u64 Input_v = 0;  //模加输入左侧掩码,通过该固定值索引其它两个值u和w
	u64 Input_w = 0;  //模加输入右侧掩码
	u64 Input_u = 0;  //模加输出掩码
	u16	w_cmp = 0;
	u64 v_block[8] = {0}; //按照8比特进行切片
	u64 w_block[8] = {0};
	u64 u_block[8] = {0};
	u64 e_Mxor[8] ={0}; //用于记录M向量的高比特的异或和
	u64 i0=0,i1=0,i2=0,i3=0;
	u64 j0=0,j1=0,j2=0,j3=0;
	u64 j = 0;
	u64 w1=0,w2=0,w3=0;
	u16 wt_cor_bound = 0;
	u64 wt_block_min[8] ={0};

//	printf("OK---------last round--------OK \n");
	Input_v = x;
	w_cmp = Bn_w - p_sumof_r_P_w[search_round -1];
///////////////////////////
	for(j=0;j<nBytes;j++)  //nBytes
	{
		//从MSB向LSB的方向进行分块
		v_block[j] = (Input_v >> 8*(nBytes - j-1)) & 0xFF; //MSB 8 bit
		wt_block_min[j] = cLAT_wtcor_min[v_block[j]][0]; //借位假设为ie=0时最小
		wt_cor_bound += wt_block_min[j];
	}
	if( wt_cor_bound > w_cmp)  //求最小相关性重量的可能值，非常重要，否则会导致大量分支，更加费时间
	{
		return 0;
	}
//	printf("OK---------last round--?????------OK \n");
	for(i0 = cLAT_wtcor_min[v_block[0]][e_Mxor[0]]; i0 < 8; i0++)
	{
		if(i0 > w_cmp ){return 0;}  //break 要比 continue 高效,直接结束return.
		for(j0=0; j0 < cLAT_WU_numb[v_block[0]][e_Mxor[0]][i0]; j0++)
		{
			w_block[0] = cLAT_W[v_block[0]][e_Mxor[0]][i0][j0];
			u_block[0] = cLAT_U[v_block[0]][e_Mxor[0]][i0][j0];
			e_Mxor[1] = cLAT_UVW_bro[u_block[0]][v_block[0]][w_block[0]][e_Mxor[0]];

	for(i1 = cLAT_wtcor_min[v_block[1]][e_Mxor[1]]; i1 <= 8; i1++)
	{
		w1 = i0 + i1;
		if(w1 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j1=0; j1 < cLAT_WU_numb[v_block[1]][e_Mxor[1]][i1]; j1++)
		{
			w_block[1] = cLAT_W[v_block[1]][e_Mxor[1]][i1][j1];
			u_block[1] = cLAT_U[v_block[1]][e_Mxor[1]][i1][j1];
			e_Mxor[2] = cLAT_UVW_bro[u_block[1]][v_block[1]][w_block[1]][e_Mxor[1]];

	for(i2 = cLAT_wtcor_min[v_block[2]][e_Mxor[2]]; i2 <= 8; i2++)
	{
		w2 = w1 + i2;
		if(w2 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j2=0; j2 < cLAT_WU_numb[v_block[2]][e_Mxor[2]][i2]; j2++)
		{
			w_block[2] = cLAT_W[v_block[2]][e_Mxor[2]][i2][j2];
			u_block[2] = cLAT_U[v_block[2]][e_Mxor[2]][i2][j2];
			e_Mxor[3] = cLAT_UVW_bro[u_block[2]][v_block[2]][w_block[2]][e_Mxor[2]];

	for(i3 = cLAT_wtcor_min[v_block[3]][e_Mxor[3]]; i3 <= 8; i3++)
	{
		w3 = w2 + i3;
		 //概率满足Matsui条件,找到期望相关性重量的线性路径
		if(w3 > w_cmp ){break;}  //break 要比 continue 高效,直接结束.
		for(j3=0; j3 < cLAT_WU_numb[v_block[3]][e_Mxor[3]][i3]; j3++)
		{
			w_block[3] = cLAT_W[v_block[3]][e_Mxor[3]][i3][j3];
			u_block[3] = cLAT_U[v_block[3]][e_Mxor[3]][i3][j3];

			Input_w = (w_block[0] << 24) | (w_block[1] << 16) |
					(w_block[2] << 8) | w_block[3];  //模加输入右侧掩码
			Input_u = (u_block[0] << 24) | (u_block[1] << 16) |
					(u_block[2] << 8) | u_block[3];  //模加输入右侧掩码

			//第search_round轮的输入掩码左右两边
			Alzette_X[1][search_round] = y ^ rol_left_32(Input_w, Alzette_rol_a[search_round-1]); //右侧输出掩码
			Alzette_X[0][search_round] = Input_u ^
									rol_left_32(Alzette_X[1][search_round], Alzette_rol_b[search_round-1]); //左侧输出掩码

			P_w[search_round] = w3;  //当前轮的线性相关性重量
			p_sumof_r_P_w[search_round] = p_sumof_r_P_w[search_round -1] + P_w[search_round];

#if 1   //是否找到第一条最优路径就返回？
			if(P_w[search_round] == w_cmp) //概率满足Matsui条件,找到期望相关性重量的线性路径
			{
				//printf("OK------------------------OK \n");
				best = 1;
				n_P_bestofR_w[search_round] = p_sumof_r_P_w[search_round];  //Bn_w;
				return best;
			}
#endif
			}}}}}}}}
	return 0;
}


/**
 * @Search for the min weight of DP of r Round of SIMON completely.
 * @ MOde_0
 */
u16 findMinDPWeightDifferentialTrail (u16 search_round)
{
	printf("----------------Search Optimal Differential Trail-------------------\n");

	if(search_round == 0)  // 0 rounds.
	{
		n_P_bestofR_w[0] = 0;
		return 1;
	}

	if( strcmp(str_cipher,"simon") == 0)
	{
		// SIMON differential trail search.
		search_entry(search_round);
		print_resoult(search_round);
	}
	else
	if( strcmp(str_cipher,"simeck") == 0)
	{
		// SIMECK differential trail search.
		search_entry(search_round);
		print_resoult(search_round);
	}
	else
	if( strcmp(str_cipher,"speck") == 0)
	{
		// SPECK differential trail search.
		sepck_differential_trail_search_entry(search_round);
	}
	else
	if( strcmp(str_cipher,"hight") == 0)
	{
		// HIGHT differential trail search.
		HIGHT_differential_trail_search_entry(search_round);
	}
	else
	if( strcmp(str_cipher,"sparx") == 0)
	{
		//str_cipher[10] = "SPARX64";

		if( sc_blocksize == 64 )
		{
		// SPARX-64 optimal differential trail search.
		SPARX64_differential_trail_search_entry(search_round);
		}
		else
		{
		// SPARX-64 optimal differential trail search.
		SPARX_128_differential_trail_search_entry(search_round);
		}
	}
	else
	if( strcmp(str_cipher,"cham") == 0)
		{
			if( sc_blocksize == 64 )
			{
			// CHAM-64 optimal differential trail search.
				CHAM_64_Diff_trail_search_entry( search_round);
			}
			else
			{
				// CHAM-128 optimal differential trail search.
				CHAM_128_Diff_trail_search_entry( search_round);
			}
		}
	else
	if( strcmp(str_cipher,"alzette") == 0)
	{
		if( sc_blocksize == 64 )
		{
		// Alzette optimal differential trail search.
			Alzette_Diff_trail_search_entry( search_round);
		}
		else
		{
			printf("Error! The block size of Alzette(ARX-Box) should be 64 bits. \n");
		}
	}
	else
	if( strcmp(str_cipher,"gimli") == 0)
	{
		// GIMLI differential trail search.
		GIMLI_differential_trail_search_entry(search_round);
	}


	time_finish = clock();
	run_time =  (double)(time_finish - time_start) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours. \n", run_time,run_time/60.0,run_time/3600.0 );
	printf("Auto-search END! \n");
	printf("|************************************************************************|\n");


	fclose(simon_diff_trail); // close the files in tmp.
	fclose(best_Bn);

	return 1;
}
/**
 * @Search for the Differential of SIMON.
 * @ MOde:1
 */
u16 find_Differntial_characteristic (u16 search_round)
{
	int i=0;
	FILE* diff_prob;
	diff_prob = fopen ("../tmp/diff_prob.xlsx", "w+"); //"a+"); //


	printf("--------------------Search Differntials Characteristic-------------------\n");
	memset(wt_nmu,0,sizeof(wt_nmu)); //内存清零函数



	if( strcmp(str_cipher,"simon") == 0)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		// SIMON differential search.
		round_1_diff(search_round);  // Search Entry.
	}
	else
	if( strcmp(str_cipher,"simeck") == 0)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		// SIMECK differential search.
		round_1_diff(search_round);  // Search Entry.
	}
	else
	if( strcmp(str_cipher,"speck") == 0)
	{
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(speck_best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		// SPECK differential search.
		bit_align_fun();

		memset(cDDT_v,0,sizeof(MSB_cDDT_v)); //内存清零函数
		memset(cDDT_n,0,sizeof(MSB_cDDT_n)); //内存清零函数
		memset(cDDT_wt_max,0,sizeof(MSB_cDDT_wt_max)); //内存清零函数
		memset(MSB_cDDT_v,0,sizeof(MSB_cDDT_v)); //内存清零函数
		memset(MSB_cDDT_n,0,sizeof(MSB_cDDT_n)); //内存清零函数
		memset(MSB_cDDT_wt_max,0,sizeof(MSB_cDDT_wt_max)); //内存清零函数

		ARX_carry_DDTm_construct();

		time_ARX_DDT = clock();
		run_time =  (time_ARX_DDT - time_start) / CLOCKS_PER_SEC;
		printf("Time of Construct ARX_DDT: %.2f seconds.  \n", run_time);

		sepck_round_1_diff(search_round);
	}
	else
	if( strcmp(str_cipher,"gimli") == 0)
	{
		// GIMLI differential trail search.
		//GIMLI_differential_trail_search_entry(search_round);
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}

		//????
	}



	printf("--------------------Search Differntial Characteristic-------------------\n");
	printf("++++++++++++++++++\n ");
	switch(blocksize_len)
	{
	case 16:
		fprintf(diff_prob,"input_diff  \t %04x \t %04x \n",input_diff_L,input_diff_R);
		fprintf(diff_prob,"output_diff \t %04x \t %04x \n",output_diff_L,output_diff_R);
		fprintf(diff_prob,"weight  \t wt_num \t prob_sum \n");

		for(i=0;i<=((wt_max<wt_ctr_max)?wt_ctr_max:wt_max);i++)  // 超过wt_max的也统计
		//for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)  // 超过wt_max的也统计
		{
			prob = prob + (wt_nmu[i] * pow(2,-i));
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(diff_prob,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
		printf("++++++++++++++++++\n ");
		printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
		printf("input:0x%04x %04x ======>> output:0x%04x %04x \n",input_diff_L,input_diff_R,output_diff_L,output_diff_R);
		break;
	case 24:
		fprintf(diff_prob,"input_diff  \t %06x \t %06x \n",input_diff_L,input_diff_R);
		fprintf(diff_prob,"output_diff  \t %06x \t %06x \n",output_diff_L,output_diff_R);
		fprintf(diff_prob,"weight  \t wt_num \t prob_sum \n");

		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
		{
			prob = prob + (wt_nmu[i] * pow(2,-i));
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(diff_prob,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
		printf("++++++++++++++++++\n ");
		printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
		printf("input:0x%06x %06x ======>> output:0x%06x %06x \n",input_diff_L,input_diff_R,output_diff_L,output_diff_R);
		break;
	case 32:
		fprintf(diff_prob,"input_diff  \t %08x \t %08x \n",input_diff_L,input_diff_R);
		fprintf(diff_prob,"output_diff  \t %08x \t %08x \n",output_diff_L,output_diff_R);
		fprintf(diff_prob,"weight  \t wt_num \t prob_sum \n");

		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
		{
			prob = prob + (wt_nmu[i] * pow(2,-i));
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(diff_prob,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
		printf("++++++++++++++++++\n ");
		printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
		printf("input:0x%08x %08x ======>> output:0x%08x %08x \n",input_diff_L,input_diff_R,output_diff_L,output_diff_R);
		break;
	case 48:
		fprintf(diff_prob,"input_diff  \t %012x \t %012x \n",input_diff_L,input_diff_R);
		fprintf(diff_prob,"output_diff  \t %012x \t %012x \n",output_diff_L,output_diff_R);
		fprintf(diff_prob,"weight  \t wt_num \t prob_sum \n");

		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
		{
			prob = prob + (wt_nmu[i] * pow(2,-i));
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(diff_prob,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
		printf("++++++++++++++++++\n ");
		printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
		printf("input:0x%012x %012x ======>> output:0x%012x %012x \n",input_diff_L,input_diff_R,output_diff_L,output_diff_R);
		break;
	default:  //64
		fprintf(diff_prob,"input_diff  \t %016x \t %016x \n",input_diff_L,input_diff_R);
		fprintf(diff_prob,"output_diff  \t %016x \t %016x \n",output_diff_L,output_diff_R);
		fprintf(diff_prob,"weight  \t wt_num \t prob_sum \n");

		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
		{
			prob = prob + (wt_nmu[i] * pow(2,-i));
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(diff_prob,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
		printf("++++++++++++++++++\n ");
		printf("cipher: %s %d \n ",str_cipher,sc_blocksize);
		printf("input:0x%016x %016x ======>> output:0x%016x %016x \n",input_diff_L,input_diff_R,output_diff_L,output_diff_R);
		break;
	}
	printf(" wt_min(:*)--->wt_max: -%d \n",wt_max);
	printf(" %d Rounds Differential with total %d trails.\n",search_round,count);
	printf(" Probability weight is: %.2Lf \n",prob_w);
	fprintf(diff_prob,"trails_cnt \t %d \n prob_weight \t %.2Lf \n",count,prob_w);
	printf("++++++++++++++++++\n ");


	time_Round = clock();
	run_time =  (time_Round - time_start) / CLOCKS_PER_SEC;
	printf("Time: %.2f seconds.  \n", run_time);
	fprintf(diff_prob,"time_cost \t %.2f \n " , run_time);
	fclose(diff_prob);

	time_finish = clock();
	run_time =  (double)(time_finish - time_start) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours. \n", run_time,run_time/60.0,run_time/3600.0 );
	printf("Auto-search END! \n");
	printf("|************************************************************************|\n");

	return 1;
}
/**
 * @Search for the min weight of LC of SIMON of N rounds.
 * @ MOde_1
 */
u16 findMinDPWeightLinearTrail(u16 search_round)
{
	u16 i = 0;

	printf("----------------Search Optimal Linear Trail-------------------\n");

	if(search_round == 0)  // 0 rounds.
	{
		n_P_bestofR_w[0] = 0;
		return 1;
	}

	simon_linear_trail = fopen ("../tmp/simon_linear_trail.xlsx", "w+"); //"a+"); //
	fprintf(simon_linear_trail,"Rounds  \t x \t y \t P_w \t n_P_bestofR_w\n"); // write.
	best_Bn_linear = fopen ("../tmp/best_Bn_w_linear.xlsx", "a+"); //  "w+"); //


	///
	if( strcmp(str_cipher,"simon") == 0)
	{
		// SIMON linear trail search.

		if(search_round > 2)
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(best_Bn_linear,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		Bn_w = n_P_bestofR_w[search_round-1] - 1;

	#if 1  //round 2 search from Bn_w >= 2.
		if(search_round == 2)
			Bn_w = 1;
	#endif

		do
		{
			Bn_w = Bn_w + 1;
			printf("Searching Bn_w: %d \n", Bn_w);

			round_1_Lineartrail(search_round);  //Linear Search Entry.

			time_Round = clock();
			run_time =  (time_Round - time_start) / CLOCKS_PER_SEC;
			printf("Time: %.2f seconds.  \n", run_time);
		}while(Bn_w !=  n_P_bestofR_w[search_round]);   //end conditions.
		fprintf(best_Bn_linear,"%d \n",n_P_bestofR_w[search_round]);  // write.

		print_resoult(search_round);
	}
	else
	if( strcmp(str_cipher,"simeck") == 0)
	{
		// SIMECK linear trail search.
		if(search_round > 2)
		for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
		{
			fscanf(best_Bn_linear,"%d",&n_P_bestofR_w[i]);  //read.
			//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
		}
		Bn_w = n_P_bestofR_w[search_round-1] - 1;

	#if 1  //round 2 search from Bn_w >= 2.
		if(search_round == 2)
			Bn_w = 1;
	#endif

		do
		{
			Bn_w = Bn_w + 1;
			printf("Searching Bn_w: %d \n", Bn_w);

			round_1_Lineartrail(search_round);  // Search Entry.

			time_Round = clock();
			run_time =  (time_Round - time_start) / CLOCKS_PER_SEC;
			printf("Time: %.2f seconds.  \n", run_time);
		}while(Bn_w !=  n_P_bestofR_w[search_round]);   //end conditions.
		fprintf(best_Bn_linear,"%d \n",n_P_bestofR_w[search_round]);  // write.

		print_resoult(search_round);
	}
	else
	if( strcmp(str_cipher,"speck") == 0)
	{
		// SPECK linear trail search.
		sepck_linear_trail_search_entry(search_round);
	}
	else
	if( strcmp(str_cipher,"gimli") == 0)
	{
		// GIMLI linear trail search.
		//GIMLI_differential_trail_search_entry(search_round);
	}
	else
	if( strcmp(str_cipher,"alzette") == 0)
	{
		// alzette optimal linear trail search.
		Alzette_Linear_trail_search_entry(search_round);
	}

	if( strcmp(str_cipher,"sparx") == 0)
	{
		if( sc_blocksize == 64 )
		{
		// SPARX-64 optimal linear trail search.
		SPARX64_linear_trail_search_entry(search_round);
		}
		else
		{
		// SPARX-64 optimal differential trail search.
		SPARX128_linear_trail_search_entry(search_round);
		}
	}
	else
		if( strcmp(str_cipher,"chaskey") == 0)
		{
			Chaskey_Linear_trail_search_entry(search_round);
		}
	else
		if( strcmp(str_cipher,"cham") == 0)
		{
			if( strcmp(str_blocksize,"64") == 0)
			{
				CHAM_64_Linear_trail_search_entry((u16)sc_rounds);
			}
			else
			{
				if( strcmp(str_blocksize,"128") == 0)
				{
					CHAM_128_Linear_trail_search_entry((u16)sc_rounds);;
				}
				else
				{
					printf("Error! . \n" );
				}
			}
		}

	fclose(simon_linear_trail); // close the files in tmp.
	fclose(best_Bn_linear);


	time_finish = clock();
	run_time =  (double)(time_finish - time_start) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours. \n", run_time,run_time/60.0,run_time/3600.0 );
	printf("Auto-search END! \n");
	printf("|************************************************************************|\n");


	return 1;
}
/**
 * @Search for the Differential of SIMON.
 * @ MOde:3
 */
u16 find_linearHull_characteristic (u16 search_round)
{
	int i=0;
	FILE* linear_sqcor;
	linear_sqcor = fopen ("../tmp/linear_sqcor.xlsx", "w+"); //"a+"); //

	for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
	{
		fscanf(best_Bn_linear,"%d",&n_P_bestofR_w[i]);  //read.
		//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
	}

	printf("--------------------Search Linear Hulls-------------------\n");

	memset(wt_nmu,0,sizeof(wt_nmu)); //内存清零函数

	round_1_LinearHull(search_round);  //Linear Search Entry.

	printf("--------------------Search Linear Hulls-------------------\n");
	printf("++++++++++++++++++++++++++++++++++++\n ");


	switch(blocksize_len)
	{
	case 16:
		fprintf(linear_sqcor,"input_mask \t %04x \t %04x \n",input_mask_L,input_mask_R);
		fprintf(linear_sqcor,"output_mask \t %04x \t %04x \n",output_mask_L,output_mask_R);
		fprintf(linear_sqcor,"weight  \t wt_num \t prob_sum \n");

		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)  // 超过wt_max的也统计
		{
			prob = prob + (wt_nmu[i] * pow(2,-i));
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(linear_sqcor,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
		printf("++++++++++++++++++++++++++++++++++++\n ");
		printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
		printf("input:0x%04x %04x ======>> output:0x%04x %04x \n",input_mask_L,input_mask_R,output_mask_L,output_mask_R);
		break;
	case 24:
		fprintf(linear_sqcor,"input_mask  \t %06x \t %06x \n",input_mask_L,input_mask_R);
		fprintf(linear_sqcor,"output_mask  \t %06x \t %06x \n",output_mask_L,output_mask_R);
		fprintf(linear_sqcor,"weight  \t wt_num \t prob_sum \n");

		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
		{
			prob = prob + (wt_nmu[i] * pow(2,-i));
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(linear_sqcor,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
		printf("++++++++++++++++++++++++++++++++++++\n ");
		printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
		printf("input:0x%06x %06x ======>> output:0x%06x %06x \n",input_mask_L,input_mask_R,output_mask_L,output_mask_R);
		break;
	case 32:
		fprintf(linear_sqcor,"input_mask  \t %08x \t %08x \n",input_mask_L,input_mask_R);
		fprintf(linear_sqcor,"output_mask  \t %08x \t %08x \n",output_mask_L,output_mask_R);
		fprintf(linear_sqcor,"weight  \t wt_num \t prob_sum \n");

		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
		{
			prob = prob + (wt_nmu[i] * pow(2,-i));
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(linear_sqcor,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
		printf("++++++++++++++++++++++++++++++++++++\n ");
		printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
		printf("input:0x%08x %08x ======>> output:0x%08x %08x \n",input_mask_L,input_mask_R,output_mask_L,output_mask_R);
		break;
	case 48:
		fprintf(linear_sqcor,"input_mask  \t %012x \t %012x \n",input_mask_L,input_mask_R);
		fprintf(linear_sqcor,"output_mask  \t %012x \t %012x \n",output_mask_L,output_mask_R);
		fprintf(linear_sqcor,"weight  \t wt_num \t prob_sum \n");

		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
		{
			prob = prob + (wt_nmu[i] * pow(2,-i));
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(linear_sqcor,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
		printf("++++++++++++++++++++++++++++++++++++\n ");
		printf("cipher: %s_%d \n ",str_cipher,sc_blocksize);
		printf("input:0x%012x %012x ======>> output:0x%012x %012x \n",input_mask_L,input_mask_R,output_mask_L,output_mask_R);
		break;
	default:  //64
		fprintf(linear_sqcor,"input_mask  \t %016x \t %016x \n",input_mask_L,input_mask_R);
		fprintf(linear_sqcor,"output_mask  \t %016x \t %016x \n",output_mask_L,output_mask_R);
		fprintf(linear_sqcor,"weight  \t wt_num \t prob_sum \n");

		for(i=0;i<=((wt_max<Bn_w)?Bn_w:wt_max);i++)
		{
			prob = prob + (wt_nmu[i] * pow(2,-i));
			prob_w = log(prob) / log(2); //prob_w = log(prob) / log(2);
			printf("wt:-%d   wt_num:%d   prob_sum:%Lf \n",i,wt_nmu[i],prob_w);
			fprintf(linear_sqcor,"-%d \t %d  \t %Lf \n",i,wt_nmu[i],prob_w);
		}
		printf("++++++++++++++++++++++++++++++++++++\n ");
		printf("cipher: %s %d \n ",str_cipher,sc_blocksize);
		printf("input:0x%016x %016x ======>> output:0x%016x %016x \n",input_mask_L,input_mask_R,output_mask_L,output_mask_R);
		break;
	}
	printf(" wt_min(:*)--->wt_max: -%d \n",wt_max);
	printf(" %d Rounds Linear Hull with total %d trails.\n",search_round,count);
	printf(" Square Correlation weight is: %.2Lf \n",prob_w);
	fprintf(linear_sqcor,"trails_cnt \t %d \n prob_weight \t %.2Lf \n",count,prob_w);
	printf("++++++++++++++++++++++++++++++++++++\n ");


	time_Round = clock();
	run_time =  (time_Round - time_start) / CLOCKS_PER_SEC;
	printf("Time: %.2f seconds.  \n", run_time);
	fprintf(linear_sqcor,"time_cost \t %.2f \n " , run_time);
	fclose(linear_sqcor);

	time_finish = clock();
	run_time =  (double)(time_finish - time_start) / CLOCKS_PER_SEC;
	printf( "Time cost: %.2f seconds ==  %.2f minutes == %.2f hours. \n", run_time,run_time/60.0,run_time/3600.0 );
	printf("Auto-search END! \n");
	printf("|************************************************************************|\n");


	return 1;
}



void bit_align_fun(void)
{
	switch(sc_blocksize)
	{
	case 32:
		Bit_Align = 0xFFFF;
		ValueMax_Align = 0x7FFF;
		V_MSB = 0x8000;

		break;
	case 48:
		Bit_Align = 0x00FFFFFF;
		ValueMax_Align = 0x007FFFFF;
		V_MSB = 0x800000;

		break;
	case 64:
		Bit_Align = 0xFFFFFFFF;
		ValueMax_Align = 0x7FFFFFFF;
		V_MSB = 0x80000000;

		break;
	case 96:
		Bit_Align = 0xFFFFFFFFFFFF;
		ValueMax_Align = 0x7FFFFFFFFFFF;
		V_MSB = 0x800000000000;

		break;
	case 128:
		Bit_Align = 0xFFFFFFFFFFFFFFFF;
		ValueMax_Align = 0x7FFFFFFFFFFFFFFF;
		V_MSB = 0x8000000000000000;

		break;
	default:
		Bit_Align = 0xFFFF;  //32bit default.
		//ValueMax = 0xFFFF;
		ValueMax_Align = 0x7FFF;
		break;
	}
}


/**
 * @ Search for the Differential of GIMLI.
 * @ MOde:0
 */
u16 GIMLI_differential_trail_search_entry (u16 search_round)
{
	u16 i = 0;


	memset(gimli_hwval_space,0,sizeof(gimli_hwval_space)); //内存清零函数
	memset(gimli_hwval_space,0,sizeof(gimli_hwspace_num)); //内存清零函数
	gimli_hw_space();

	time_Round = clock();
	run_time =  (time_Round - time_start) / CLOCKS_PER_SEC;
	printf("Time: %.2f seconds.  \n", run_time);


	if(search_round > 2)
	for(i=1; i < search_round; i++)  //搜索n轮，需要先搜索前n-1轮得到P_bestofR_w。
	{
		fscanf(best_Bn,"%d",&n_P_bestofR_w[i]);  //read.
		//printf("n_P_bestofR_w[%d]: %d \n",i,n_P_bestofR_w[i]);  // write.
	}
	Bn_w = n_P_bestofR_w[search_round-1] - 1;

	do
	{
		Bn_w = Bn_w + 1;
		printf("Searching Bn_w: %d \n", Bn_w);

		gimli_round_1(search_round);  // GIMLI first round Search Entry.

		time_Round = clock();
		run_time =  (time_Round - time_start) / CLOCKS_PER_SEC;
		printf("Time: %.2f seconds.  \n", run_time);
	}while(Bn_w !=  n_P_bestofR_w[search_round]);   //end conditions.
	fprintf(best_Bn,"%d \n",n_P_bestofR_w[search_round]);  // write.


	return 1;
}

/**
 * @ GIMLI search hw_val space.
 * @
 */
void gimli_hw_space(void)
{
	u64 i = 0;
	u64 numb = 0;
	u16 hweight = 0;
	u64 ValueMax = 0xFFFFFFFF;

	while( hweight<= 4)   // 6 in 32
	{
		numb = 0;
		i = 0;
		while(i<=ValueMax)
		{
			if(hweight == HM_weight(i))
			{
				gimli_hwval_space[hweight][numb] = i;
				numb += 1;
			}
			i++;
		}
		gimli_hwspace_num[hweight] = numb;
		hweight++;
	}

}


/**
 * @Search for the min weight of DP of the Last Round of GIMLI.
 * @
 */
u16 gimli_round_N(u16 search_round)
{


	return 1;
}
/**
 * @Search for the min weight of DP of the r-th Round of GIMLI.
 * @
 */
u16 gimli_round_r(u16 search_round)
{



	return 1;
}

/**
 * @Search for the min weight of DP of the first Round of GIMLI.
 * @
 */
u16 gimli_round_1(u16 search_round)
{
	u64 H_val = 0;
	u64 H_tmp = 0;
	u16 H_wt = 0;
	u16 H_wt_0 = 0;
	u16 H_wt_1 = 0;
	u16 H_wt_2 = 0;
	u16 H_wt_3 = 0;
	u16 best = 0;
	u16 p_alpha = 0; // p with the input alpha (x | y | z).
	u16 HW_space_num = 0;
	u16 i=0;
	u16 k=0;

	if( search_round == 1)   // 0 - 0
	{
		best = 1;
		return best;
	}

	// 汉明重量逐渐增加
	for(H_wt=0;H_wt<128;H_wt++)  // alpha hamming weight 0-n wordsize. pow(2,n).
	{
		p_alpha = 2 * H_wt;

		// Matsui condition.
		if ( ( p_alpha + n_P_bestofR_w[search_round - 1]) > Bn_w) // Limited the input hamming weight.
		{
			return 0;  //alpha hamming weight increased,the Pmax will be decreased,and Pmax weight be increase.
		}

		for(H_wt_0=0;H_wt_0 <=H_wt;H_wt_0++ )
			for(H_wt_1=0;H_wt_1 <=H_wt;H_wt_1++ )
				for(H_wt_2=0;H_wt_2 <=H_wt;H_wt_2++ )
					for(H_wt_3=0;H_wt_3 <=H_wt;H_wt_3++ )   // Each H in 128 bit.
					{
						if((H_wt_0 + H_wt_1 + H_wt_2 + H_wt_3) == H_wt)
						{
							if(H_wt_0 == 0)
							{
								GIMLI_state_word[0][0] = 0;  // input
								GIMLI_state_word[0][1] = 0;
								GIMLI_state_word[0][2] = 0;

								GIMLI_state_word[1][0] = 0;  // output
								GIMLI_state_word[1][1] = 0;
								GIMLI_state_word[1][2] = 0;
							}
							else
							{
								HW_space_num = gimli_hwspace_num[H_wt_0];  // The number of value of the corresponding H_wt_0.
								//printf("Searching HW_space_num: %d \n", HW_space_num);

								for (k=0;k < HW_space_num;k++)
								{
									H_val = gimli_hwval_space[H_wt_0][k]; //H_val=x|y|z in a SPbox with 32 bit
									H_tmp = H_val;
									i = 0;
									while ( H_tmp != 0 )  //遍历
									{
										if((H_tmp & 0x01) == 1)  // this position is not zero.
										{
											//index;

										}
										H_tmp >>= 1;   // 右移一位
										i++;
									}

									for(i=1;i<8;i++)
									{
									GIMLI_state_word[0][0] |= (gimli_OR_table[i][0] & 0x01) << i; // input
									GIMLI_state_word[0][1] |= (gimli_OR_table[i][0] & 0x02) << i;
									GIMLI_state_word[0][2] |= (gimli_OR_table[i][0] & 0x04) << i;
									}

								}
							}

						}

					}
	}

	return best;
}



